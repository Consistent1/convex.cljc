{}


;;;;;;;;;;


(.t.def ..state.core.vanilla

  (def core.genesis
       (get-in (.state.genesis)
               [:accounts
                (long .account.core)]))

  (def core
       (get-in (.state.core.vanilla *state*)
               [:accounts
                (long .account.core)]))

  (.t.is (= (:environment core.genesis)
            (:environment core))
         "Environment")

  (.t.is (= (:metadata core.genesis)
            (:metadata core))
         "Metadata")

  (.t.is (.t.ex :ARGUMENT
                (.state.core.vanilla :fail))
         "Not a State"))



(.t.def ..state.do


  (.t.is (= true
            (.state.do (fn []
                         (def a
                              :a)))))

  (.t.is (= :a
            a)
         "State preserved on success")

  (.t.is (= false
            (.state.do (fn []
                         (def a
                              :b)
                         (fail :FROM-TEST
                               42)))))

  (.t.is (= :a
            a)
         "State reverted on failure"))



(.t.def ..state.do*


  (.t.is (= true
            (.state.do*
              (def a
                   :a))))

  (.t.is (= :a
            a)
         "State preserved on success")

  (.t.is (= false
            (.state.do* 
              (def a
                   :b)
              (fail :FROM-TEST
                    42))))

  (.t.is (= :a
            a)
         "State reverted on failure"))



(.t.def ..state.genesis

  (.t.is (= (.state.genesis)
            (.state.genesis {:pubkey+ [(.kp.pubkey (.kp.create .account.0-key))]}))
         "Default public key")

  (.t.is (.t.ex :ARGUMENT
                (.state.genesis {:pubkey+ []}))
         "Missing keys")

  (.t.is (.t.ex :ARGUMENT
                (.state.genesis {:pubkey+ [.account.0-key
                                           .account.0-key]}))
         "Duplicate keys")

  (.t.is (.t.ex :ARGUMENT
                (.state.genesis {:pubkey+ [.account.0-key
                                           0x12]}))
         "Bad key")

  (.t.is (.t.ex :ARGUMENT
                (.state.genesis {:pubkey+ 42}))
         "Random argument")

  (.t.is (reduce (fn [_ [_k peer]]
                   (or (let [c (:controller peer)]
                         (and (= {:url (str c)}
                                 (:metadata peer))
                              (= (long c)
                                 (:stake peer))))
                       (reduced peer)))
                 false
                 (:peers (.state.genesis {:each-peer '(fn [peer]
                                                        (let [c (:controller peer)
                                                              k (:key peer)]
                                                          (set-peer-data k
                                                                         {:url (str c)})
                                                          (set-peer-stake k
                                                                          (long c))))
                                          :pubkey+   [(.kp.pubkey (.kp.create))
                                                      (.kp.pubkey (.kp.create))]})))
         ":each-peer"))



(.t.def ..state.safe


  (.t.is (= [true
             :a]
            (.state.safe (fn []
                           (def a
                                :a)))))

  (.t.is (= :a
            a)
         "State preserved on success")


  (def failure
       (.state.safe (fn []
                      (def a
                           :b)
                      (fail :FROM-TEST
                            42))))
       
  (.t.is (= false
            (first failure)))

  (.t.is (= :a
            a)
         "State reverted on failure")

  (.t.is (.t.ex :FROM-TEST
                (.ex.rethrow (second failure)))
         "Exception was properly captured")

  (.t.is (.t.ex :ARITY
                (.ex.rethrow (second (.state.safe (fn [_x])))))
         "Must be no-arg function")

  (.t.is (.t.ex :ARGUMENT
                (.state.safe 42))
         "Random argument"))



(.t.def ..state.safe*


  (.t.is (= [true
             :a]
            (.state.safe*
              (def a
                   :a))))

  (.t.is (= :a
            a)
         "State preserved on success")


  (def failure
       (.state.safe*
         (def a
              :b)
         (fail :FROM-TEST
               42)))
       
  (.t.is (= false
            (first failure)))

  (.t.is (= :a
            a)
         "State reverted on failure")

  (.t.is (.t.ex :FROM-TEST
                (.ex.rethrow (second failure)))
         "Exception was properly captured"))



(.t.def ..state.tmp


  (.t.is (= [true
             :a]
            (.state.tmp (fn []
                          (def a
                               :a)))))


  (.t.is (not (defined? a))
         "State reverted on success")

  (def failure
       (.state.tmp (fn []
                     (def a
                          :b)
                     (fail :FROM-TEST
                           42))))
       
  (.t.is (= false
            (first failure)))

  (.t.is (not (defined? a))
         "State reverted on failure")

  (.t.is (.t.ex :FROM-TEST
                (.ex.rethrow (second failure)))
         "Exception was properly captured")

  (.t.is (.t.ex :ARITY
                (.ex.rethrow (second (.state.tmp (fn [_x])))))
         "Must be no-arg function")

  (.t.is (.t.ex :ARGUMENT
                (.state.tmp 42))
         "Random argument"))



(.t.def ..state.tmp*


  (.t.is (= [true
             :a]
            (.state.tmp*
              (def a
                   :a))))


  (.t.is (not (defined? a))
         "State reverted on success")

  (def failure
       (.state.tmp*
         (def a
              :b)
         (fail :FROM-TEST
               42)))
       
  (.t.is (= false
            (first failure)))

  (.t.is (not (defined? a))
         "State reverted on failure")

  (.t.is (.t.ex :FROM-TEST
                (.ex.rethrow (second failure)))
         "Exception was properly captured"))
