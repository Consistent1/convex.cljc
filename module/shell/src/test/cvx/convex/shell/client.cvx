{}


;;;;;;;;;;


(.t.def ..client.connect

  ;; Also tests `.client.close`.

  (.try.resrc* [client (.client.connect {:host "convex.world"})
                       (.client.close client)]
    (.t.is (boolean client)))


  (.t.is (.t.ex :ARGUMENT
                (.client.connect {:host :fail}))
         "Bad host")

  (.t.is (.t.ex :ARGUMENT
                (.client.connect {:port :fail}))
         "Bad port")

  (.t.is (.t.ex :SHELL.CLIENT
                (.client.connect {:host "azertyazerty"}))
         "Inexistent host, cannot connect"))



(.t.def ..client.peer.status

  (def kp
       (.kp.create))

  (def pubkey
       (.kp.pubkey kp))

  (def state
       (.state.genesis {:pubkey+ [pubkey]}))

  (def state.hash
       (hash (encoding state)))

  (def status
       (.try.resrc* [peer   (.peer.start (.peer.init kp
                                                     {:state state}))
                            (.peer.stop peer)
                     client (.client.connect)
                            (.client.close client)]
         (.a.take (.client.peer.status client)
                  2000
                  :timeout)))

  (.t.is (blob? (:hash.belief status))
         "Belief hash")

  (.t.is (= state.hash
            (:hash.state.consensus status))
         "Consensus state hash")

  (.t.is (= state.hash
            (:hash.state.genesis status))
         "Genesis state hash")

  (.t.is (zero? (:n.block status))
         "Ordering length")

  (.t.is (zero? (:point.consensus status))
         "Consensus point")

  (.t.is (zero? (:point.proposal status))
         "Proposal point")

  (.t.is (= pubkey
            (:pubkey status))
         "Pubkey"))



(.t.def ..client.query

  (.try.resrc* [client (.client.connect {:host "convex.world"})
                       (.client.close client)]

    (def result
         (.a.take (.client.query client
                                 #2
                                 '(inc 42))
                  4000
                  :timeout))

    (.t.is (nil? (:error result)))

    (.t.is (long? (:id result)))

    (.t.is (nil? (:info result)))

    (.t.is (= 43
              (:result result)))

    (.t.is (.t.ex :ARGUMENT
                  (.client.query client
                                 :fail
                                 '(inc 42)))
           "Not an address"))

  (.t.is (.t.ex :ARGUMENT
                (.client.query :fail
                               #2
                               '(inc 42)))
         "Not a client"))



(.t.def ..client.query.state

  ^:slow?

  (.try.resrc* [client (.client.connect {:host "convex.world"})
                       (.client.close client)]
    (.t.is (= #{:accounts
                :globals
                :peers
                :schedule}
           (set (keys (.a.take (.client.query.state client)))))))

  (.t.is (.t.ex :ARGUMENT
                (.client.query.state :fail))
         "Not a client"))



(.t.def ..client.sequence

  (.try.resrc* [client (.client.connect {:host "convex.world"})
                       (.client.close client)]

    (.t.is (= 1
              (.a.take (.client.sequence client
                                         #0)))
           "Existing account")

    (.t.is (nil? (.a.take (.client.sequence client
                                            #1000000000000)))
           "Inexistent account")))



(.t.def ..client.transact

  (def kp
       (.kp.create))

  (def addr
       (.a.take (.testnet.create-account (.kp.pubkey kp))))

  (.t.is (= 100000000
            (.a.take (.testnet.faucet addr
                                      100000000)
                     4000
                     :timeout))
         "Requested coins")

  (.try.resrc* [client (.client.connect {:host "convex.world"})
                       (.client.close client)]

    (def result
         (.a.take (.client.transact client
                                    kp
                                    (.trx.new.invoke addr
                                                     '(def foo
                                                           (inc 42))
                                                     {:sequence 1}))
                  4000
                  :timeout))

    (.t.is (nil? (:error result)))

    (.t.is (long? (:id result)))

    (.t.is (nil? (:info result)))

    (.t.is (= 43
              (:result result)))

    (.t.is (= 43
              (:result (.a.take
                         (.client.query client
                                        addr
                                        'foo)
                         4000
                         :timeout)))
           "Confirm transaction with a query")

    (.t.is (= 44
              (:result (.a.take
                         (.client.transact client
                                           (.kp.sign kp
                                                     (.trx.new.invoke addr
                                                                      '(def foo
                                                                            (inc foo))
                                                                      {:sequence 2}))))))
           "Pre-signed transaction")

    (.t.is (.t.ex :ARGUMENT
                  (.client.transact client
                                    :fail
                                    (.trx.new.invoke addr
                                                     '(def foo
                                                           (inc 42))
                                                     {:sequence 3})))
           "Not a key pair")

    (.t.is (.t.ex :ARGUMENT
                  (.client.transact client
                                    kp
                                    :fail))
           "Not a transaction")))
