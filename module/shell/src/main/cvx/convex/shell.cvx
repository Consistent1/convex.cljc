;;
;; CONVEX SHELL LIBRARY
;;
;; Unlocks all the extra features offered by the Shell through `.shell.invoke`.
;;


;;;;;;;;;; Miscellaneous helpers, private and public


(defn .docoll

  ^:private?

  [f coll]

  (let [n (count coll)]
    (loop [i 0]
      (if (< i
             n)
        (do
          (f (nth coll
                  i))
          (recur (inc i)))
        nil))))



(defn .prn

  ^{:doc {:description "Prints arguments in a vector using `.stream.outln`."
          :examples    [{:code (.prn :a :b :c)}]
          :signature   [{:params [& arg+]}]}}

  [& arg+]

  (.stream.outln arg+))


;;;;;;;;;; Account


(def .account

  ^{:private?      true
    :shell.section ["Utilities centered on Convex accounts."
                    "Notably, see `.account.switch`."]}

  nil)



(def .account.0-key

  ^{:doc {:description "Fake key, useful for turning an actor into a user account with `set-key`."}}

  0x0000000000000000000000000000000000000000000000000000000000000000)



(def .account.core

  ^{:doc {:description "Address of the core account where all core functions are defined."}}

  $CORE$)



(defn .account.key?

  ^{:doc {:description "Returns true if `x` is a 32-byte blob that can act as a key."
          :examples    [{:code (.account.key? $.account/fake-key)}
                        {:code (.account.key? 42)}]
          :signature   [{:params [x]}]}}

  [x]

  (and (blob? x)
       (= (count x)
          32)))



(def .account.genesis

  ^{:doc {:description "Address of the account used when starting the Shell."}}

  .account.genesis)



(defn .account.switch

  ^{:doc {:description ["Switches the execution context to the given address."]
          :examples    [{:code (.account.switch #3)}]
          :signature   [{:params [address]}]}}

  [address]

  (.shell.invoke '.account.switch
                 address))


;;;;;;;;;; Benchmarking


(def .bench

  ^{:private?      true
    :shell.section ["Benchmarking utilities, more will be provided in the future."]}

  nil)



(defn .bench.trx

  ^{:doc {:description ["Benchmarks the mean execution time of the given transaction."
                        "Any state change is reverted each time."
                        ""
                        "Returns a map with:"
                        ""
                        "  :mean"
                        "    Mean execution time (nanoseconds)"
                        "  :stddev"
                        "    Standard deviation (nanoseconds)"
                        "Executed in a query a high number of times."
                        ""
                        "Highly experimental and subject to change, probably useful for CVM developers only."
                        "Depending on the given transaction, takes between one and several minutes to complete."]
          :examples    [{:code (.bench.trx '(+ 2 2))}
                        {:code (.bench.trx (compile '(+ 2 2)))}]
          :signature   [{:params [trx]}]}}


  [trx]

  (.shell.invoke '.bench.trx
                 trx))


;;;;;;;;;; Dependency management


(def .dep
  
  ^{:private?      true
    :shell.section ["Experimental dependency management framework."
                    ""
                    "Convex Lisp dependencies are expressed in a `project.cvx` file"
                    "residing in the root directory of your project."
                    ""
                    "Currently, 3 types of dependencies are supported:"
                    ""
                    "  :relative"
                    "    Project files relative to your `project.cvx` file."
                    "    Expressed as a vector `[:relative \"./path/inside/project\"]`."
                    ""
                    "  :local"
                    "    Local directory containing its own `project.cvx` file."
                    "    Expressed as a vector `[:local \"/path/to/another-project\"]`."
                    ""
                    "  :git"
                    "    Git repository containing its own `project.cvx` file."
                    "    Those will be cloned in a local cached found in `.shell.*root*`."
                    "    Expressed as a vector `[:git \"URL\" \"FULL_COMMIT_SHA\"]`."
                    ""
                    ""
                    "Here is an example of a `project.cvx` file showcasing those 3 types:"
                    ""
                    "  {:deps {main            [:relative \"./src/main\"]"
                    "          another-project [:local \"/home/foo/another-project\"]"
                    "          some-lib        [:git \"https://github.com/foo/bar\""
                    "                                \"38a44d086c95c7b190f47ea17712da130906495f\"]}}"
                    ""
                    "  `main`"
                    "     indicates that the project files can be found under `./src/main`."
                    ""
                    "  `another-project`"
                    "     points to a directory which should contain its own `project.cvx`,"
                    "     typically defining its own relative dependencies."
                    ""
                    "  `some-lib`"
                    "     points to a foreign Git repository that will be cloned locally if not"
                    "     found in the local cache, and that specific commit will be used."
                    ""
                    ""
                    "Inside a relative directory, files meant to be deployed in the Shell as"
                    "actors can be referred to by following the directory hierarchy. This is known"
                    "as the \"actor path\", expressed as a list."
                    ""
                    "E.g. Suppose the above example project defines a file at `./src/main/a/b.cvx`."
                    "     Its actor path would be: (main a b)"
                    "     Now, any other files in your project can require it by adding a similar map"
                    "     as a header which specifies a \"deploy vector\":"
                    ""
                    "        {:deploy [a.b (main a b)]}"
                    ""
                    "     In the requiring file, this will instruct the Shell to deploy `(main a b)` as"
                    "     an actor and its address will be bound to the chosen symbol, `a.b` in this case."
                    "     Such a deploy vector can refer to any number of actor paths."
                    ""
                    "Actor paths are recursive. If `some-lib`, in its own `project.cvx`, defines a relative"
                    "dependency called `lib` with a file `math.cvx`, you could require it similarly to:"
                    ""
                    "        {:deploy [a.b  (main a b)"
                    "                  math (some-lib lib math)]}"
                    ""]}

  nil)



(defn .dep.deploy

  ^{:doc {:description ["Deploys requested actors in the Shell."
                        "Expects a \"deploy vector\"."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns a map where each symbol from the deploy vector points"
                        "to the address of its corresponding deployed actor."]
          :examples    [{:code (.dep.deploy '[some-alias (path to actor)])}]
          :signature   [{:params [deploy-vector]}]}}

  [deploy-vector]

  (.shell.invoke '.dep.deploy
                 deploy-vector))



(defn .dep.exec

  ^{:doc {:description ["Given an actor path, deploys all dependencies in its deploy"
                        "vector using `.dep.deploy` and defines in the current account"
                        "all deployed addesses under their corresponding symbols."
                        ""
                        "The source of the actor then runs through `eval`, in the current"
                        "account."
                        "Very useful when used alongside `.repl` during development."

                        "See `(?.shell '.dep)`."]
          :examples    [{:code (.dep.exec '(main foo bar))}]
          :signature   [{:params [actor-path]}]}}

  [actor-path]

  (when-not (list? actor-path)
    (fail :ARGUMENT
          "Requires an actor path"))
  (let [file     (.dep.read actor-path)
        required (:deploy file)]
    (when required
      (reduce (fn [_ [sym addr]]
                (eval `(def ~sym
                            ~addr))
                nil)
              nil
              (.dep.deploy required)))
    (eval (cons 'do
                (:src file)))))



(defn .dep.fetch

  ^{:doc {:description ["Fetches all dependencies required by the given actor path"
                        "or deploy vector."
                        "Does not deploy anything in the Shell but ensures everything"
                        "is available locally."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns some analysis data that is subject to change while"
                        "this dependency management framework is stabilized."]
          :examples    [{:code (.dep.fetch '(main foo bar))}
                        {:code (.dep.fetch '[foo.bar (main foo bar)])}]
          :signature   [{:params [required]}]}}

  [required]

  (.shell.invoke '.dep.fetch
                  (if (list? required)
                    ['_ required]
                    required)))



(defn .dep.read

  ^{:doc {:description ["Reads the content of a file by actor path."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns a map with"
                        ""
                        "  :deploy"
                        "    Deploy vector of this actor if there is one."
                        ""
                        "  :filename"
                        "    Filename to the file."
                        ""
                        "  :src"
                        "    List of cells representing the source code of this actor."]
          :examples    [{:code (.dep.read '(main foo bar))}]
          :signature   [{:params [actor-path]}]}}

  ;; Also supports as deploy vector, not only an actor path.
  ;; But not documented for now, for the sake of simplicity.

  [actor-path]

  (let [required actor-path]
    (if (list? required)
      (do
        (when (empty? required)
          (fail :ARGUMENT
                "Actor path is empty"))
        (get (.shell.invoke '.dep.read
                            ['x required])
             'x))
      (.shell.invoke '.dep.read
                     required))))



(defn .dep.require.filter

  ^:private?

  [f required]

  (let [n (count required)]
    (loop [acc []
           i   0]
      (if (< i
             n)
        (recur (let [sym  (get required
                               i)
                     path (get required
                               (inc i))]
                 (if (f sym
                        path)
                   (conj acc
                         sym
                         path)
                   acc))
               (+ i
                  2))
        acc))))
                      


(defn .dep.test

  ^{:doc {:description ["Executes unit tests by actor path."
                        "The actor is effectively a test suite which specifies all files"
                        "to test in its deploy vector."
                        ""
                        "A map of options map be provided with:"
                        ""
                        "  :focus"
                        "    Vector of metadata keywords, actors by alias, or individual tests to"
                        "    focus. Meaning only corresponding tests will run while other ones will"
                        "    be skipped."
                        ""
                        "  :skip"
                        "    Just like `:focus` but behaves in the opposite way: everything else will run"
                        "    but what is specified in this vector."
                        ""
                        "E.g. These options will run only actors A and B, as aliased in the deploy vector,"
                        "     and skip all tests which have `{:slow? true}` in their metadata:"
                        ""
                        "        {:focus [A B]"
                        "         :skip  [:slow?]}"
                        ""
                        ""
                        "See:"
                        "  (?.shell '.dep)"
                        "  (?.shell '.t)"]
          :examples    [{:code (.dep.test '(test foo bar))}
                        {:code (.dep.test '(test foo bar) {:skip [:slow?]})}]
          :signature   [{:params [actor-path]}
                        {:params [actor-path option+]}]}}

  ;; Also supports as deploy vector, not only an actor path.
  ;; But not documented for now, for the sake of simplicity.


  ([actor-path]

   (.dep.test actor-path
              nil))


  ([actor-path option+]

   (let [test            (if .*dev?*
                           .t.dev
                           .t.main)
         required        actor-path
         required-2      (if (list? required)
                           (:deploy (.dep.read required))
                           required)
         focus           (:focus option+)
         focus.test      (reduce (fn [actor-sym->test+ x]
                                   (if (and (list? x)
                                            (not (empty? x))
                                            (= (first x)
                                               'lookup))
                                     (let [actor-sym (second x)]
                                       (assoc actor-sym->test+
                                              actor-sym
                                              (conj (or (get actor-sym->test+
                                                             actor-sym)
                                                        #{})
                                                    (nth x
                                                         2))))
                                     actor-sym->test+))
                                 {}
                                 focus)
         option-2+       (assoc option+
                                :focus.test
                                focus.test)
         focus-actor+    (union (set (filter symbol?
                                             focus))
                                (set (keys focus.test)))

         required-3      (if (empty? focus-actor+)
                           required-2
                           (.dep.require.filter (fn [sym _path]
                                                  (contains-key? focus-actor+
                                                                 sym))
                                                required-2))
         skip            (:skip option+)
         skip-actor+     (set (filter symbol?
                                      skip))
         required-4      (if (empty? skip-actor+)
                           required-3
                           (.dep.require.filter (fn [sym _path]
                                                  (not (contains-key? skip-actor+
                                                                      sym)))
                                                required-3))
         option-3+       (assoc option-2+
                                :skip.test
                                (reduce (fn [skip.test x]
                                          (if (and (list? x)
                                                   (not (empty? x))
                                                   (= (first x)
                                                      'lookup))
                                            (let [actor-sym (second x)]
                                              (assoc skip.test
                                                     actor-sym
                                                     (conj (or (get skip.test
                                                                    actor-sym)
                                                               #{})
                                                           (nth x
                                                                2))))
                                            skip.test))
                                        {}
                                        skip))
                         ]
     (test (.dep.deploy required-4)
           (assoc option-3+
                  :focus.meta (set (filter keyword?
                                           focus))
                  :skip.meta  (set (filter keyword?
                                           skip)))))))


;;;;;;;;;; Dev


(def .*dev?*

  ^{:doc {:description ["Boolean indicating if the Shell is in dev mode."
                        "Some utilities uses this value to change behavior."
                        ""
                        "E.g. `.dep.test` will not terminate the process if this value is `false`."]}}

  false)



(defn .dev.set

  ^{:callable? true
    :doc       {:description ["Sets `.*dev*`."]
                :examples    [{:code (.dev.set true)}]
                :signature   [{:params [enable?]}]}}

  [enable?]

  (if (= *address*
         $CORE$)
    (def .*dev?*
         (boolean enable?))
    (call $CORE$
          (.dev.set enable?))))


;;;;;;;;; Etch


(def .db

  ^{:private?      true
    :shell.section ["Etch is a fast, immutable database for Convex data."
                    ""
                    "Writing a cell returns the hash of that cell whereas reading"
                    "requiring a hash and returns the corresponding cell."
                    ""
                    "Only one instance can be open per Shell."
                    "See `.db.open`."]}

  nil)
 
 

(defn .db.flush

  ^{:doc {:description ["Flushes the current Etch instance."
                        ""
                        "Happens automatically when the process terminates gracefully."
                        "Good idea to flush manually once in a while to ensure data"
                        "is persisted on disk."]
          :examples    [{:code (.db.flush)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.flush))



(defn .db.open

  ^{:doc {:description ["Opens an Etch instance."
                        ""
                        "Must be called before calling any other DB function."
                        "Not providing a path will create an instance in a temporary file."
                        "File is created if it does not exist."
                        ""
                        "Attention, only one instance can be open per Shell."]
          :examples    [{:code (.db.open "path/to/file.etch")}]
          :signature   [{:params [path]}]}}


  ([]

   (.db.open nil))


  ([path]

   (.shell.invoke '.db.open
                  (or path
                      (.fs.tmp "convex-shell-"
                               ".etch")))))



(defn .db.path

  ^{:doc {:description ["Returns the path of the current Etch instance (or nil if"
                        "no instance has been open)."]
          :examples    [{:code (.db.flush)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.path))



(defn .db.read
  
  ^{:doc {:description ["Reads a cell by hash from the current Etch instance."
                        "Returns `nil` if no cell is found for that hash."
                        ""
                        "Also see `.db.write`."]
          :examples    [{:code (.db.read 0x1fa0dd51b167d4cca60177d13d731c461eae9cdb4ecd75e1e8f2158251968c66)}]
          :signature   [{:params [hash]}]}}

  [hash]

  (.shell.invoke '.db.read
                 hash))



(defn .db.root.read

  ^{:doc {:description ["Reads the root cell from the current Etch instance."
                        "Returns `nil` if no cell has been persisted to the root."
                        ""
                        "Also see `.db.root.write`."]
          :examples    [{:code (.db.root.read)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.root.read))



(defn .db.root.write

  ^{:doc {:description ["Writes the given `cell` to the root of the current Etch instance."
                        "Otherwise, behaves exactly like `.db.write`."
                        ""
                        "Also see `.db.root.read`."]
          :examples    [{:code (.db.root.write [:my 'cell 42])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.root.write
                 cell))



(defn .db.write

  ^{:doc {:description ["Writes the given `cell` to the current Etch instance."
                        "Returns the hash of that cell."
                        ""
                        "If the returned value is `nil`, it means the cell was not persisted."
                        "This happens only with a few basic cells for optimization reasons."
                        "Precisely, those that are so simple they are usually embedded in more complex values:"
                        ""
                        "  - Addresses"
                        "  - Empty collections"
                        "  - Primitives (booleans, bytes, doubles, longs)"
                        "  - Symbolic (keywords and symbols)"
                        ""
                        "Also see `.db.read`."]
          :examples    [{:code (.db.write [:my 'cell 42])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.write
                 cell))


;;;;;;;;;; Exceptions


(defn .ex.print

  ^{:doc {:description ["Pretty prints the given exception (by default to `.stream.*out*`."
                        "For catching exceptions, see `.state.safe` and `.state.tmp`."]
          :examples    [{:code (.ex.print {:code :ARGUMENT, :message "Some message"})}]
          :signature   [{:params [ex]}
                        {:params [stream ex]}]}}

  ([ex]

   (.ex.print nil
              ex))


  ([stream ex]

   (let [msg        (:message ex)
         msg-2      (when (map? msg)
                      (:message msg))
         extra-data (when msg-2
                      (dissoc msg
                              :message))
         trace      (:trace ex)
         trace-2    trace]
     (.stream.txt.outln
       stream
       (str .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Exception code:"
            (.term.reset)
            .sys.eol
            "  "
            (.term.bold)
            (:code ex)
            (.term.bold)
            (.term.fg.red)
            .sys.eol
            "Executing address:"
            (.term.reset)
            .sys.eol
            "  "
            (:address ex)
            .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Message:"
            (.term.reset)
            .sys.eol
            "  "
            (or msg-2
                msg)
            .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Trace:"
            (.term.reset)
            (if (empty? trace-2)
              (str .sys.eol
                   "  None.")
              (apply str
                     (reduce (fn [acc entry]
                               (conj acc
                                     .sys.eol
                                     "  "
                                     entry))
                             []
                             trace-2)))
            (if (and extra-data
                     (not (empty? extra-data)))
              (str .sys.eol
                   (.term.bold)
                   (.term.fg.red)
                   "Extra data:"
                   (.term.reset)
                   .sys.eol
                   "  "
                   extra-data)
              ""))))))



(defn .ex.rethrow
  ^{:doc {:description ["Rethrow the given exception."
                        "For catching exceptions, see `.state.safe` and `.state.tmp`."]
          :examples    [{:code (.ex.rethrow {:code :ARGUMENT, :message "Some message"})}]
          :signature   [{:params [ex]}]}}

  [ex]

  (.shell.invoke '.ex.rethrow
                 ex))


;;;;;;;;;; File operations


(def .file

  ^{:private?      true
    :shell.section ["High-level utilities for reading and writing files,"
                    "either as text or as Convex data."
                    ""
                    "Builds on the stream utilities offered by the Shell."
                    "See `(?.shell '.stream)`."]}

  nil)



(defn .file.-handle

  ^:private?

  [x path]

  (if (nil? x)
    [(.gensym "file-")
     (.fs.resolve path)]
    x))



(defn .file.-read

  ^:private?

  [f-in path]

  (let [handle (.file.stream.in path)
        [ok?
         x]    (.state.safe (fn []
                              (f-in handle)))]
    (.stream.close handle)
    (if ok?
      x
      (.ex.rethrow x))))



(defn .file.-write

  ^:private?

  [f-out path cell option+]

  (let [handle (.file.stream.out path
                                  option+)
        [ok?
         x]    (.state.safe (fn []
                              (f-out handle
                                     cell)))]
    (.stream.close handle)
    (if ok?
      x
      (.ex.rethrow x))))


;;;


(defn .file.exec

  ^{:doc {:description ["Like `.file.read` but also applies `eval`."]
          :examples    [{:code (.file.exec "./my/file.cvx")}]
          :signature   [{:params [path]}]}}

  [path]

  (eval (cons 'do
              (.file.read path))))



(defn .file.read

  ^{:doc {:description ["Returns a list of cells resulting from reading the given file."
                        "Also see `.file.txt.read`."]
          :examples    [{:code (.file.read "./my/file.cvx")}]
          :signature   [{:params [path]}]}}

  ;; Stream is closed automatically in the Clojure code.

  [path]

  (.file.-read .stream.in+
               path))



(defn .file.stream.in

  ^{:doc {:description ["Returns a handle to an input stream for the given file."
                        "See `(?.shell '.stream)` about stream utilities."]
          :examples    [{:code (.file.stream.in "./my/file.cvx")}]
          :signature   [{:params [path]}]}}


  [path]

  (.shell.invoke '.file.stream.in
                 (.resrc.next)
                 (.fs.resolve path)
                 path))



(defn .file.stream.out

  ^{:doc {:description ["Returns a handle to an output stream for the given file."
                        "See `(?.shell '.stream)` about stream utilities."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :append?"
                        "    Writes will be appended to the end if true, otherwise file will be overwritten if it exists."
                        "    False by default."]
          :examples    [{:code (.file.stream.out "./my/file.cvx")}
                        {:code (.file.stream.out "./my/file.cvx" {:append? true})}]
          :signature   [{:params [path]}
                        {:params [path option+]}]}}


  ([path]

   (.file.stream.out path
                     nil))


  ([path option+]

   (.shell.invoke '.file.stream.out
                  (.resrc.next)
                  path
                  (:append? option+))))



(defn .file.txt.read

  ^{:doc {:description ["Returns the content of the given file as a string."
                        "Also see `.file.read`."]
          :examples    [{:code (.file.txt.read "some/file.txt")}]
          :signature   [{:params [path]}]}}

  [path]

  (.file.-read .stream.txt.in
               path))



(defn .file.txt.write

  ^{:doc {:description ["Writes the given cell to the given file as a string."
                        "Same options as `.file.stream.out`."
                        ""
                        "Also see `.file.write`."]
          :examples    [{:code (.file.txt.write "some/file.txt" "Some text")}
                        {:code (.file.txt.write "some/file.txt" "Some text" {:append? true})}]
          :signature   [{:params []}]}}


  ([path cell]

   (.file.txt.write path
                    cell
                    nil))


  ([path cell option+]

   (.file.-write .stream.txt.outln
                 path
                 cell
                 option+)))



(defn .file.write

  ^{:doc {:description ["Writes the given cell to the given file."
                        "Same options as `.file.stream.out`."
                        "Can be read back as cells with `.file.read`."
                        ""
                        "Also see `.file.txt.write`."]
          :examples    [{:code (.file.write "some/file.cvx" [:a :b])}
                        {:code (.file.write "some/file.cvx" [:a :b] {:append? true})}]
          :signature   [{:params []}]}}


  ([path cell]

   (.file.write path
                cell
                nil))


  ([path cell option+]

   (.file.-write .stream.outln
                 path
                 cell
                 option+)))


;;;;;;;;;; Filesystem operations


(def .fs
 
  ^{:private?      true
    :shell.section ["Simple filesystem utilities."]}

  nil)



(defn .fs.copy

  ^{:doc {:description ["Copies the file at `path-source` to `path-destination`."
                        "If `path-destination` is a directory, `path-source` will be copied inside it."
                        "Behaves like Unix's `cp`."]
          :examples    [{:code (.file.copy "some_dir/foo.txt" "another_dir")}]
          :signature   [{:params [path-source path-destination]}]}}

  [path-source path-destination]

  (.shell.invoke '.fs.copy
                 path-source
                 path-destination))



(defn .fs.delete

  ^{:doc {:description "Deletes the file or the empty folder at the given `path`."
          :examples    [{:code (.file.delete "some-file.cvx")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.delete
                 path))



(defn .fs.dir?

  ^{:doc {:description ["Returns `true` if the given path refers to an existing directory."]
          :examples    [{:code (.fs.dir? "some/path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.dir?
                 path))



(defn .fs.exists?

  ^{:doc {:description ["Returns `true` if a file or directory exists at the given path."]
          :examples    [{:code (.file.exists? "some_dir/some_file.txt")}]
          :signatures  [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.exists?
                 path))



(defn .fs.file?

  ^{:doc {:description ["Returns `true` if the given path refers to an existing regular file."]
          :examples    [{:code (.fs.file? "some/path")}]
          :signature   [{:params [path]}]}}
  [path]

  (.shell.invoke '.fs.file?
                 path))



(defn .fs.resolve

  ^{:doc {:description ["Returns the given path fully resolved as an absolute path."
                        "Follows symlinks."]
          :examples    [{:code (.fs.resolve "some/../../path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.resolve
                 path))



(defn .fs.size

  ^{:doc {:description ["Returns the size of the file at the given path (in bytes)."
                        "Returns `nil` if the file does not exist."]
          :examples    [{:code (.fs.size "some/path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.size
                 path))



(defn .fs.tmp

  ^{:doc {:description ["Creates a temporary file."
                        "`prefix` and `suffix` for the filename are both optional."]
          :examples    [{:code (.file.tmp)}
                        {:code (.file.tmp ".cvx")}
                        {:code (.file.tmp "some-project_" ".cvx")}]
          :signature   [{:params []}
                        {:params [suffix]}
                        {:params [prefix suffix]}]}}


  ([]

   (.fs.tmp nil
            nil))


  ([suffix]

   (.fs.tmp nil
            suffix))


  ([prefix suffix]

   (.shell.invoke '.fs.tmp
                  (or prefix
                      "")
                  (or suffix
                      ""))))



(defn .fs.tmp.dir

  ^{:doc {:description ["Creates a temporary directory."
                        "`prefix` is optional."]
          :examples    [{:code (.file.tmp.dir)}
                        {:code (.file.tmp-dir "some-prefix")}]
          :signature   [{:params []}
                        {:params [prefix]}]}}


  ([]

   (.fs.tmp.dir nil))


  ([prefix]

   (.shell.invoke '.fs.tmp.dir
                  (or prefix
                      ""))))


;;;;;;;;;; Generators


(defn .gen.always

  [x]

  (.shell.invoke '.gen.always
                 (.resrc.next)
                 x))



(defn .gen.blob


  ([]

   (.shell.invoke '.gen.blob
                  (.resrc.next)))


  ([n]

   (.shell.invoke '.gen.blob.fixed
                  (.resrc.next)
                  n))


  ([min max]

   (.shell.invoke '.gen.blob.bounded
                  (.resrc.next)
                  min
                  max)))



(defn .gen.blob-map


  ([generator-key generator-value]

   (.shell.invoke '.gen.blob-map
                  (.resrc.next)
                  generator-key
                  generator-value))


  ([generator-key generator-value n]

   (.shell.invoke '.gen.blob-map.fixed
                  (.resrc.next)
                  generator-key
                  generator-value
                  n))


  ([generator-key generator-value min max]

   (.shell.invoke '.gen.blob-map.bounded
                  (.resrc.next)
                  generator-key
                  generator-value
                  min
                  max)))



(defn .gen.double.bounded

  [option+]

  (.shell.invoke '.gen.double.bounded
                 (.resrc.next)
                 (:min option+)
                 (:max option+)
                 (:infinite? option+
                             true)
                 (:NaN? option+
                        true)))



(defn .gen.freq


  [pair+]

  (.shell.invoke '.gen.freq
                 (.resrc.next)
                 pair+))



(defn .gen.hex-string


  ([]

   (.shell.invoke '.gen.hex-string
                  (.resrc.next)))


  ([n]

   (.shell.invoke '.gen.hex-string.fixed
                  (.resrc.next)
                  n))


  ([min max]

   (.shell.invoke '.gen.hex-string.bounded
                  (.resrc.next)
                  min
                  max)))



(defn .gen.list


  ([generator]

   (.shell.invoke '.gen.list
                  (.resrc.next)
                  generator))


  ([generator n]

   (.shell.invoke '.gen.list.fixed
                  (.resrc.next)
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.list.bounded
                  (.resrc.next)
                  generator
                  min
                  max)))



(defn .gen.long.bounded

  [option+]

  (.shell.invoke '.gen.long.bounded
                 (.resrc.next)
                 (:min option+)
                 (:max option+)))



(defn .gen.long.uniform

  [min max]

  (.shell.invoke '.gen.long.uniform
                 (.resrc.next)
                 min
                 max))



(defn .gen.make


  ([generator]

   (.gen.make generator
              nil))


  ([generator option+]

   (.shell.invoke '.gen.make
                  generator
                  (or (:size option+)
                      30)
                  (:seed option+))))



(defn .gen.map


  ([generator-key generator-value]

   (.shell.invoke '.gen.map
                  (.resrc.next)
                  generator-key
                  generator-value))


  ([generator-key generator-value n]

   (.shell.invoke '.gen.map.fixed
                  (.resrc.next)
                  generator-key
                  generator-value
                  n))


  ([generator-key generator-value min max]

   (.shell.invoke '.gen.map.bounded
                  (.resrc.next)
                  generator-key
                  generator-value
                  min
                  max)))



(defn .gen.or

  [generator+]

  (.shell.invoke '.gen.or
                 (.resrc.next)
                 generator+))



(defn .gen.quoted

  [generator]

  (.shell.invoke '.gen.quoted
                 (.resrc.next)
                 generator))



(defn .gen.pick

  [x+]

  (.shell.invoke '.gen.pick
                 (.resrc.next)
                 x+))



(defn .gen.set


  ([generator]

   (.shell.invoke '.gen.vector
                  (.resrc.next)
                  generator))


  ([generator n]

   (.shell.invoke '.gen.set.fixed
                  (.resrc.next)
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.set.bounded
                  (.resrc.next)
                  generator
                  min
                  max)))



(defn .gen.string


  ([]

   (.shell.invoke '.gen.string
                  (.resrc.next)))


  ([n]

   (.shell.invoke '.gen.string.fixed
                  (.resrc.next)
                  n))


  ([min max]

   (.shell.invoke '.gen.string.bounded
                  (.resrc.next)
                  min
                  max)))



(defn .gen.string.alphanum


  ([]

   (.shell.invoke '.gen.string.alphanum
                  (.resrc.next)))


  ([n]

   (.shell.invoke '.gen.string.alphanum.fixed
                  (.resrc.next)
                  n))


  ([min max]

   (.shell.invoke '.gen.string.alphanum.bounded
                  (.resrc.next)
                  min
                  max)))



(defn .gen.syntax


  ([]

   (.shell.invoke '.gen.syntax
                  (.resrc.next)))


  ([generator-value]

   (.shell.invoke '.gen.syntax.with-value
                  (.resrc.next)
                  generator-value))


  ([generator-value generator-meta]

   (.shell.invoke '.gen.syntax.with-meta
                  (.resrc.next)
                  generator-value
                  generator-meta)))



(defn .gen.tuple

  [generator+]

  (.shell.invoke '.gen.tuple
                 (.resrc.next)
                 generator+))



(defn .gen.vector


  ([generator]

   (.shell.invoke '.gen.vector
                  (.resrc.next)
                  generator))


  ([generator n]

   (.shell.invoke '.gen.vector.fixed
                  (.resrc.next)
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.vector.bounded
                  (.resrc.next)
                  generator
                  min
                  max)))


;;;;;;;;;; Gensym


(def .*gensym*

  ^:private?

  0)



(defn .gensym

  ^{:callable? true
    :doc       {:description ["Returns a symbol guaranteed to be unique relative to other symbols generated"
                              "with this function in the context of a single process."
                              ""
                              "A prefix string may be provided (default to \"G_\")."
                              ""
                              "Useful for metaprogramming."]
                :examples    [{:code (.gensym)}
                              {:code ($.gensym "some-prefix-")}]
                :signature   [{:params []}
                              {:params [prefix]}]}}

  
  ([]

   (.gensym nil))


  ([prefix]

   (if (= *address*
          $CORE$)
     (do
       (let [id .*gensym*]
         (def .*gensym*
              (inc id))
         (symbol (str (or prefix
                          "G_")
                      id
                      "_"
                      (.time.nano)))))
     (call $CORE$
           (.gensym prefix)))))


;;;;;;;;;; Juice operations


(def .juice

  ^{:private?      true
    :shell.section ["Juice is the computational unit of Convex."
                    "All operations in a transaction, such as calling a function,"
                    "are measured in this unit."
                    ""
                    "Currently available juice can be retrieved with `*juice*`."
                    ""
                    "For instance, try setting this value to 0 with `.juice.set`"
                    "and do anything afterwards. A `:JUICE` exception will be thrown."]}

  nil)



(defn .juice.refill

  ^{:doc {:description ["Refills `*juice*` to the maximum value."
                        "Useful to call once in a while when running long operations."]
          :examples    [{:code (.juice.refill)}]
          :signature   [{:params []}]}}

  []

  (.juice.set 9223372036854775807))



(defn .juice.set

  ^{:doc {:description ["Sets `*juice*` to an exact amount."
                        "Useful when there is a need for limiting an operation."]
          :examples    [{:code (.juice.set 10000000)}]
          :signature   [{:params [n-unit]}]}}

  [n-unit]

  (.shell.invoke '.juice.set
                 n-unit))



(defn .juice.track

  ^{:doc {:description ["Tracks the juice consumption of the given transaction."
                        "Any state change is reverted."
                        ""
                        "Returns a vector of 4 elements:"
                        ""
                        "  0: Transaction result"
                        "  1: Juice cost when running as is"
                        "  2: Juice cost after `compile`"
                        "  3: Juice cost after `expand`"]
          :examples    [{:code (.juice.track '(if :a :b :c))}
                        {:code (.juice.track (compile '(if :a :b :c)))}]
          :signature   [{:params [trx]}]}}

  [trx]

  (conj (.shell.invoke '.juice.track
                       trx)
        (second (.shell.invoke '.juice.track
                               (compile trx)))
        (second (.shell.invoke '.juice.track
                               (expand trx)))))


;;;;;;;;;; CVM log operations


(def .log

  ^{:private?      true
    :shell.section ["The core `log` functions allows for saving Convex data"
                    "for off-chain use. For instance, a peer might issue off-chain"
                    "notifications based on what is being logged."
                    ""
                    "On-chain, logged data is inaccessible. These few functions"
                    "allowing for inspecting it in the Shell."]}

  nil)



(defn .log.clear

  ^{:doc {:description ["Clears the CVM log."
                        "Also see `.log.get`."]
          :examples    [{:code (.log.clear)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.log.clear))



(defn .log.get

  ^{:doc {:description ["Returns the current CVM log."
                        "Values can be logged using the core `log` function."
                        ""
                        "Also see `.log.clear`."]
          :examples    [{:code (.log.get)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.log.get))


;;;;;;;;;; Project files


(def .project.*dir*

  ^{:doc {:description ["Path to the directory containing `project.cvx`."
                        "Also see `.project.dir.set`."]}}

  "./")



(defn .project.dir.set

  ^{:callable? true
    :doc       {:description ["Points `.project.*dir*` to another directory."]
                :examples    [{:code (.project.dir.set "some/dir")}]
                :signature   [{:params [dir]}]}}

  [dir]

  (if (= *address*
         $CORE$)
    (do
      (when-not (.fs.dir? dir)
        (fail :ARGUMENT
              "Given path is not a directory"))
      (def .project.*dir*
           dir))
    (call $CORE$
          (.project.dir.set dir))))


;;;;;;;;;; Reader


(defn .reader.form+

  ^{:doc {:description ["Returns a list of cells read from the given string."]
          :examples    [{:code (.reader.form+ ":a :b :c")}]
          :signature   [{:params [string]}]}}
  [string]

  (.shell.invoke '.reader.form+
                 string))


;;;;;;;;;; REPL


(defn .repl

  ^{:doc {:description ["Starts a Read-Eval-Print-Loop for working interactively."
                        ""
                        "By default, a prompt is printed and the user can introduce a lines of cells to evaluate."
                        "Results and exceptions are printed."
                        "By default, stops when the user enter `:q` or `:quit`."
                        "The result of the previous command is made available under `$`."
                        ""
                        "A map of options may be provided to alter the behavior of the REPL."
                        "Functions in this map takes a state map and must returns it, altered or not."
                        "The state map starts with those options. Users may want to attach additional
                         information."
                        ""
                        "Tweaking these option may lead to interesting ways of doing inter-process communication"
                        "through STDIO."
                        ""
                        "Options may be:"
                        ""
                        "  :eval"
                        "    Function for producing a result given cells attached under `:result`."
                        "    Defaults to `.repl.eval`."
                        ""
                        "  :on.ex"
                        "    Function for acting when `:eval` throws an exception."
                        "    Exception is attached under `:result`."
                        "    Defaults to `.repl.on.ex`."
                        ""
                        "  :on.ex.reader"
                        "    Function for acting on reader errors, when an input line is not valid Convex data."
                        "    Besides the state map, also takes the message of the reader exception."
                        "    Defaults to `.repl.on.ex.reader`."
                        ""
                        "  :on.prompt"
                        "    Function for acting prior to asking for input (e.g. print a prompt)."
                        "    Defaults to `.repl.on.prompt`."
                        ""
                        "  :on.result"
                        "     Function for acting when a result is produced."
                        "     Defaults to `.repl.on.result`."
                        ""
                        "  :stop?"
                        "    Function for deciding if the REPL should stop after reading a line but before evaluating it."
                        "    Defaults to `.repl.stop?`."
                        ""
                        "  :stream.in"
                        "    Input stream for reading lines of cells."
                        "    Defaults to `.stream.*in*`."
                        ""
                        "  :stream.out"
                        "    Output stream for printing results."
                        "    Defaults to `.stream.*out*`."]
          :examples    [{:code (.repl)}]
          :signature   [{:params []}
                        {:params [option+]}]}
    :shell.section ["See `(? '.repl)` for driving an interactive workflow."
                    "The REPL is started automatically when the Shell is started"
                        "without instructions."]}


  ([]

   (.repl nil))


  ([option+]

   (loop [state (merge {:eval         .repl.eval
                        :on.ex        .repl.on.ex
                        :on.ex.reader .repl.on.ex.reader
                        :on.prompt    .repl.on.prompt
                        :on.result    .repl.on.result
                        :stop?        .repl.stop?
                        :stream.in    .stream.*in*
                        :stream.out   .stream.*out*}
                       option+)]
     (let [state-2 ((:on.prompt state) state)
           [read?
            x]     (.state.safe (fn []
                                  (.stream.line (:stream.in state-2))))]
       (if read?
         ;;
         ;; Successful read.
         ;;
         (let [form+   x
               state-3 (assoc state-2
                              :form+
                              form+)]
           (cond
             ;;
             (nil? form+)
             state-3
             ;;
             (empty? form+)
             (recur state-3)
             ;;
             ((:stop? state-3) state-3)
             state-3
             ;;
             (let [[ok?
                    x]     (.state.safe (fn []
                                          ((:eval state-3) (assoc state-3
                                                                  :form+
                                                                  form+))))
                   state-4 (if ok?
                             (let [state-4 x]
                               ((:on.result state-4) state-4))
                             (let [ex x]
                               ((:on.ex state) (assoc state-3
                                                      :result
                                                      ex))))]
               (if (contains-key? state-4
                                  :result)
                 (recur state-4)
                 state-4))))
         ;;
         ;; Reading input failed.
         ;;
         (let [ex x]
           (if (= (:code ex)
                  :READER)
             (let [state-3 ((:on.ex.reader state) state
                                                  (:message ex))]
               (if (contains-key? state-3
                                  :result)
                 (recur state-3)
                 state-3))
             (.ex.rethrow ex))))))))



(defn .repl.eval

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL state, applies `:form+` to `eval` and attaches the result"
                        "under `:result`."]
          :signature   [{:params [repl-state]}]}}

  [state]

  (assoc state
         :result
         (eval (concat `(let [$ (quote ~(:result state))])
               (:form+ state)))))



(defn .repl.on.ex

  ^{:doc {:description ["See `.repl`."
                        "Pretty-prints the exception found under `:result` in the REPL state."]
          :signature   [{:params [repl-state]}]}}

  [state]

  (let [out   (:stream.out state)
        ex    (:result state)
        trace (:trace ex)
        ex-2  (assoc ex
                     :trace
                     (slice trace
                            0
                            ;; Removing lines relating to the REPL, not interesting.
                            (- (count trace)
                               3)))]
    (.ex.print out
               ex-2)
    (.stream.txt.outln out
                       "")
    (assoc state
           :result
           ex-2)))



(defn .repl.on.ex.reader

  ^{:doc {:description ["See `.repl`."
                        "Prints the reader error that occured when the REPL was parsing input."]
          :signature   [{:params [repl-state error-message]}]}}

  [state message]

  (.stream.txt.outln (:stream.out state)
                     (str .sys.eol
                          (.term.fg.red)
                          (.term.bold)
                          "Input cannot be parsed as Convex Lisp:"
                          (.term.reset)
                          .sys.eol
                          "  "
                          message
                          .sys.eol))
  state)



(defn .repl.on.prompt

  ^{:doc {:description ["See `.repl`."
                        "Prints a simple prompt."]
          :signature   [{:params [repl-state]}]}}

  [state]

  (let [out (:stream.out state)]
    (.stream.txt.out out
                     (str (.term.bold)
                          (.term.fg.blue)
                          "> "
                          (.term.reset)))
    (.stream.flush out))
  state)



(defn .repl.on.result

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL state, prints `:result` to `:stream.out`."]
          :signature   [{:params [repl-state]}]}}

  [state]

  (let [out (:stream.out state)]
    (.stream.txt.out out
                     .sys.eol)
    (.stream.out out
                 (:result state))
    (.stream.txt.out out
                     .sys.eol)
    (.stream.txt.out out
                     .sys.eol)
    (.stream.flush out))
  state)



(defn .repl.stop?

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL state, returns `true` if the first cell in"
                        "`:form+` is `:q` or `:quit`."]
          :signature   [{:params [repl-state]}]}}

  [state]

  (contains-key? #{:q
                   :quit}
                 (first (:form+ state))))


;;;;;;;;;; Used by resources external to the CVM


(def .resrc.*count*

  ^:private?

  0)



(defn .resrc.next

  ^{:callable? true
    :doc       {:description ["Returns an ever incrementing Long."
                              "Some utilities use this function for identifying resources external"
                               "to the Convex Virtual Machine (e.g. stream handles)."]
                :examples    [{:code (.resrc.next)}]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         $CORE$)
    (def .resrc.*count*
         (inc .resrc.*count*))
    (call $CORE$
          (.resrc.next))))


;;;;;;;;;; Shell


(def .shell

  ^{:private?      true
    :shell.section ["Shell configuration, such as selectively removing some of"
                    "the extra features it offers."]}

  nil)



(defn .shell.inspect

  ^{:doc {:description ["Returns a set of symbols expressing features offered by the Shell."
                        "Those symbols often relates directly to functions and are not native"
                        "to the regular Convex Virtual Machine."
                        ""
                        "See also `.shell.limit`."]
          :examples    [{:code (.shell.inspect)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.shell.inspect))



(def .shell.invoke

  ^{:doc {:description ["Main entry point for accessing features offered by the Shell."
                        "Aka the \"invoker\"."
                        "Shell functions often delegates to it."
                        ""
                        "The regular user should never have to call this function directly."
                        "For experts only."]
          :examples    [{:code (.shell.invoke '.time.unix)}]
          :signature   [{:params [feature & arg+]}]}}

  ;; Injected from Clojure.

  ^:private?

  nil)



(defn .shell.limit

  ^{:doc {:description ["Limits the features offered by the Shell."
                        ""
                        "See `.shell.inspect` about getting the set of currently available features."
                        "This function takes a similar set and will limit `.shell.invoke` to those only."
                        ""
                        "Thus, an empty set removes all Shell features, resulting in a pure Convex Virtual Machine."
                        ""
                        "A common pattern is to call `.shell.limit` inside `.state.tmp*`, so that the Shell"
                        "is limited only temporarily."]
          :examples    [{:code (.shell.limit #{})}
                        {:code (.shell.limit (disj (.shell.inspect) '.time.unix))}]
          :signature   [{:params [feature-set]}]}}

  [feature-set]

  (.shell.invoke '.shell.limit
                 feature-set))



(defn .shell.main

  ^:private?

  [src]

  (let [[ok?
         x]  (.state.safe (fn []
                            (.reader.form+ src)))]
    (cond
      ;;
      ok?
      (let [form+ x]
        (if (empty? form+)
          (do
            (.dev.set true)
            (.stream.txt.outln
              (str (.term.fg.blue)
                   (.term.bold)
                   "Convex Shell (REPL mode)"
                   (.term.reset)
                   .sys.eol
                   "Enter transactions and build a new world."
                   .sys.eol
                   .sys.eol
                   "Powered by Protosens SRL and collaborators."
                   .sys.eol
                   "For help, type: "
                   (.term.bold)
                   "(?)"
                   (.term.reset)
                   .sys.eol))
            (.repl)
            nil)
          (eval (cons 'do
                      form+))))
      ;;
      (= (:code x)
         :READER)
      (do
        (.stream.txt.outln
           (str .sys.eol
                (.term.fg.red)
                (.term.bold)
                "Input cannot be parsed as Convex Lisp:"
                (.term.reset)
                .sys.eol
                "  "
                (:message x)
                .sys.eol))
        (.sys.exit 4))
      ;;
      (fail :SHELL.FATAL
            {:message "Initialization problem while reading input"}))))



(def .shell.*root*

  ^{:doc {:description ["Root directory used by the Shell."
                        "E.g. This is where `.dep.fetch` caches foreign dependencies."
                        ""
                        "Also see `.shell.root.set`."]}}

  "~/.convex-shell")



(defn .shell.root.set

  ^{:callable? true
    :doc       {:description ["Points `.shell.*root*` to another directory."
                              "Given path must point to an existing one."]
                :examples    [{:code (.shell.root.set "./some/dir")}]
                :signature   [{:params [dir]}]}}

  [dir]

  (if (= *address*
         $CORE$)
    (do
      (when-not (str? dir)
        (fail :ARGUMENT
              "Given path is not a string"))
      (def .shell.*root*
           dir))
    (call $CORE$
          (.shell.root.set dir))))


;;;;;;;;;; Creating and handling states


(def .state

  ^{:private?      true
    :shell.section ["Convex transactions alter the global state of the network."
                    "In Convex Lisp, the current state is available under `*state*`."
                    ""
                    "The Shell offers extra features such as `.state.switch` which allows"
                    "jumping to another state. For instance, one that has been loaded"
                    "from the Etch database (see `(?.shell '.db)`)."]}

  nil)



(defn .state.genesis

  ^{:doc {:description ["Generates and returns a genesis state."
                        ""
                        "The genesis state is the original state used by the Convex network"
                        "to bootstrap. Such a state does not have any of the features offered"
                        "by the Shell."
                        ""
                        "A vector of distinct keys may be provided for creating initial user accounts."
                        "If not, one account is created with `.account.0-key`."]
          :examples    [{:code (.state.genesis)}
                        {:code (.state.genesis [0x1122334455667788990011223344556677889900112233445566778899001122])}]
          :signature   [{:params []}
                        {:params [key+]}]}}

  ([]

   (.state.genesis nil))


  ([key+]

   (.shell.invoke '.state.genesis
                  (or key+
                      [.account.0-key]))))



(defn .state.safe

  ^{:doc {:description ["Executes the given function in a safe, atomic way."
                        "Returns a vector of 2 elements."
                        ""
                        "First item is a boolean indicating if the function ran without throwing"
                        "an exception."
                        ""
                        "If `true`, second item is the returned result."
                        "If `false`, second item is the thrown exception and `*state*` is reverted."
                        ""
                        "Usually, prefer the `.state.safe*` macro for convenience."]
          :examples    [{:code (.state.safe (fn [] (assert false)))}]
          :signature   [{:params [f]}]}}
  [f]

  (.shell.invoke '.state.safe
                 f))



(defmacro .state.safe*

  ^{:doc {:description ["Executes the given code exactly like `.state.safe`."
                        "More convenient to use."]
          :examples    [{:code (.state.safe* (def x []) (inc x))}]
          :signature   [{:params [& form+]}]}}

  [& form+]

  `(~$CORE$/.state.safe (fn []
                          ~(cons 'do
                                 form+))))
 


(defn .state.switch

  ^{:doc {:description ["Switches `*state*` to the given one."
                        "For instance, a state produced with `.state.genesis` or a state"
                        "retrieved from Etch."
                        ""
                        "Provided address must point to an account in the target state."
                        "By default, current `*address*` is used."
                        ""
                        "Attention, beware of consequences."
                        "E.g. Switching in a middle of an actor call who was working under"
                        "     assumptions relating to the old `*state*`."]
          :examples    [{:code (.state.switch (.state.genesis))}]
          :signature   [{:params [state]}]}}


  ([state]

   (.state.switch nil
                  state))


  ([address state]

   (.shell.invoke '.state.switch
                  (or address
                      *address*)
                  state)))



(defn .state.tmp

  ^{:doc {:description ["Exactly like `.state.safe` but the state is always reverted."
                        "Even if an exception is not thrown."
                        ""
                        "Also see the `.state.tmp*` macro for convenience."]
          :examples    [{:code (.state.tmp (fn [] (def x 42) (inc x)))}]
          :signature   [{:params [f]}]}}

  [f]

  (.shell.invoke '.state.tmp
                 f))



(defmacro .state.tmp*

  ^{:doc {:description ["Convenience macro over `.state.tmp`."
                        "Wraps given code into a function."]
          :examples    [{:code (state.tmp* (def x 42) (inc x))}]
          :signature   [{:params [& form+]}]}}

  [& form+]

  `(~$CORE$/.state.tmp (fn []
                         ~(cons 'do
                                form+))))


;;;;;;;;;; Strings


(def .str

  ^{:private?      true
    :shell.section ["Extra string-related utilities not found natively in Convex."]}

  nil)



(defn .str.pluralize

  ^:private?

  [n s]

  (if (> n
         1)
    (str s
         "s")
    s))



(defn .str.sort

  ^:private?

  [str+]

  (.shell.invoke '.str.sort
                 str+))



(defn .str.stream.in

  ^{:doc {:description ["Wraps the given string in an input stream."
                        "The returned handle can be used with stream utilities."
                        "See `(?.shell '.stream)`."]
          :examples    [{:code (.str.stream.in ":a :b :c")}]
          :signature   [{:params [string]}]}}

  [string]

  (.shell.invoke '.str.stream.in
                 (.resrc.next)
                 string))



(defn .str.stream.out

  ^{:doc {:description ["Wraps the given string in an output stream."
                        "The returned handle can be used with stream utilities."
                        "See `(?.shell '.stream)`."
                        ""
                        "Note that `.stream.close` has no effect."
                        ""
                        "See `.str.stream.unwrap` for unwrapping the string inside."]
          :examples    [{:code (.str.stream.out)}]
          :signature   [{:params [string]}]}}

  []

  (.shell.invoke '.str.stream.out
                 (.resrc.next)))



(defn .str.stream.unwrap

  ^{:doc {:description ["Returns the string wrapped inside the given string output stream."
                        "See `.str.stream.out`."]
          :examples    [{:code (.str.stream.unwrap (.str.stream.out))}]
          :signature   [{:params [handle]}]}}

  [handle]

  (.shell.invoke '.str.stream.unwrap
                 handle))


;;;;;;;;;; Streams


(def .stream

  ^{:private?      true
    :shell.section ["Streams are an abstraction for reading and writing text"
                    "or Convex data."
                    ""
                    "For instance, see the following ways for creating streams"
                    "which can then be used with the various stream utilities:"
                    ""
                    "  .file.stream.in"
                    "  .file.stream.out"
                    "  .str.stream.in"
                    "  .str.stream.out"]}

  nil)



(def .stream.stderr

  ^{:doc {:description "Stream for STDERR."}}

  .stream.stderr)



(def .stream.stdin

  ^{:doc {:description "Stream for STDIN."}}

  .stream.stdin)



(def .stream.stdout

  ^{:doc {:description "Stream for STDOUT."}}

  .stream.stdout)


;;;


(def .stream.*err*

  ^{:doc {:description ["Default error stream, originally set to `.stream.stderr`."
                        "See `.stream.set.err`."]}}

  .stream.stderr)



(def .stream.*in*

  ^{:doc {:description ["Default input stream, originally set to `.stream.stdin`."
                        "See `.stream.set.in`."]}}

  .stream.stdin)



(def .stream.*out*

  ^{:doc {:description ["Default output stream, originally set to `.stream.stdout`."
                        "See `.stream.set.out`."]}}

  .stream.stdout)



(defn .stream.close

  ^{:doc {:description ["Closes the given stream."
                        "Returns `nil`."]
          :examples    [{:code (.stream.close (.str.stream.in ":test"))}]
          :signature   [{:params [handle]}]}}

  [handle]

  (.shell.invoke '.stream.close
                 handle))



(defn .stream.err

  ^{:doc {:description ["Like `.stream.out` but prints the given value to `.stream.*err*`."]
          :examples    [{:code (.stream.err {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.out .stream.*err*
               x))



(defn .stream.errln

  ^{:doc {:description ["Like `.stream.outln` but prints the given value to `.stream.*err*`."]
          :examples    [{:code (.stream.errln {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.outln .stream.*err*
                 x))



(defn .stream.flush

  ^{:doc {:description ["Flushes the given output stream, ensuring all current content is printed."
                        "Defaults to `.stream.*out*`."
                        "Returns the stream handle."]
          :examples    [{:code (.stream.flush)}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.flush .stream.*out*))


  ([handle]

   (.shell.invoke '.stream.flush
                  handle)))



(defn .stream.in+

  ^{:doc {:description ["Reads as cells all content available from the given stream."
                        "Returns a list."
                        "Closes the stream automatically."
                        ""
                        "Reads from `.stream.*in*` by default."]
          :examples    [{:code (.stream.in+ (.str.stream.in ":a :b :c"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.in+ .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.in+
                  handle)))



(defn .stream.line

  ^{:doc {:description ["Reads a single lines of cells from the given stream."
                        "Returns a list or `nil` if the stream is empty."
                        ""
                        "Once empty, the next read will throw an exception."
                        ""
                        "Reads from `.stream.*in*` by default."]
          :examples    [{:code (.stream.line (.str.stream.in ":a :b \n :c"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.line .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.line
                  handle)))



(defn .stream.out

  ^{:doc {:description ["Writes the value as a cell to the given output stream."
                        "Prints in such a way that those cells can be read back."
                        ""
                        "Defaults to `.stream.*out*`."]
          :examples    [{:code (.stream.out :test)}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.out .stream.*out*
                x))


  ([handle x]

   (.shell.invoke '.stream.out
                  handle
                  x)))



(defn .stream.outln

  ^{:doc {:description "Exactly like `.stream.out` but also prints a new line and flushes the stream."
          :examples    [{:code (.stream.outln :test)}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.outln .stream.*out*
                  x))


  ([handle x]
   
   (.shell.invoke '.stream.outln
                  handle
                  x)))



(defn .stream.set.err

  ^{:callable? true
    :doc       {:description "Sets `.stream.*err*` to the given stream."
                :examples    [{:code (.stream.set.err (.str.stream.out))}]
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*err*
         handle)
    (call $CORE$
          (.stream.set.err handle))))



(defn .stream.set.in

  ^{:callable? true
    :doc       {:description "Sets `.stream.*in*` to the given stream."
                :examples    [{:code (.stream.set.in (.str.stream.in ":a :b :c"))}]
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*in*
         handle)
    (call $CORE$
          (.stream.set.in handle))))



(defn .stream.set.out

  ^{:callable? true
    :doc       {:description "Sets `.stream.*out* to the given stream."
                :examples    [{:code (.stream.set.out (.str.stream.out))}]
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*out*
         handle)
    (call $CORE$
          (.stream.set.out handle))))



(defn .stream.txt.err

  ^{:doc {:description ["Like `.stream.txt.out` but prints to `.stream.*err*`."]
          :examples    [{:code (.stream.err {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.txt.out .stream.*err*
                   x))



(defn .stream.txt.errln

  ^{:doc {:description ["Like `.stream.txt.outln but prints to `.stream.*err*`."]
          :examples    [{:code (.stream.errln {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.txt.outln .stream.*err*
                     x))



(defn .stream.txt.in

  ^{:doc {:description ["Reads the full content of the given input stream as a string."
                        "Defaults to `.stream.*in*`."
                        "Stream is closed automatically."]
          :examples    [{:code (.stream.txt.in (.str.stream.in "test"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.in .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.txt.in
                  handle)))



(defn .stream.txt.line

  ^{:doc {:description ["Reads a single line from the given input stream as a string."
                        "Defaults to `.stream.*in*`."
                        ""
                        "Like `.stream.in`, returns `nil` when the end of the stream is reached."
                        "Any subsequent read will then throw an exception."]
          :examples    [{:code (.stream.txt.line (.str.stream.in "foo\nbar"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.line .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.txt.line
                  handle)))



(defn .stream.txt.out

  ^{:doc {:description ["Like `.stream.out` but strings are not double-quoted."
                        "Hence, the output might not be readable as Convex data."]
          :examples    [{:code (.stream.txt.out "Some text")}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.out .stream.*out*
                    x))


  ([handle x]

   (.shell.invoke '.stream.txt.out
                  handle
                  x)))



(defn .stream.txt.outln

  ^{:doc {:description ["Like `.stream.outln` but strings are not double-quoted."
                        "Hence, the output might not be readable as Convex data."]
          :examples    [{:code (.stream.txt.outln "Some text")}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.outln .stream.*out*
                      x))


  ([handle x]

   (.shell.invoke '.stream.txt.outln
                  handle
                  x)))


;;;;;;;;;; System utilities


(def .sys

  ^{:private?      true
    :shell.section ["Basic system utilities."]}

  nil)



(defn .sys.arch

  ^{:doc {:description ["Returns the machine architecture as a string."]
          :examples    [{:code (.sys.arch)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.arch))



(defn .sys.cwd

  ^{:doc {:description ["Returns the current working directory."
                        "In other words, the directory the Shall was started in."
                        "Will not change throught the course of a process."]
          :examples    [{:code (.sys.cwd)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.sys.cwd))



(defn .sys.env

  ^{:doc {:description ["Returns a map of process environment variables."
                        "Also see `.sys.env.var`."]
          :examples    [{:code (.sys.env)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.env))



(defn .sys.env.var

  ^{:doc {:description ["Returns the value for a single process environment variable."
                        "Also see `.sys.env.var."]
          :examples    [{:code (.sys.env.var "SOME_VAR")}]
          :signature   [{:params [var]}]}}
  [var]

  (.shell.invoke '.sys.env.var
                 var))



(def .sys.eol

  ^{:doc {:description "Platform-dependent new line."}}

  .sys.eol)



(defn .sys.exit

  ^{:doc {:description ["Exists the Shell process with the given exit code."
                        "Exit code must be 0 or >= 128 and <= 255."
                        "Values below 128 are reserved for the Shell itself."]
          :examples    [{:code (.sys.exit 128)}]
          :signature   [{:params [code]}]}}

  [code]

  (.shell.invoke '.sys.exit
                 code))



(defn .sys.home

  ^{:doc {:description ["Returns the user's home directory."]
          :examples    [{:code (.sys.home)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.home))



(defn .sys.os

  ^{:doc {:description ["Returns a vector where the first element is the operating"
                        "system and the second is the version."]
          :examples    [{:code (.sys.os)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.os))


;;;;;;;;;; Unit testing


(def .t

  ^{:private?      true
    :shell.section ["Unit testing framework."
                    ""
                    "Tests are functions defined with `.t.def` which should"
                    "contain assertions written with `.t.is`."
                    ""
                    "See `.dep.test` about how to run them."]}

  nil)



(def .t.*assert+*

  ^:private?

  [])



(defn .t.assert.add

  ^:callable?
  ^:private?

  [assertion]

  (if (= *address*
         ~*address*)
    (def .t.*assert+*
         (conj .t.*assert+*
               assertion))
    (call ~*address*
          (.t.assert.add assertion))))



(defn .t.assert.failed+

  ^:private?

  [assertion+]

  (reduce (fn [acc assertion]
            (let [[ok?
                   x]         (:result assertion)
                  assertion-2 (if ok?
                                (if (syntax? x)
                                  (if-let [status (:test.status (meta x))]
                                    {:fail   (unsyntax x)
                                     :status status}
                                    {:fail   x
                                     :status :fail})
                                  (when-not (= x
                                               true)
                                    {:fail   x
                                     :status :fail}))
                                {:fail   x
                                 :status :exception})]
              (if assertion-2
                (conj acc
                      (assoc assertion-2
                             :form    (:form assertion)
                             :message (:message assertion)))
                acc)))
          []
          assertion+))



(defmacro .t.ex

  ^{:doc {:description ["Used as a form for `.t.is` for testing if an exception was thrown."
                        "Exception code is optional. Without it, the assertion will pass for"
                        "any exception."
                        ""
                        "A good test suite not only proves that things succeed but also that they"
                        "fail when they should."]
          :examples    [{:code (.t.is (.t.ex (assert false)))}
                        {:code (.t.is (.t.ex :ASSERT (assert false)))}]
          :signature   [{:params [form]}
                        {:params [ex-code form]}]}}

  ([form]

   `(.t.ex nil
           ~form))


  ([ex-code form]

   `(let [ex-code ~ex-code
          [ok?
           x]    (.state.safe* ~form)]
      (if ok?
        (syntax x
                {:test.status :fail})
        (if (nil? ex-code)
          true
          (or (= ex-code
                 (:code x))
              (syntax x
                      {:test.status :exception})))))))



(defmacro .t.def

  ^{:doc {:description ["Defines a function that can run as a test."
                        ""
                        "Just like when defining a regular function, metadata can be attached."
                        "This metadata may be useful for focusing on the test or skipping it when"
                        "running tests with `.dep.test`."]
          :examples    [{:code (.t.def some-test ^:slow? (.t.is (< 1 2)))}]
          :signature   [{:params [name & assertion+]}]}}

  [name & assertion+]

  (let [[name-2
         meta-]      (if (syntax? name)
                       [(unsyntax name)
                        (meta name)]
                       [name
                        nil])
        first-assert (when-not (empty? assertion+)
                       (first assertion+))
        meta-2       (if (syntax? first-assert)
                       (merge meta-
                              (meta first-assert))
                       meta-)]
    `(defn ~(syntax name-2
                    (assoc meta-2
                           :test?
                           true))

       []

       ~(cons 'do
               assertion+))))



(defn .t.dev

  ^:private?

  ([required]

   (.t.dev required
           nil))


  ([required state]

   (= (:status (.t.run required
                       state))
      :pass)))



(defn .t.find

  ^:private?

  [state actor-sym actor-address]

  (let [account    (account actor-address)
        meta       (:metadata account)
        env        (:environment account)
        focus.test (get-in state
                           [:focus.test
                             actor-sym])
        skip.test  (get-in state
                           [:skip.test
                            actor-sym])]
    (reduce (fn [acc [sym x]]
              (let [sym-meta (get meta
                                  sym)]
                (if (and (fn? x)
                         (get-in meta
                                 [sym
                                  :test?])
                         (or (not focus.test)
                             (contains-key? focus.test
                                            sym))
                         (or (not skip.test)
                             (not (contains-key? skip.test
                                                 sym)))
                         (reduce (fn [_focus? k-focus]
                                   (if (get sym-meta
                                            k-focus)
                                     (reduced true)
                                     false))
                                 true
                                 (get state
                                      :focus.meta))
                         (reduce (fn [_skip? k-skip]
                                   (if (get sym-meta
                                            k-skip)
                                     (reduced false)
                                     true))
                                 true
                                 (get state
                                      :skip.meta)))
                  (conj acc
                        [sym
                         x])
                  acc)))
            []
            env)))



(defmacro .t.is

  ^{:doc {:description ["Creates a test assertion."
                        "Meant to be used in tests defined with `.t.def`."
                        ""
                        "In order for a test assertion to pass, `form` must return `true`."
                        "An optional message can be provided, making it easier to locate the"
                        "assertion in the test report in case of failure."]
          :examples    [{:code (.t.is (= a b) "A and B must be equal")}]
          :signature   [{:params [form]}
                        {:params [form message]}]}}


  ([form]

   `(.t.is ~form
           nil))


  ([form message]

   `(.t.assert.add {:form    (quote ~form)
                    :message ~message
                    :result  (.state.safe* ~form)})))



(defn .t.main

  ^:private?


  ([required]

   (.t.main required
            nil))


  ([required state]

   (.sys.exit (if (.t.dev required
                          state)
                0
                128))))



(defn .t.on.run.begin

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (str .sys.eol
                          "=========="
                          .sys.eol
                          .sys.eol
                          (.term.bold)
                          "["
                          (.term.reset)))
    (.stream.flush s))
  state)



(defn .t.on.run.end

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       (str (.term.bold)
                            "]"
                            (.term.reset)
                            .sys.eol
                            .sys.eol
                            "=========="
                            .sys.eol))
    (.docoll (fn [test]
               (if-let [f (get {:empty     .t.on.test.empty
                                :exception .t.on.test.ex
                                :fail      .t.on.test.fail}
                               (:status test))]
                 (f state
                    test)
                 nil))
             (:run state))
    (let [status (:status state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (cond
                                (= status
                                   :empty)
                                (str (.term.fg.red)
                                     "NO TESTS FOUND")
                                ;;
                                (= status
                                   :fail)
                                (str (.term.fg.red)
                                     "FAIL")
                                ;;
                                (= status
                                   :pass)
                                (str (.term.fg.green)
                                     "OK"))
                              (.term.bold)
                              .sys.eol)))
    (let [empty-actor+ (:empty-actor+ state)
          n-actor      (:n-actor state)
          n-test       (:n-test state)
          n-test-fail  (:n-test-fail state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (.term.fg.cyan)
                              n-test
                              " test"
                              (if (> n-test
                                     1)
                                "s"
                                "")
                              (.term.reset)
                              " run over "
                              (.term.bold)
                              (.term.fg.cyan)
                              n-actor
                              " actor"
                              (if (> n-actor
                                     1)
                                "s"
                               "")
                              (.term.reset)
                              ", "
                              (.term.bold)
                              (if (zero? n-test-fail)
                                (.term.fg.green)
                                (.term.fg.red))
                              n-test-fail
                              " failed"
                              (.term.reset)))
      (when-not (empty? empty-actor+)
        (.stream.txt.outln s
                           (str .sys.eol
                                .sys.eol
                                (.term.bold)
                                (.term.fg.red)
                                "Actors without tests:"
                                (.term.reset)
                                .sys.eol))
        (.docoll (fn [sym-actor]
                   (.stream.txt.outln s
                                      (str "  "
                                           sym-actor)))
                 empty-actor+))))
  state)



(defn .t.on.test.empty

  ^:private?

  [state test]

  (.t.print.test.name state
                      test)
  (.stream.txt.outln (:stream.out state)
                     "No assertions.")
  (.t.print.test.separator state))



(defn .t.on.test.ex

  ^:private?

  [state test]

  (.t.print.test.name state
                      test)
  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       "Exception thrown unexpectedly")
    (.ex.print s
               (:exception test)))
  (.t.print.test.separator state))



(defn .t.on.test.fail

  ^:private?

  [state test]

  (let [s (:stream.out state)]
    (.docoll (fn [failed]
               (.t.print.test.name state
                                   test)
               (when-let [message (:message failed)]
                 (.stream.txt.outln s
                                    (str message
                                         .sys.eol)))
               (.stream.txt.outln s
                                  (str (.term.bold)
                                       (.term.fg.cyan)
                                       "Form:   "
                                       (.term.reset)
                                       (:form failed)))
               (let [status (:status failed)]
                 (when-not (= status
                              :pass)
                   (cond
                     ;;
                     (= status
                        :fail)
                     (.stream.txt.outln s
                                        (str .sys.eol
                                             (.term.bold)
                                             (.term.fg.cyan)
                                             "Result: "
                                             (.term.reset)
                                             (:fail failed)))
                     ;;
                     (= status
                        :exception)
                     (.ex.print s
                                (:fail failed)))
                   (.t.print.test.separator state))))
             (:failed+ test))))



(defn .t.on.test.result

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state result]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (if (= (:status result)
                            :pass)
                       (str (.term.bold)
                            (.term.fg.green)
                            "."
                            (.term.reset))
                       (str (.term.bold)
                            (.term.fg.red)
                            "X"
                            (.term.reset))))
    (.stream.flush s))
  state)



(defn .t.print.test.name

  ^:private?

  [state test]

  (.stream.txt.outln (:stream.out state)
                     (str (.term.bold)
                          (:name test)
                          (.term.reset)
                          .sys.eol))
  nil)



(defn .t.print.test.separator

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       "")
    (.stream.txt.outln s
                       "-----")
    (.stream.txt.outln s
                       ""))
  nil)



(defn .t.run

  ^:private?

  [actor-sym->addr state]

  (let [[ok?
         x]
        (.state.tmp
          (fn []
            (let [state          (merge {:on.run.begin   .t.on.run.begin
                                         :on.run.end     .t.on.run.end
                                         :on.test.result .t.on.test.result
                                         :stream.out     .stream.stdout}
                                        state)
                  on.run.begin   (:on.run.begin state)
                  on.run.end     (:on.run.end state)
                  state          (if on.run.begin
                                   (on.run.begin state)
                                   state)
                  state-2        (reduce (fn [state-2 [actor-sym actor-address]]
                                           (.t.run.actor state-2
                                                         actor-sym
                                                         actor-address))
                                         (assoc state
                                                :empty-actor+ []
                                                :n-actor      0
                                                :n-test       0
                                                :n-test-fail  0)
                                         actor-sym->addr)
                 state-3         (.t.run.finalize state-2)]
             (if on.run.end
               (on.run.end state-3)
               state-3))))]
    (if ok?
      x
      (.ex.rethrow x))))



(defn .t.run.actor

  ^:private?

  [state actor-sym actor-address]

  (let [found (.t.find state
                       actor-sym
                       actor-address)]
    (if (empty? found)
      (assoc state
             :empty-actor+
             (conj (:empty-actor+ state)
                   actor-sym))
      (reduce (fn [state-2 [test-sym test-f]]
                (.t.run.test state-2
                             actor-sym
                             actor-address
                             test-sym
                             test-f))
              (assoc state
                     :n-actor
                     (inc (:n-actor state)))
              found))))



(defn .t.run.finalize

  ^:private?

  [state]

  (assoc state
         :status
         (cond
           ;;
           (zero? (:n-test state))
           :empty
           ;;
           (zero? (:n-test-fail state))
           :pass
           ;;
           :else
           :fail)))



(defn .t.run.test

  ^:private?

  [state actor-sym actor-address test-sym test-f]

  (let [on.test.result (:on.test.result state)
        [ok?
         x]            (.state.tmp (fn []
                                     (.account.switch actor-address)
                                     (test-f)
                                     .t.*assert+*))
        test-result    (if ok?
                         (.t.run.test.finalize x)
                         (let [trace (:trace x)]
                           {:exception (assoc x
                                              :trace
                                              ;; Removing lines relating to calling the test.
                                              (slice trace
                                                     0
                                                     (- (count trace)
                                                        2)))
                            :status    :exception}))
        test-result-2  (assoc test-result
                              :name
                              (str actor-sym
                                   "/"
                                   test-sym))
        state-2        (assoc state
                              :run
                              (conj (:run state)
                                    test-result-2))
        state-3        (assoc state-2
                              :n-test
                              (inc (:n-test state-2)))
        state-4        (if on.test.result
                         (on.test.result state-3
                                         test-result-2)
                         state-3)]
    (if (= (:status test-result-2)
           :pass)
      state-4
      (assoc state-4
             :n-test-fail
             (inc (:n-test-fail state-4))))))



(defn .t.run.test.finalize

  ^:private?

  [assertion+]

  (let [n (count assertion+)]
    (if (zero? n)
      {:status :empty}
      (let [failed+ (.t.assert.failed+ assertion+)
            result  {:n n}]
        (if (empty? failed+)
          (assoc result
                 :status
                 :pass)
          (assoc result
                 :failed+ failed+
                 :status  :fail))))))


;;;;;;;;;; Basic ANSI terminal commands


(def .term

  ^{:private?      true
    :shell.section ["Simples utilities for producing terminal ANSI escape codes, such as"
                    "for coloring strings."
                    ""
                    "Some environments, such as some Windows terminals, or some use cases,"
                    "such as writing files, requires disabling these."
                    "See `.term.style.enable?` which will work for all color-related functions."]}

  nil)



(def .term.*style?*

  ^{:doc {:description ["Boolean indicating if text styling functions like `.term.fg.red` can use ANSI escape codes."
                        "If set to `false`, those functions will return empty strings."
                        "See `.term.style.enable?`."]}}

  true)



(defn .term.style

  ^:private?

  [x]

  (if .term.*style?*
    x
    ""))



(defn .term.style.enable?

  ^{:callable? true
    :doc       {:description ["Sets the value of `.term.*style?*`."
                              "Disabling colors is useful when working in a terminal that does not support ANSI"
                              "escape codes or when printing to files."
                              "See `.term.style.enable?`."]
                :examples    [{:code (.term.style.enable? false)}]
                :signature   [{:params [enable?]}]}}

  [enable?]

  (if (= *address*
         ~*address*)
    (def .term.*style?*
         (boolean enable?))
    (call ~*address*
          (.term.style.enable? enable?))))


;; ANSI background colors


(defn .term.bg.black

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in black (background)."]
          :examples    [{:code (.term.bg.black)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[40m"))



(defn .term.bg.blue

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in blue (background)."]
          :examples    [{:code (.term.bg.blue)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[44m"))



(defn .term.bg.cyan

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in cyan (background)."]
          :examples    [{:code (.term.bg.cyan)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[46m"))



(defn .term.bg.green

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in green (background)."]
          :examples    [{:code (.term.bg.green)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[42m"))



(defn .term.bg.magenta

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in magenta (background)."]
          :examples    [{:code (.term.bg.magenta)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[45m"))


(defn .term.bg.red

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in red (background)."]
          :examples    [{:code (.term.bg.red)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[41m"))



(defn .term.bg.white

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in white (background)."]
          :examples    [{:code (.term.bg.white)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[47m"))



(defn .term.bg.yellow

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in (background)."]
          :examples    [{:code (.term.bg.)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[43m"))


;;


(defn .term.bg.rgb

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in RGB (background)."]
          :examples    [{:code (.term.bg.rgb 156 120 201)}]
          :signature   [{:params [r g b]}]}}

  [r g b]

  (if .term.*style?*
    (str "\033[48;2;" r ";" g ";" b "m")
    ""))


;; ANSI foreground colors


(defn .term.fg.black

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in black (foreground)."]
          :examples    [{:code (.term.fg.black)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[30m"))



(defn .term.fg.blue

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in blue (foreground)."]
          :examples    [{:code (.term.fg.blue)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[34m"))



(defn .term.fg.cyan

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in cyan (foreground)."]
          :examples    [{:code (.term.cyan)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[36m"))



(defn .term.fg.green

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in green (foreground)."]
          :examples    [{:code (.term.fg.green)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[32m"))



(defn .term.fg.magenta

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in magenta (foreground)."]
          :examples    [{:code (.term.fg.magenta)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[35m"))



(defn .term.fg.white

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in white (foreground)."]
          :examples    [{:code (.term.fg.white)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[37m"))



(defn .term.fg.red

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in red (foreground)."]
          :examples    [{:code (.term.fg.red)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[31m"))



(defn .term.fg.yellow

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in yellow (foreground)."]
          :examples    [{:code (.term.fg.yellow)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[33m"))


;;


(defn .term.fg.rgb

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in RGB (foreground)."]
          :examples    [{:code (.term.fg.rgb 156 120 201)}]
          :signature   [{:params [r g b]}]}}


  [r g b]

  (if .term.*style?*
    (str "\033[38;2;" r ";" g ";" b "m")
    ""))


;; Terminal effects


(defn .term.bold

  ^{:doc {:description ["Returns the ANSI escape code for bold text."]
          :examples    [{:code (.term.bold)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[1m"))



(defn .term.reset

  ^{:doc {:description ["Returns the ANSI escape code for resetting all colors and effects."]
          :examples    [{:code (.term.reset)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[0m"))



(defn .term.reversed

  ^{:doc {:description ["Returns the ANSI escape code for reversing background and"
                        "foreground colors."]
          :examples    [{:code (.term.reversed)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[7m"))



(defn .term.underline

  ^{:doc {:description ["Returns the ANSI escape code for underlining text."]
          :examples    [{:code (.term.underline)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[4m"))


;;;;;;;;;; Moving


(defn .term.col

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor to column `n`."]
          :examples    [{:code (.term.col 42)}]
          :signature   [{:params [n]}]}}

  [n]

  (str "\033[" n "G"))



(def .term.cursor.save

  ^{:doc {:description ["ANSI code for saving current cursor position."
                        "See `cursor.restore`."]}}

  "\033[s")



(def .term.cursor.restore

  ^{:doc {:description ["ANSI escape code for restoring last saved cursor position."
                        "See `cursor.save`."]}}

  "\033[u")



(defn .term.down

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code (.term.down 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down 1))


  ([n]

   (str "\033[" n "B")))



(defn .term.down.begin

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor to the beginning"
                        "of the line and then `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code ($.term.down.begin 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down.begin 1))


  ([n]

   (str "\033[" n "E")))



(defn .term.left

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` columns left."
                        "Defaults to one column."]
          :examples    [{:code (.term.left 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.left 1))


  ([n]

   (str "\033[" n "D")))



(defn .term.right

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` columns right."
                        "Defaults to one column."]
          :examples    [{:code (.term.right 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.right 1))


  ([n]

   (str "\033[" n "C")))



(defn .term.up

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code (.term.up 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up 1))


  ([n]

   (str "\033[" n "A")))



(defn .term.up.begin

  ^{:doc {:description ["Returns the ANSI escapecode for moving the cursor to the beginning of the line"
                        "and then `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code (.term.up.begin 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up.begin 1))


  ([n]

   (str "\033[" n "F")))


;; Screen clearing


(defn .term.clear

  ^{:doc {:description "Returns the ANSI code for clearing the whole screen."
          :examples    [{:code (.term.clear)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[H\033[2J"))


;;


(defn .term.demo

  ^{:doc {:description ["Prints a string to `.stream.*out*` producing colored output as demo"
                        "of the different `.term...` functions."]
          :examples    [{:code ($.term/demo)}]
          :signature   [{:params []}]}}
  []

  (.stream.txt.outln
    (str .sys.eol
         (.term.bg.black)
         "BG black"
         (.term.reset)
         .sys.eol
         (.term.bg.blue)
         "BG blue"
         (.term.reset)
         .sys.eol
         (.term.bg.cyan)
         "BG cyan"
         (.term.reset)
         .sys.eol
         (.term.bg.green)
         "BG green"
         (.term.reset)
         .sys.eol
         (.term.bg.magenta)
         "BG magenta"
         (.term.reset)
         .sys.eol
         (.term.bg.red)
         "BG red"
         (.term.reset)
         .sys.eol
         (.term.bg.white)
         (.term.fg.black)
         "BG white"
         (.term.reset)
         .sys.eol
         (.term.bg.yellow)
         "BG yellow"
         (.term.reset)
         .sys.eol
         (.term.bg.rgb 100 200 150)
         "BG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.fg.black)
         "FG black"
         (.term.reset)
         .sys.eol
         (.term.fg.blue)
         "FG blue"
         (.term.reset)
         .sys.eol
         (.term.fg.cyan)
         "FG cyan"
         (.term.reset)
         .sys.eol
         (.term.fg.green)
         "FG green"
         (.term.reset)
         .sys.eol
         (.term.fg.magenta)
         "FG magenta"
         (.term.reset)
         .sys.eol
         (.term.fg.red)
         "FG red"
         (.term.reset)
         .sys.eol
         (.term.fg.white)
         (.term.fg.black)
         "FG white"
         (.term.reset)
         .sys.eol
         (.term.fg.yellow)
         "FG yellow"
         (.term.reset)
         .sys.eol
         (.term.fg.rgb 100 200 150)
         "FG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.bold)
         "Bold text"
         .sys.eol
         (.term.fg.blue)
         "Bold makes also colors brighter"
         (.term.reset)))
  nil)


;;;;;;;;;; Time utilities


(def .time

  ^{:private?      true
    :shell.section ["Times related utilities."
                    ""
                    "Note that the Convex Virtual Machine keeps its own time available"
                    "under `*timestamp*` which represents the network time. In the Shell,"
                    "this timestamp can only move forwards via `.time.advance`."
                    ""
                    "Other utilities, such as `.time.unix`, refer to the actual clock"
                    "time of the machine the Shell is running on."]}

  nil)



(defn .time.advance

  ^{:doc {:description ["Advances `*timestamp*`, the timestamp of the Convex Virtual Machine."
                        "Unless calling this function, this timestamp never changes."
                        "Canot go back in time."
                        ""
                        "Useful for triggering transactions that have been scheduled at a"
                        "future time with `schedule`."]
          :examples    [{:code (.time.advance 1000)}]
          :signature   [{:params [millis]}]}}

  [millis]

  (.shell.invoke '.time.advance
                 millis))



(defn .time.iso

  ^{:doc {:description ["Returns the current time as an ISO 8601 UTC string."
                        "This refers to clock time, the actual time of the machine the Shell"
                        "is running on, not `*timestamp*`."]
          :examples    [{:code (.time.iso)}]
          :signature   [{:params []}]}}
  []

  (.time.unix->iso (.time.unix)))



(defn .time.iso->unix

  ^{:doc {:description ["Converts time as an ISO 8601 UTC string into a Unix timestamp."
                        "Also see `.time.iso`, `.time.unix`."]
          :examples    [{:code (.time.iso->unix "2022-09-14T11:43:34.633")}]
          :signature   [{:params [iso-string]}]}}

  [iso-string]

  (.shell.invoke '.time.iso->unix
                 iso-string))



(defn .time.nano

  ^{:doc {:description ["Returns the current value of a high-resolution timer in nanoseconds."
                        ""
                        "Guarantees:"
                        ""
                        "  - Timer is monotonic if the OS supports it"
                        "  - Resolution is at least as good as that of `.time.unix`"
                        ""
                        "Useful for timing things as usually more accurate than `.time.unix`."
                        ""
                        "This timer has no particular, predictable origin. Hence the first value is meaningless."
                        "However, the difference between 2 values from the same process offers a precise interval."
                        "It follows that values from different processes are not comparable."]
          :examples    [{:code (.time.nano)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.nano))



(defn .time.sleep

  ^{:doc {:description ["Blocks execution for the given interval in milliseconds."
                        "subject to the precision and accuracy of system timers and scheduler."]
          :examples    [{:code (.time.sleep 1000)}]
          :signature   [{:params [millis]}]}}

  [millis]

  (.shell.invoke '.time.sleep
                 millis))



(defn .time.unix

  ^{:doc {:description ["Returns the current Unix time as a Long."
                        "This refers to clock time, the actual time of the machine the Shell"
                        "is running on, not `*timestamp*`."]
          :examples    [{:code (.time.unix)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.unix))



(defn .time.unix->iso

  ^{:doc {:description ["Converts a Unix timestamp to an ISO 8601 UTC string."
                        "Also see `.time.iso`, `.time.unix`."]
          :examples    [{:code (.time.unix->iso 1663155814633)}]
          :signature   [{:params [unix-timestamp]}]}}

  [unix-timestamp]

  (.shell.invoke '.time.unix->iso
                 unix-timestamp))


;;;;;;;;;; Try-catch like helpers


(def .try

  ^{:private?      true
    :shell.section ["By design, the Convex Virtual Machine does not offer any \"try-catch\""
                    "mechanism as commonly found in mainstream languages. A transaction either"
                    "succeeds or fails when an exception is thrown."
                    ""
                    "However, catching exceptions is a common need for development. This section"
                    "contains some helper macros that build over `.state.safe`."]}

  nil)



(defmacro .try*

  ^{:doc {:description ["If `do-good` fails with an exception, state is reverted and `do-fail` is run."]
          :examples    [{:code (.try* (+ 2 2) :fail)}
                        {:code (.try* (assert false) :fail)}]
          :signature   [{:params [do-good do-fail]}]}}

  [do-good do-fail]

  `(let [[ok?
          x]  (.state.safe (fn [] ~do-good))]
     (if ok?
       x
       ~do-fail)))
          


(defmacro .try.resrc*

  ^{:doc {:description ["Safe way of running code with resources such as streams."
                        "Bindings are in a vector, akin to `let`, where each symbol is followed"
                        "by 2 forms."
                        ""
                        "Result of the first form is bound to the symbol, just like in `let`."
                        "Second form is executed when leaving this macro, usually to close the resource."
                        ""
                        "This ensure that resources closed even in case of an exception."]
          :examples    [{:code (.try.resrc* [s (.file.stream.in "foo.cvx") (.stream.close s)] (assert false)) }]
          :signature   [{:params [binding+ & body]}]}}

  [binding+ & body]

  (when-not (and (vector? binding+)
                 (zero? (mod (count binding+)
                             3)))
    (fail :ARGUMENT
          "Bindings must be in a vector consisting of triples"))
  (loop [code (cons 'do
                    body)
         i    (- (count binding+)
                 3)]
    (if (< i
           0)
      code
      (recur
        (let [sym   (get binding+
                         i)
              open  (get binding+
                         (inc i))
              close (get binding+
                         (+ i
                            2))]
          `(let [~sym ~open
                 [ok?
                  x]  (.state.safe* ~code)]
             ~(if (symbol? close)
                (list close
                      sym)
                close)
             (if ok?
               x
               (.ex.rethrow x))))
        (- i
           3)))))


;;;;;;;;;; Versions


(def .version

  ^{:private?      true
    :shell.section ["In case of a bug, please report `.version.shell` as well as `.version.convex`."]}

  nil)



(def .version.convex

  ^{:doc {:description "Convex version used by the Shell."}}

  .version.convex)



(def .version.java

  ^:private?

  .version.java)



(def .version.shell

  ^{:doc {:description "Version of this Shell."}}

  .version.shell)


;;;;;;;;;; Help


(defn ?

  ^{:doc {:description ["Get help."]
          :examples    [{:code (?)}
                        {:code (? #8)}
                        {:code (? #8 'inc)}
                        {:code (? 'inc)}]
          :signature   [{:params [query]}
                        {:params [address symbol]}]}}

  ([]

   (.stream.txt.outln "")
   (?.title "Information about an account")
   (?.txt "(? address)         ->  (? #8)")
   (?.title "Information about a symbol")
   (?.txt "(? symbol)          ->  (? 'inc)")
   (?.txt "(? address symbol)  ->  (? #8 'inc)")
   (?.title "Information about the Convex Shell")
   (?.txt "(?.shell)")
   (.stream.txt.outln "")
   nil)


  ([query]

   (.stream.txt.outln "")
   (cond
     ;;
     (address? query)
     (?.account query)
     ;;
     (symbol? query)
     (?.sym query)
     ;;
     (.stream.txt.outln "Ask for an address or a symbol."))
   nil)


  ([addr sym]

    (.stream.txt.outln "")
    (?.sym addr
           sym)
    nil))



(defn ?.account

  ^:private?

  [addr]

  (if-let [-account (account addr)]
    (?.print.account (assoc -account
                            :help.addr
                            addr))
    (.stream.txt.outln (str "Account not found for address "
                            addr))))



(defn ?.color

  ^:private?

  [s]

  (str (.term.bold)
       (.term.fg.blue)
       s
       (.term.reset)))



(defn ?.color-2

  ^:private?

  [s]

  (str (.term.bold)
       (.term.fg.green)
       s
       (.term.reset)))



(defn ?.print.env

  ^:private?

  [env metadata filt]

  (reduce (fn [n sym-str]
            (let [sym      (symbol sym-str)
                  meta-sym (get metadata
                                sym)]
              (if (and (not (get meta-sym
                                   :private?))
                         (filt sym
                               meta-sym))
                (do
                  (?.txt (?.color-2 sym))
                  (?.txt-2 (when-let [desc (:description (:doc meta-sym))]
                             (let [desc-2 (if (str? desc)
                                            desc
                                            (let [first-line (first desc)]
                                              (if (> (count desc)
                                                     1)
                                                (str first-line
                                                     "..")
                                                first-line)))]
                               (if (> (count desc-2)
                                      80)
                                 (str (slice desc-2
                                             0
                                             77)
                                      "...")
                               desc-2))))
                  (inc n))
                n)))

           0
           (.str.sort (keys env))))



(defn ?.print.account

  ^:private?

  [-account]

  (.stream.txt.outln "")
  (let [addr   (:help.addr -account)
        lookup (call *registry*
                     (lookup addr))]
    (.docoll (fn [[title txt]]
               (?.title title)
               (?.txt txt))
             [["Address"     addr]
              ["Name"        (:name lookup)]
              ["Description" (:description lookup)]
              ["Allowance"   (:allowance -account)]
              ["Balance"     (:balance -account)]
              ["Controller"  (:controller -account)]
              ["Key"         (when-let [key (:key -account)]
                               (str "0x"
                                    key))]])
  
    (?.title "Overview")
    (let [env      (:environment -account)
          metadata (:metadata -account)]
      (if (empty? env)
        (?.txt "Empty environment.")
        (?.print.env env
                     metadata
                     (fn [sym _sym-meta]
                       (let [first-char (first (str sym))]
                         (and (not (= first-char
                                      \.))
                              (not (= first-char
                                      \?))))))))))



(defn ?.print.sym

  ^:private?

  [sym-meta]

  (?.title "Defined in")
  (?.txt (:help.addr sym-meta))
  (let [doc          (:doc sym-meta)
        code->reason (:errors doc)
        example+     (:examples doc)
        signature+   (:signature doc)]
    (?.title "Description")
    (?.txt (:description doc))
    (when-not (empty? signature+)
      (?.title (.str.pluralize (count signature+)
                               "Signature"))
      (.docoll (fn [signature]
                 (.stream.txt.outln (str "  "
                                         (:params signature))))
               signature+))
    (when-not (empty? code->reason)
      (?.title "Throws")
      (.docoll (fn [[code reason]]
                 (?.txt (str code
                             (?.color " <- ")
                             reason)))
               code->reason))
    (when-not (empty? example+))
      (?.title (.str.pluralize (count example+)
                               "Example"))
      (.docoll (fn [example]
                 (?.txt (:code example)))
               example+)))



(defn ?.shell


  ([]
 
   (let [feature (fn [feature description]
                   (str "  "
                        (.term.bold)
                        feature
                        (.term.reset)
                        "  "
                        description))]
     (.docoll .stream.txt.outln
              [""
               "Convex Shell augments the Convex Virtual Machine with additional features"
               "useful for developing smart contracts in Convex Lisp."
               ""
               "These functions and values are prefixed with `.` to be easily recognizable."
               "None of this is available on-chain with the regular Convex Virtual Machine."
               ""
               "Key sets of features are:"
               ""
               (feature ".account"
                        "Account management")
               (feature ".bench  "
                        "Benchmarking")
               (feature ".db     "
                        "Using Etch, the fast immutable database for cells")
               (feature ".dep    "
                        "Dependency management and file reloading")
               (feature ".file   "
                        "Reading and writing files")
               (feature ".fs     "
                        "Filesystem utilities")
               (feature ".juice  "
                        "Juice operations")
               (feature ".log    "
                        "CVM log management")
               (feature ".repl   "
                        "Read-Eval-Print-Loop for interactive work")
               (feature ".shell  "
                        "Shell configuration")
               (feature ".state  "
                        "Convex state management, such as time travel")
               (feature ".str    "
                        "String utilities")
               (feature ".stream "
                        "Generic utilities for reading and writing streams (files and beyond)")
               (feature ".sys    "
                        "System utilities")
               (feature ".t      "
                        "Unit testing library")
               (feature ".term   "
                        "Terminal ANSI escape codes (e.g. colored output)")
               (feature ".try    "
                         "Error handling abstractions built over `.state.safe`.")
               (feature ".time   "
                        "Time utilities")
               (feature ".version"
                        "CVM and Shell versions")
               ""]))
   (?.title "List everything available in a feature set")
   (?.txt "(?.shell feature-set)  ->  (?.shell '.account)")
   (?.title "List all Shell features")
   (?.txt "(?.shell.list)")
   (?.title "Help about a function or a value")
   (?.txt "(? symbol)             ->  (? '.time.unix)")
   nil)


 ([sym]

   (.stream.txt.outln "")
   (when-let [txt (get-in (account $CORE$)
                          [:metadata
                           sym
                           :shell.section])]
     (?.title sym)
     (?.txt txt)
     (.stream.txt.outln ""))
   (?.title (str "Overview of Shell features matching `" sym "`"))
   (let [sym-2     (or (get {'.str '.str.  ;; avoids printing stream utils
                             '.t   '.t.}
                            sym)  ;; avoids printin anything that starts with `.t`
                       sym)
         core      (account .account.core)
         prefix    (str sym-2)
         n-slice   (count prefix)
         n-printed (?.print.env (:environment core)
                                (:metadata core)
                                (fn [sym sym-meta]
                                  (and (?.shell.list.filter sym
                                                            sym-meta)
                                       (let [target (str sym)]
                                         (and (>= (count target)
                                                  n-slice)
                                              (= (slice (str sym)
                                                        0
                                                        n-slice)
                                                 prefix))))))]
     (when (zero? n-printed)
       (?.txt "No matching symbols found.")))
   nil))



(defn ?.shell.list

  []

  (.stream.txt.outln "")
  (?.title "All Shell functions and values")
  (let [core (account .account.core)]
    (?.print.env (:environment core)
                 (:metadata core)
                 ?.shell.list.filter))
  nil)



(defn ?.shell.list.filter

  ^:private?

  [sym _sym-meta]

  (let [first-char (first (str sym))]
    (or (= first-char
           \.)
        (= first-char
           \?))))



(defn ?.sym

  ^:private?

  ([sym]

   (if-let [sym-meta (or (?.sym.meta *address*
                                     sym)
                         (?.sym.meta .account.core
                                     sym))]
     (?.print.sym sym-meta)
     (.stream.txt.outln "Symbol not found in current account nor in core account.")))


  ([addr sym]

   (if-let [sym-meta (?.sym.meta addr
                                 sym)]
     (?.print.sym sym-meta)
     (.stream.txt.outln (str "Symbol not found in account "
                             addr)))))



(defn ?.sym.meta

  ^:private?

  [addr sym]

  (when-let [sym-meta (get-in (account addr)
                              [:metadata
                               sym])]
    (assoc sym-meta
           :help.addr addr
           :help.sym  sym)))



(defn ?.title

  ^:private?

  [s]

  (.stream.txt.outln (?.color (str s
                                   ":"))))



(defn ?.txt

  ^:private?

  [s]

  (if s
    (if (vector? s)
      (.docoll (fn [s]
                 (.stream.txt.outln (str "  "
                                         s)))
               s)
      (.stream.txt.outln (str "  "
                              s)))
    (.stream.txt.outln "  None.")))



(defn ?.txt-2

  ^:private?

  [s]

  (.stream.txt.out "  ")
  (?.txt s))
