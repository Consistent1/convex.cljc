

;;;;;;;;;; Miscellaneous helpers, private and public


(defn .docoll

  ^:private?

  [f coll]

  (let [n (count coll)]
    (loop [i 0]
      (if (< i
             n)
        (do
          (f (nth coll
                  i))
          (recur (inc i)))
        nil))))



(defn .prn

  ^{:doc {:description "Prints arguments in a vector using `.stream.outln`."
          :examples    [{:code (.prn :a :b :c)}]
          :signature   [{:params [& arg+]}]}}

  [& arg+]

  (.stream.outln arg+))


;;;;;;;;;; Account


(def .account.0-key

  ^{:doc {:description "Fake key, useful for turning an actor into a user account with `set-key`."}}

  0x0000000000000000000000000000000000000000000000000000000000000000)



(def .account.core

  ^{:doc {:description "Address of the core account where all core functions are defined."}}

  $CORE$)



(defn .account.key?

  ^{:doc {:description "Returns true if `x` is a 32-byte blob that can act as a key."
          :examples    [{:code (.account.key? $.account/fake-key)}
                        {:code (.account.key? 42)}]
          :signature   [{:params [x]}]}}

  [x]

  (and (blob? x)
       (= (count x)
          32)))



(def .account.genesis

  ^{:doc {:description "Address of the account used when starting the Shell."}}

  .account.genesis)



(defn .account.switch

  ^{:doc {:description ["Switches the execution context to the given address."]
          :examples    [{:code (.account.switch #3)}]
          :signature   [{:params [address]}]}}

  [address]

  (.shell.invoke '.account.switch
                 address))


;;;;;;;;;; Benchmarking


(defn .bench.trx

  ^{:doc {:description ["Benchmarks the mean execution time of the given transaction."
                        "Any state change is reverted each time."
                        ""
                        "Returns a map with:"
                        ""
                        "  :mean"
                        "    Mean execution time (nanoseconds)"
                        "  :stddev"
                        "    Standard deviation (nanoseconds)"
                        "Executed in a query a high number of times."
                        ""
                        "Highly experimental and subject to change, probably useful for CVM developers only."
                        "Depending on the given transaction, takes between one and several minutes to complete."]
          :examples    [{:code (.bench.trx '(+ 2 2))}
                        {:code (.bench.trx (compile '(+ 2 2)))}]
          :signature   [{:params [trx]}]}}


  [trx]

  (.shell.invoke '.bench.trx
                 trx))


;;;;;;;;;; Dependency management


(defn .dep.deploy

  ^{:doc {:description ["Deploys requested dependencies from `project.cvx`."]
          :examples    [{:code (.dep.deploy '[some-alias (path to actor)])}]
          :signature   [{:params [dep]}]}}

  [dep]

  (.shell.invoke '.dep.deploy
                 dep))



(defn .dep.exec

  [actor-path]

  (when-not (list? actor-path)
    (fail :ARGUMENT
          "Requires an actor path"))
  (let [file     (.dep.read actor-path)
        required (:deploy file)]
    (when required
      (reduce (fn [_ [sym addr]]
                (eval `(def ~sym
                            ~addr))
                nil)
              nil
              (.dep.deploy required)))
    (eval (cons 'do
                (:src file)))))



(defn .dep.fetch

  [required]

  (.shell.invoke '.dep.fetch
                  (if (list? required)
                    ['_ required]
                    required)))



(defn .dep.read

  [required]

  (if (list? required)
    (do
      (when (empty? required)
        (fail :ARGUMENT
              "Actor path is empty"))
      (get (.shell.invoke '.dep.read
                          ['x required])
           'x))
    (.shell.invoke '.dep.read
                   required)))



(defn .dep.require.filter

  ^:private?

  [f required]

  (let [n (count required)]
    (loop [acc []
           i   0]
      (if (< i
             n)
        (recur (let [sym  (get required
                               i)
                     path (get required
                               (inc i))]
                 (if (f sym
                        path)
                   (conj acc
                         sym
                         path)
                   acc))
               (+ i
                  2))
        acc))))
                      


(defn .dep.test


  ([required]

   (.dep.test required
              nil))


  ([required option+]

   (let [test            (if .*dev?*
                           .t.dev
                           .t.main)
         required-2      (if (list? required)
                           (:deploy (.dep.read required))
                           required)

         focus           (:focus option+)
         focus.test      (reduce (fn [actor-sym->test+ x]
                                   (if (and (list? x)
                                            (not (empty? x))
                                            (= (first x)
                                               'lookup))
                                     (let [actor-sym (second x)]
                                       (assoc actor-sym->test+
                                              actor-sym
                                              (conj (or (get actor-sym->test+
                                                             actor-sym)
                                                        #{})
                                                    (nth x
                                                         2))))
                                     actor-sym->test+))
                                 {}
                                 focus)
         option-2+       (assoc option+
                                :focus.test
                                focus.test)
         focus-actor+    (union (set (filter symbol?
                                             focus))
                                (set (keys focus.test)))

         required-3      (if (empty? focus-actor+)
                           required-2
                           (.dep.require.filter (fn [sym _path]
                                                  (contains-key? focus-actor+
                                                                 sym))
                                                required-2))
         skip            (:skip option+)
         skip-actor+     (set (filter symbol?
                                      skip))
         required-4      (if (empty? skip-actor+)
                           required-3
                           (.dep.require.filter (fn [sym _path]
                                                  (not (contains-key? skip-actor+
                                                                      sym)))
                                                required-3))
         option-3+       (assoc option-2+
                                :skip.test
                                (reduce (fn [skip.test x]
                                          (if (and (list? x)
                                                   (not (empty? x))
                                                   (= (first x)
                                                      'lookup))
                                            (let [actor-sym (second x)]
                                              (assoc skip.test
                                                     actor-sym
                                                     (conj (or (get skip.test
                                                                    actor-sym)
                                                               #{})
                                                           (nth x
                                                                2))))
                                            skip.test))
                                        {}
                                        skip))
                         ]
     (test (.dep.deploy required-4)
           (assoc option-3+
                  :focus.meta (set (filter keyword?
                                           focus))
                  :skip.meta  (set (filter keyword?
                                           skip)))))))


;;;;;;;;;; Dev


(def .*dev?*

  ^{:doc {:description ["Boolean indicating if the Shell is in dev mode."
                        "Some utilities uses this value to change behavior."
                        ""
                        "E.g. `.dep.test` will not terminate the process if this value is `false`."]}}

  false)



(defn .dev.set

  ^{:callable? true
    :doc       {:description ["Sets `.*dev*`."]
                :examples    [{:code (.dev.set true)}]
                :signature   [{:params [enable?]}]}}

  [enable?]

  (if (= *address*
         $CORE$)
    (def .*dev?*
         (boolean enable?))
    (call $CORE$
          (.dev.set enable?))))


;;;;;;;;; Etch


(defn .db.flush

  ^{:doc {:description ["Flushes the current Etch instance."
                        ""
                        "Happens automatically when the process terminates gracefully."
                        "Good idea to flush manually once in a while to ensure data"
                        "is persisted on disk."]
          :examples    [{:code (.db.flush)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.flush))



(defn .db.open

  ^{:doc {:description ["Opens an Etch instance."
                        ""
                        "Must be called before calling any other DB function."
                        "Not providing a path will create an instance in a temporary file."
                        "File is created if it does not exist."
                        ""
                        "Attention, only one instance can be open per Shell."]
          :examples    [{:code (.db.open \"path/to/file.etch\")}]
          :signature   [{:params [path]}]}}


  ([]

   (.db.open nil))


  ([path]

   (.shell.invoke '.db.open
                  (or path
                      (.fs.tmp "convex-shell-"
                               ".etch")))))



(defn .db.path

  ^{:doc {:description ["Returns the path of the current Etch instance (or nil if"
                        "no instance has been open)."]
          :examples    [{:code (.db.flush)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.path))



(defn .db.read
  
  ^{:doc {:description ["Reads a cell by hash from the current Etch instance."
                        "Returns `nil` if no cell is found for that hash."
                        ""
                        "Also see `.db.write`."]
          :examples    [{:code (.db.read 0x1fa0dd51b167d4cca60177d13d731c461eae9cdb4ecd75e1e8f2158251968c66)}]
          :signature   [{:params [hash]}]}}

  [hash]

  (.shell.invoke '.db.read
                 hash))



(defn .db.root.read

  ^{:doc {:description ["Reads the root cell from the current Etch instance."
                        "Returns `nil` if no cell has been persisted to the root."
                        ""
                        "Also see `.db.root.write`."]
          :examples    [{:code (.db.root.read)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.root.read))



(defn .db.root.write

  ^{:doc {:description ["Writes the given `cell` to the root of the current Etch instance."
                        "Otherwise, behaves exactly like `.db.write`."
                        ""
                        "Also see `.db.root.read`."]
          :examples    [{:code (.db/.root.write [:my 'cell 42])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.root.write
                 cell))



(defn .db.write

  ^{:doc {:description ["Writes the given `cell` to the current Etch instance."
                        "Returns the hash of that cell."
                        ""
                        "If the returned value is `nil`, it means the cell was not persisted."
                        "This happens only with a few basic cells for optimization reasons."
                        "Precisely, those that are so simple they are usually embedded in more complex values:"
                        ""
                        "  - Addresses"
                        "  - Empty collections"
                        "  - Primitives (booleans, bytes, doubles, longs)"
                        "  - Symbolic (keywords and symbols)"
                        ""
                        "Also see `.db.read`."]
          :examples    [{:code (.db.write [:my 'cell 42])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.write
                 cell))


;;;;;;;;;; Exceptions


(defn .ex.print

  ^{:doc {:description ["Pretty prints the given exception (by default to `.stream.*out*`."
                        "For catching exceptions, see `.state.safe` and `.state.tmp`."]
          :examples    [{:code (.ex.print {:code :ARGUMENT, :message "Some message"})}]
          :signature   [{:params [ex]}
                        {:params [stream ex]}]}}

  ([ex]

   (.ex.print nil
              ex))


  ([stream ex]

   (let [msg        (:message ex)
         msg-2      (when (map? msg)
                      (:message msg))
         extra-data (when msg-2
                      (dissoc msg
                              :message))
         trace      (:trace ex)
         trace-2    trace]
     (.stream.txt.outln
       stream
       (str .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Exception code:"
            (.term.reset)
            .sys.eol
            "  "
            (.term.bold)
            (:code ex)
            (.term.bold)
            (.term.fg.red)
            .sys.eol
            "Executing address:"
            (.term.reset)
            .sys.eol
            "  "
            (:address ex)
            .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Message:"
            (.term.reset)
            .sys.eol
            "  "
            (or msg-2
                msg)
            .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Trace:"
            (.term.reset)
            (if (empty? trace-2)
              (str .sys.eol
                   "  None.")
              (apply str
                     (reduce (fn [acc entry]
                               (conj acc
                                     .sys.eol
                                     "  "
                                     entry))
                             []
                             trace-2)))
            (if (and extra-data
                     (not (empty? extra-data)))
              (str .sys.eol
                   (.term.bold)
                   (.term.fg.red)
                   "Extra data:"
                   (.term.reset)
                   .sys.eol
                   "  "
                   extra-data)
              ""))))))



(defn .ex.rethrow
  ^{:doc {:description ["Rethrow the given exception."
                        "For catching exceptions, see `.state.safe` and `.state.tmp`."]
          :examples    [{:code (.ex.rethrow {:code :ARGUMENT, :message "Some message"})}]
          :signature   [{:params [ex]}]}}

  [ex]

  (.shell.invoke '.ex.rethrow
                 ex))


;;;;;;;;;; File operations


(defn .file.-handle

  ^:private?

  [x path]

  (if (nil? x)
    [(.gensym "file-")
     (.fs.resolve path)]
    x))



(defn .file.-read

  ^:private?

  [f-in path]

  (let [handle (.file.stream.in path)
        [ok?
         x]    (.state.safe (fn []
                              (f-in handle)))]
    (.stream.close handle)
    (if ok?
      x
      (.ex.rethrow x))))



(defn .file.-write

  ^:private?

  [f-out path cell option+]

  (let [handle (.file.stream.out path
                                  option+)
        [ok?
         x]    (.state.safe (fn []
                              (f-out handle
                                     cell)))]
    (.stream.close handle)
    (if ok?
      x
      (.ex.rethrow x))))


;;;


(defn .file.exec

  ^{:doc {:description ["Like `.file.read` but also applies `eval`."]
          :examples    [{:code (.file.exec "./my/file.cvx")}]
          :signature   [{:params [path]}]}}

  [path]

  (eval (cons 'do
              (.file.read path))))



(defn .file.read

  ^{:doc {:description ["Returns a list of cells resulting from reading the given file."
                        "Also see `.file.txt.read`."]
          :examples    [{:code (.file.read "./my/file.cvx")}]
          :signature   [{:params [path]}]}}

  ;; Stream is closed automatically in the Clojure code.

  [path]

  (.file.-read .stream.in+
               path))



(defn .file.stream.in

  ^{:doc {:description ["Returns a handle to an input stream for the given file."
                        "See stream utils such as `.stream.line`."]
          :examples    [{:code (.file.stream.in "./my/file.cvx")}]
          :signature   [{:params [path]}]}}


  [path]

  (.shell.invoke '.file.stream.in
                 (.resrc.next)
                 (.fs.resolve path)
                 path))



(defn .file.stream.out

  ^{:doc {:description ["Returns a handle to an output stream for the given file."
                        "See stream utils such as `.stream.outln`."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :append?"
                        "    Writes will be appended to the end if true, otherwise file will be overwritten if it exists."
                        "    False by default."]
          :examples    [{:code (.file.stream.out "./my/file.cvx")}
                        {:code (.file.stream.out "./my/file.cvx" {:append? true})}]
          :signature   [{:params [path]}
                        {:params [path option+]}]}}


  ([path]

   (.file.stream.out path
                     nil))


  ([path option+]

   (.shell.invoke '.file.stream.out
                  (.resrc.next)
                  path
                  (:append? option+))))



(defn .file.txt.read

  ^{:doc {:description ["Returns the content of the given file as a string."
                        "Also see `.file.read`."]
          :examples    [{:code (.file.txt.read "some/file.txt")}]
          :signature   [{:params [path]}]}}

  [path]

  (.file.-read .stream.txt.in
               path))



(defn .file.txt.write

  ^{:doc {:description ["Writes the given cell to the given file as a string."
                        "Same options as `.file.stream.out`."
                        ""
                        "Also see `.file.write`."]
          :examples    [{:code (.file.txt.write "some/file.txt" "Some text")}
                        {:code (.file.txt.write "some/file.txt" "Some text" {:append? true})}]
          :signature   [{:params []}]}}


  ([path cell]

   (.file.txt.write path
                    cell
                    nil))


  ([path cell option+]

   (.file.-write .stream.txt.outln
                 path
                 cell
                 option+)))



(defn .file.write

  ^{:doc {:description ["Writes the given cell to the given file."
                        "Same options as `.file.stream.out`."
                        "Can be read back with `.file.read`."
                        ""
                        "Also see `.file.txt.write`."]
          :examples    [{:code (.file.write "some/file.cvx" [:a :b])}
                        {:code (.file.write "some/file.cvx" [:a :b] {:append? true})}]
          :signature   [{:params []}]}}


  ([path cell]

   (.file.write path
                cell
                nil))


  ([path cell option+]

   (.file.-write .stream.outln
                 path
                 cell
                 option+)))


;;;;;;;;;; Filesystem operations


(defn .fs.copy

  ^{:doc {:description ["Copies the file at `path-source` to `path-destination`."
                        "If `path-destination` is a directory, `path-source` will be copied inside it."
                        "Behaves like Unix's `cp`."]
          :examples    [{:code (.file.copy "some_dir/foo.txt" "another_dir")}]
          :signature   [{:params [path-source path-destination]}]}}

  [path-source path-destination]

  (.shell.invoke '.fs.copy
                 path-source
                 path-destination))



(defn .fs.delete

  ^{:doc {:description "Deletes the file or the empty folder at the given `path`."
          :examples    [{:code (.file.delete "some-file.cvx")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.delete
                 path))



(defn .fs.dir?

  ^{:doc {:description ["Returns `true` if the given path refers to an existing directory."]
          :examples    [{:code (.fs.dir? "some/path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.dir?
                 path))



(defn .fs.exists?

  ^{:doc {:description ["Returns `true` if a file or directory exists at the given path."]
          :examples    [{:code (.file.exists? "some_dir/some_file.txt")}]
          :signatures  [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.exists?
                 path))



(defn .fs.file?

  ^{:doc {:description ["Returns `true` if the given path refers to an existing regular file."]
          :examples    [{:code (.fs.file? "some/path")}]
          :signature   [{:params [path]}]}}
  [path]

  (.shell.invoke '.fs.file?
                 path))



(defn .fs.resolve

  ^{:doc {:description ["Returns the given path fully resolved as an absolute path."
                        "Follows symlinks."]
          :examples    [{:code (.fs.resolve "some/../../path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.resolve
                 path))



(defn .fs.size

  ^{:doc {:description ["Returns the size of the file at the given path (in bytes)."
                        "Returns `nil` if the file does not exist."]
          :examples    [{:code (.fs.size "some/path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.size
                 path))



(defn .fs.tmp

  ^{:doc {:description ["Creates a temporary file."
                        "`prefix` and `suffix` for the filename are both optional."]
          :examples    [{:code (.file.tmp)}
                        {:code (.file.tmp ".cvx")}
                        {:code (.file.tmp "some-project_" ".cvx")}]
          :signature   [{:params []}
                        {:params [suffix]}
                        {:params [prefix suffix]}]}}


  ([]

   (.fs.tmp nil
            nil))


  ([suffix]

   (.fs.tmp nil
            suffix))


  ([prefix suffix]

   (.shell.invoke '.fs.tmp
                  (or prefix
                      "")
                  (or suffix
                      ""))))



(defn .fs.tmp.dir

  ^{:doc {:description ["Creates a temporary directory."
                        "`prefix` is optional."]
          :examples    [{:code (.file.tmp.dir)}
                        {:code (.file.tmp-dir "some-prefix")}]
          :signature   [{:params []}
                        {:params [prefix]}]}}


  ([]

   (.fs.tmp.dir nil))


  ([prefix]

   (.shell.invoke '.fs.tmp.dir
                  (or prefix
                      ""))))


;;;;;;;;;; Gensym


(def .*gensym*

  ^:private?

  0)



(defn .gensym

  ^{:callable? true
    :doc       {:description ["Returns a symbol guaranteed to be unique relative to other symbols generated"
                              "with this function in the context of a single process."
                              ""
                              "A prefix string may be provided (default to \"G_\")."
                              ""
                              "Useful for metaprogramming."]
                :examples    [{:code (.gensym)}
                              {:code ($.gensym "some-prefix-")}]
                :signature   [{:params []}
                              {:params [prefix]}]}}

  
  ([]

   (.gensym nil))


  ([prefix]

   (if (= *address*
          $CORE$)
     (do
       (let [id .*gensym*]
         (def .*gensym*
              (inc id))
         (symbol (str (or prefix
                          "G_")
                      id
                      "_"
                      (.time.nano)))))
     (call $CORE$
           (.gensym prefix)))))


;;;;;;;;;; Juice operations


(defn .juice.refill

  ^{:doc {:description ["Refills `*juice*` to the maximum value."
                        "Useful to call once in a while when running long operations."]
          :examples    [{:code (.juice.refill)}]
          :signature   [{:params []}]}}

  []

  (.juice.set 9223372036854775807))



(defn .juice.set

  ^{:doc {:description ["Sets `*juice*` to an exact amount."
                        "Useful when there is a need for limiting an operation."]
          :examples    [{:code (.juice.set 10000000)}]
          :signature   [{:params [n-unit]}]}}

  [n-unit]

  (.shell.invoke '.juice.set
                 n-unit))



(defn .juice.track

  ^{:doc {:description ["Tracks the juice consumption of the given transaction."
                        "Any state change is reverted."
                        ""
                        "Returns a vector of 4 elements:"
                        ""
                        "  0: Transaction result"
                        "  1: Juice cost when running as is"
                        "  2: Juice cost after `compile`"
                        "  3: Juice cost after `expand`"]
          :examples    [{:code (.juice.track '(if :a :b :c))}
                        {:code (.juice.track (compile '(if :a :b :c)))}]
          :signature   [{:params [trx]}]}}

  [trx]

  (conj (.shell.invoke '.juice.track
                       trx)
        (second (.shell.invoke '.juice.track
                               (compile trx)))
        (second (.shell.invoke '.juice.track
                               (expand trx)))))


;;;;;;;;;; CVM log operations


(defn .log.clear

  ^{:doc {:description ["Clears the CVM log."
                        "Also see `.log.get`."]
          :examples    [{:code (.log.clear)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.log.clear))



(defn .log.get

  ^{:doc {:description ["Returns the current CVM log."
                        "Values can be logged using the core `log` function."
                        ""
                        "Also see `.log.clear`."]
          :examples    [{:code (.log.get)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.log.get))


;;;;;;;;;; Project files


(def .project.*dir*

  ^{:doc {:description ["Path to the directory containing `project.cvx`."
                        "Also see `.project.dir.set`."]}}

  "./")



(defn .project.dir.set

  ^{:callable? true
    :doc       {:description ["Points `.project.*dir*` to another directory."]
                :examples    [{:code (.project.dir.set "some/dir")}]
                :signature   [{:params [dir]}]}}

  [dir]

  (if (= *address*
         $CORE$)
    (do
      (when-not (.fs.dir? dir)
        (fail :ARGUMENT
              "Given path is not a directory"))
      (def .project.*dir*
           dir))
    (call $CORE$
          (.project.dir.set dir))))


;;;;;;;;;; Reader


(defn .reader.form+

  ^{:doc {:description ["Returns a list of cells read from the given string."]
          :examples    [{:code (.reader.form+ ":a :b :c")}]
          :signature   [{:params [string]}]}}
  [string]

  (.shell.invoke '.reader.form+
                 string))


;;;;;;;;;; REPL


(defn .repl

  ^{:doc {:description ["Starts a Read-Eval-Print-Loop for working interactively."
                        ""
                        "By default, a prompt is printed and the user can introduce a lines of cells to evaluate."
                        "Results and exceptions are printed."
                        "Stops when the user enter `:q` or `:quit`."
                        ""
                        "A map of options may be provided to alter the behavior of the REPL."
                        "Functions in this map takes a state map and must returns it, altered or not."
                        "The state map starts with those options. Users may want to attach additional
                         information."
                        ""
                        "Options may be:"
                        ""
                        "  :eval"
                        "    Function for producing a result given cells attached under `:result`."
                        "    Defaults to `.repl.eval`."
                        ""
                        "  :on.ex"
                        "    Function for acting when `:eval` throws an exception."
                        "    Exception is attached under `:result`."
                        "    Defaults to `.repl.on.ex`."
                        ""
                        "  :on.ex.reader"
                        "    Function for acting on reader errors, when an input line is not valid Convex data."
                        "    Besides the state map, also takes the message of the reader exception."
                        "    Defaults to `.repl.on.ex.reader`."
                        ""
                        "  :on.prompt"
                        "    Function for acting prior to asking for input (e.g. print a prompt)."
                        "    Defaults to `.repl.on.prompt`."
                        ""
                        "  :on.result"
                        "     Function for acting when a result is produced."
                        "     Defaults to `.repl.on.result`."
                        ""
                        "  :stop?"
                        "    Function for deciding if the REPL should stop after reading a line but before evaluating it."
                        "    Defaults to `.repl.stop?`."
                        ""
                        "  :stream.in"
                        "    Input stream for reading lines of cells."
                        "    Defaults to `.stream.*in*`."
                        ""
                        "  :stream.out"
                        "    Output stream for printing results."
                        "    Defaults to `.stream.*out*`."]
          :examples    [{:code (.repl)}]
          :signature   [{:params []}
                        {:params [option+]}]}}


  ([]

   (.repl nil))


  ([option+]

   (loop [state (merge {:eval         .repl.eval
                        :on.ex        .repl.on.ex
                        :on.ex.reader .repl.on.ex.reader
                        :on.prompt    .repl.on.prompt
                        :on.result    .repl.on.result
                        :stop?        .repl.stop?
                        :stream.in    .stream.*in*
                        :stream.out   .stream.*out*}
                       option+)]
     (let [state-2 ((:on.prompt state) state)
           [read?
            x]     (.state.safe (fn []
                                  (.stream.line (:stream.in state-2))))]
       (if read?
         ;;
         ;; Successful read.
         ;;
         (let [form+   x
               state-3 (assoc state-2
                              :form+
                              form+)]
           (cond
             ;;
             (nil? form+)
             state-3
             ;;
             (empty? form+)
             (recur state-3)
             ;;
             ((:stop? state-3) state-3)
             state-3
             ;;
             (let [[ok?
                    x]     (.state.safe (fn []
                                          ((:eval state-3) (assoc state-3
                                                                  :form+
                                                                  form+))))
                   state-4 (if ok?
                             (let [state-4 x]
                               ((:on.result state-4) state-4))
                             (let [ex x]
                               ((:on.ex state) (assoc state-3
                                                      :result
                                                      ex))))]
               (if (contains-key? state-4
                                  :result)
                 (recur state-4)
                 state-4))))
         ;;
         ;; Reading input failed.
         ;;
         (let [ex x]
           (if (= (:code ex)
                  :READER)
             (let [state-3 ((:on.ex.reader state) state
                                                  (:message ex))]
               (if (contains-key? state-3
                                  :result)
                 (recur state-3)
                 state-3))
             (.ex.rethrow ex))))))))



(defn .repl.eval

  ^{:doc {:description "See `.repl`."}}

  [state]

  (assoc state
         :result
         (eval (concat `(let [$ (quote ~(:result state))])
               (:form+ state)))))



(defn .repl.on.ex

  ^{:doc {:description "See `.repl`."}}

  [state]

  (let [out   (:stream.out state)
        ex    (:result state)
        trace (:trace ex)
        ex-2  (assoc ex
                     :trace
                     (slice trace
                            0
                            ;; Removing lines relating to the REPL, not interesting.
                            (- (count trace)
                               3)))]
    (.ex.print out
               ex-2)
    (.stream.txt.outln out
                       "")
    (assoc state
           :result
           ex-2)))



(defn .repl.on.ex.reader

  ^{:doc {:description "See `.repl`."}}

  [state message]

  (.stream.txt.outln (:stream.out state)
                     (str .sys.eol
                          (.term.fg.red)
                          (.term.bold)
                          "Input cannot be parsed as Convex Lisp:"
                          (.term.reset)
                          .sys.eol
                          "  "
                          message
                          .sys.eol))
  state)



(defn .repl.on.prompt

  ^{:doc {:description "See `.repl`."}}

  [state]

  (let [out (:stream.out state)]
    (.stream.txt.out out
                     (str (.term.bold)
                          (.term.fg.blue)
                          "> "
                          (.term.reset)))
    (.stream.flush out))
  state)



(defn .repl.on.result

  ^{:doc {:description "See `.repl`."}}

  [state]

  (let [out (:stream.out state)]
    (.stream.txt.out out
                     .sys.eol)
    (.stream.out out
                 (:result state))
    (.stream.txt.out out
                     .sys.eol)
    (.stream.txt.out out
                     .sys.eol)
    (.stream.flush out))
  state)



(defn .repl.stop?

  ^{:doc {:description "See `.repl`."}}

  [state]

  (contains-key? #{:exit
                   :q
                   :quit
                   :stop}
                 (first (:form+ state))))


;;;;;;;;;; Used by resources external to the CVM


(def .resrc.*count*

  ^:private?

  0)



(defn .resrc.next

  ^{:callable? true
    :doc       {:description ["Returns an ever incrementing Long."
                              "Some utilities use this function for identifying resources external"
                               "to the Convex Virtual Machine (e.g. stream handles)."]
                :examples    [{:code (.resrc.next)}]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         $CORE$)
    (def .resrc.*count*
         (inc .resrc.*count*))
    (call $CORE$
          (.resrc.next))))


;;;;;;;;;; Shell


(defn .shell.inspect

  ^{:doc {:description ["Returns a set of symbols expressing features offered by the Shell."
                        "Those symbols often relates directly to functions and are not native"
                        "to the regular Convex Virtual Machine."
                        ""
                        "See also `.shell.limit`."]
          :examples    [{:code (.shell.inspect)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.shell.inspect))



(def .shell.invoke

  ^{:doc {:description ["Main entry point for accessing features offered by the Shell."
                        "Aka the \"invoker\"."
                        "Shell functions often delegates to it."
                        ""
                        "The regular user should never have to call this function directly."
                        "For experts only."]
          :examples    [{:code (.shell.invoke '.time.unix)}]
          :signature   [{:params [feature & arg+]}]}}

  ;; Injected from Clojure.

  ^:private?

  nil)



(defn .shell.limit

  ^{:doc {:description ["Limits the features offered by the Shell."
                        ""
                        "See `.shell.inspect` about getting the set of currently available features."
                        "This function takes a similar set and will limit `.shell.invoke` to those only."
                        ""
                        "Thus, an empty set removes all Shell features, resulting in a pure Convex Virtual Machine."
                        ""
                        "A common pattern is to call `.shell.limit` inside `.state.tmp*`, so that the Shell"
                        "is limited only temporarily."]
          :examples    [{:code (.shell.limit #{})}
                        {:code (.shell.limit (disj (.shell.inspect) '.time.unix))}]
          :signature   [{:params [feature-set]}]}}

  [feature-set]

  (.shell.invoke '.shell.limit
                 feature-set))



(defn .shell.main

  ^:private?

  [src]

  (let [[ok?
         x]  (.state.safe (fn []
                            (.reader.form+ src)))]
    (cond
      ;;
      ok?
      (let [form+ x]
        (if (empty? form+)
          (do
            (.dev.set true)
            (.stream.txt.outln
              (str (.term.fg.blue)
                   (.term.bold)
                   "Convex Shell (REPL mode)"
                   (.term.reset)
                   .sys.eol
                   "Enter transactions and build a new world."
                   .sys.eol
                   .sys.eol
                   "Powered by Protosens SRL and collaborators."
                   .sys.eol
                   "For help, type: "
                   (.term.bold)
                   "(?)"
                   (.term.reset)
                   .sys.eol))
            (.repl)
            nil)
          (eval (cons 'do
                      form+))))
      ;;
      (= (:code x)
         :READER)
      (do
        (.stream.txt.outln
           (str .sys.eol
                (.term.fg.red)
                (.term.bold)
                "Input cannot be parsed as Convex Lisp:"
                (.term.reset)
                .sys.eol
                "  "
                (:message x)
                .sys.eol))
        (.sys.exit 4))
      ;;
      (fail :SHELL.FATAL
            {:message "Initialization problem while reading input"}))))



(def .shell.*root*

  ^{:doc {:description ["Root directory used by the Shell."
                        "E.g. This is where `.dep.fetch` caches foreign dependencies."
                        ""
                        "Also see `.shell.root.set`."]}}

  "~/.convex-shell")



(defn .shell.root.set

  ^{:callable? true
    :doc       {:description ["Points `.shell.*root*` to another directory."
                              "Given path must point to an existing one."]
                :examples    [{:code (.shell.root.set "./some/dir")}]
                :signature   [{:params [dir]}]}}

  [dir]

  (if (= *address*
         $CORE$)
    (do
      (when-not (str? dir)
        (fail :ARGUMENT
              "Given path is not a string"))
      (def .shell.*root*
           dir))
    (call $CORE$
          (.shell.root.set dir))))


;;;;;;;;;; Creating and handling states


(defn .state.genesis

  ^{:doc {:description ["Generates and return a genesis state."
                        ""
                        "The genesis state is the original state used by the Convex network"
                        "to bootstrap. Such a state does not have any of the features offered"
                        "by the Shell."
                        ""
                        "A vector of distinct keys may be provided for creating initial user accounts."
                        "If not, one account is created with `.account.0-key`."]
          :examples    [{:code (.state.genesis)}
                        {:code (.state.genesis [0x1122334455667788990011223344556677889900112233445566778899001122])}]
          :signature   [{:params []}
                        {:params [key+]}]}}

  ([]

   (.state.genesis nil))


  ([key+]

   (.shell.invoke '.state.genesis
                  (or key+
                      [.account.0-key]))))



(defn .state.safe

  ^{:doc {:description ["Executes the given function in a safe, atomic way."
                        "Returns a vector of 2 elements."
                        ""
                        "First item is a boolean indicating if the function ran without throwing"
                        "an exception."
                        ""
                        "If `true`, second item is the returned result."
                        "If `false`, second item is the thrown exception and `*state*` is reverted."
                        ""
                        "Usually, prefer the `.state.safe*` macro for convenience."]
          :examples    [{:code (.state.safe (fn [] (assert false)))}]
          :signature   [{:params [f]}]}}
  [f]

  (.shell.invoke '.state.safe
                 f))



(defmacro .state.safe*

  ^{:doc {:description ["Executes the given code exactly like `.state.safe`."
                        "More convenient to use."]
          :examples    [{:code (.state.safe* (def x []) (inc x))}]
          :signature   [{:params [& form+]}]}}

  [& form+]

  `(~$CORE$/.state.safe (fn []
                          ~(cons 'do
                                 form+))))
 


(defn .state.switch

  ^{:doc {:description ["Switches `*state*` to the given one."
                        "For instance, a state produced with `.state.genesis` or a state"
                        "retrieved from Etch."
                        ""
                        "Provided address must point to an account in the target state."
                        "By default, current `*address*` is used."
                        ""
                        "Attention, beware of consequences."
                        "E.g. Switching in a middle of an actor call who was working under"
                        "     assumptions relating to the old `*state*`."]
          :examples    [{:code (.state.switch (.state.genesis))}]
          :signature   [{:params [state]}]}}


  ([state]

   (.state.switch nil
                  state))


  ([address state]

   (.shell.invoke '.state.switch
                  (or address
                      *address*)
                  state)))



(defn .state.tmp

  ^{:doc {:description ["Exactly like `.state.safe` but the state is always reverted."
                        "Even if an exception is not thrown."
                        ""
                        "Also see the `.state.tmp*` macro for convenience."]
          :examples    [{:code (.state.tmp (fn [] (def x 42) (inc x)))}]
          :signature   [{:params [f]}]}}

  [f]

  (.shell.invoke '.state.tmp
                 f))



(defmacro .state.tmp*

  ^{:doc {:description ["Convenience macro over `.state.tmp`."
                        "Wraps given code into a function."]
          :examples    [{:code (state.tmp* (def x 42) (inc x))}]
          :signature   [{:params [& form+]}]}}

  [& form+]

  `(~$CORE$/.state.tmp (fn []
                         ~(cons 'do
                                form+))))


;;;;;;;;;; Strings


(defn .str.pluralize

  ^:private?

  [n s]

  (if (> n
         1)
    (str s
         "s")
    s))



(defn .str.sort

  ^:private?

  [str+]

  (.shell.invoke '.str.sort
                 str+))



(defn .str.stream.in

  [string]

  (.shell.invoke '.str.stream.in
                 (.resrc.next)
                 string))



(defn .str.stream.out

  ;; Closing has no effect.

  []

  (.shell.invoke '.str.stream.out
                 (.resrc.next)))



(defn .str.stream.unwrap

  [handle]

  (.shell.invoke '.str.stream.unwrap
                 handle))


;;;;;;;;;; Streams


(def .stream.stderr

  ^{:doc {:description "Stream for STDERR"}}

  .stream.stderr)



(def .stream.stdin

  ^{:doc {:description "Stream for STDIN."}}

  .stream.stdin)



(def .stream.stdout

  ^{:doc {:description "Stream for STDOUT"}}

  .stream.stdout)


;;;


(def .stream.*err*

  ^{:doc {:description ["Default error stream, originally set to `stderr`."
                        "See `set.err`."]}}

  .stream.stderr)



(def .stream.*in*

  ^{:doc {:description ["Default input stream, originally set to `stdin`."
                        "See `set.in`."]}}

  .stream.stdin)



(def .stream.*out*

  ^{:doc {:description ["Default output stream, originally set to `stdout`."
                        "See `set.out`."]}}

  .stream.stdout)



(defn .stream.close

  ^{:doc {:description ["Returns a request for closing the given `handle`."
                        "`$.stream/stderr` cannot be closed."]
          :examples    [{:code "($.stream/!.close $.stream/stdout)"}]
          :signature   [{:params [handle]}]}}

  [handle]

  (.shell.invoke '.stream.close
                 handle))



(defn .stream.err

  ^{:doc {:description "Uses `$.stream/!.out` ont `*err*` for printing `x` to the default error stream."
          :examples    [{:code "($.stream/!.err {:some :error})"}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.out .stream.*err*
               x))



(defn .stream.errln

  ^{:doc {:description "Uses `$.stream/!.outln` ont `*err*` for printing `x` to the default error stream."
          :examples    [{:code "($.stream/!.errln {:some :error})"}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.outln .stream.*err*
                 x))



(defn .stream.flush

  ^{:doc {:description ["Returns a request for flushing the given output `handle` and ensuring all outputs are processed."
                        "Flushes `*out*` by default."]
          :examples    [{:code "($.stream/!.flush)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.flush .stream.*out*))


  ([handle]

   (.shell.invoke '.stream.flush
                  handle)))



(defn .stream.in+

  ^{:doc {:description ["Returns a request for reading the given input `handle`."
                        "Reads from `*in*` by default."
                        "Whole input is read and `handle` is automatically closed."
                        "List of read cells becomes available during next transaction under `$/*result*`."]
          :examples    [{:code "($.stream/!.in+ $.stream/stdin)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.in+ .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.in+
                  handle)))



(defn .stream.line

  ^{:doc {:description ["Returns a request for reading a line from the given input `handle`."
                        "Reads from `*in*` by default."
                        "Stops when a new line is encountered."
                        "List of read cells becomes available during next the transaction under `$/*result*`."
                        "Result is `nil` when the end of the stream is reached. The stream is then closed"
                        "automatically."]
          :examples    [{:code "($.stream/!.line)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.line .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.line
                  handle)))



(defn .stream.out

  ^{:doc {:description ["Returns a request for writing `x` to the given output `handle`."
                        "Writes to `*out*` by default."]
          :examples    [{:code "($.stream/!.out :foo)"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.out .stream.*out*
                x))


  ([handle x]

   (.shell.invoke '.stream.out
                  handle
                  x)))



(defn .stream.outln

  ^{:doc {:description "Likes `$.stream/!.out` but also outputs a new line and flushes the `handle`."
          :examples    [{:code "($.stream/!.outln :foo)"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.outln .stream.*out*
                  x))


  ([handle x]
   
   (.shell.invoke '.stream.outln
                  handle
                  x)))



(defn .stream.set.err

  ^{:callable? true
    :doc       {:description "Sets `*err*` to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*err*
         handle)
    (call $CORE$
          (.stream.set.err handle))))



(defn .stream.set.in

  ^{:callable? true
    :doc       {:description "Sets `*in*` to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*in*
         handle)
    (call $CORE$
          (.stream.set.in handle))))



(defn .stream.set.out

  ^{:callable? true
    :doc       {:description "Sets `*out* to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*out*
         handle)
    (call $CORE$
          (.stream.set.out handle))))



(defn .stream.txt.err

  ^{:doc {:description "Uses `$.stream/!.out` ont `*err*` for printing `x` to the default error stream."
          :examples    [{:code "($.stream/!.err {:some :error})"}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.txt.out .stream.*err*
                   x))



(defn .stream.txt.errln

  ^{:doc {:description "Uses `$.stream/!.outln` ont `*err*` for printing `x` to the default error stream."
          :examples    [{:code "($.stream/!.errln {:some :error})"}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.txt.outln .stream.*err*
                     x))



(defn .stream.txt.in

  ^{:doc {:description ["Returns a request for reading the rest of the given input `handle` as text."
                        "Reads from `*in*` by default."
                        "String will be available during the next transaction under `$/*result*`."
                        "Stream is closed automatically."]
          :examples    [{:code "($.stream/!.txt.in 42)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.in .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.txt.in
                  handle)))



(defn .stream.txt.line

  ^{:doc {:description ["Returns a request for reading a line from the given input `handle` as text."
                        "Reads from `*in*` by default."
                        "String will be available during the next transaction under `$/*result*`."
                        "Result is `nil` when the end of the stream is reached. The stream is then closed"
                        "automatically."]
          :examples    [{:code "($.stream/!.txt.line)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.line .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.txt.line
                  handle)))



(defn .stream.txt.out

  ^{:doc {:description ["Like `$.stream/!.out` but if `cell` is a string, it will not be double-quoted."
                        "Hence, the output might not be readable as Convex Lisp."]
          :examples    [{:code "($.stream/!.txt.out \"This is some text\")"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.out .stream.*out*
                    x))


  ([handle x]

   (.shell.invoke '.stream.txt.out
                  handle
                  x)))



(defn .stream.txt.outln

  ^{:doc {:description ["Like `$.stream/!.outln` but if `cell` is a string, it will not be double-quoted."
                        "Hence, the output might not be readable as Convex Lisp."]
          :examples    [{:code "($.stream/!.txt.outln \"This is some text\")"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.outln .stream.*out*
                      x))


  ([handle x]

   (.shell.invoke '.stream.txt.outln
                  handle
                  x)))


;;;;;;;;;; System utilities


(defn .sys.arch

  []

  (.shell.invoke '.sys.arch))



(defn .sys.cwd

  []

  (.shell.invoke '.sys.cwd))



(defn .sys.env

  []

  (.shell.invoke '.sys.env))



(defn .sys.env.var

  [var]

  (.shell.invoke '.sys.env.var
                 var))



(def .sys.eol

  ;; Set from Clojure.

  .sys.eol)



(defn .sys.exit

  [code]

  (.shell.invoke '.sys.exit
                 code))



(defn .sys.home

  []

  (.shell.invoke '.sys.home))



(defn .sys.os

  []

  (.shell.invoke '.sys.os))


;;;;;;;;;; Unit testing


(def .t.*assert+*

  [])



(defn .t.assert.add

  ^:callable?
  ^:private?

  [assertion]

  (if (= *address*
         ~*address*)
    (def .t.*assert+*
         (conj .t.*assert+*
               assertion))
    (call ~*address*
          (.t.assert.add assertion))))



(defn .t.assert.failed+

  ^:private?

  [assertion+]

  (reduce (fn [acc assertion]
            (let [[ok?
                   x]         (:result assertion)
                  assertion-2 (if ok?
                                (if (syntax? x)
                                  (if-let [status (:test.status (meta x))]
                                    {:fail   (unsyntax x)
                                     :status status}
                                    {:fail   x
                                     :status :fail})
                                  (when-not (= x
                                               true)
                                    {:fail   x
                                     :status :fail}))
                                {:fail   x
                                 :status :exception})]
              (if assertion-2
                (conj acc
                      (assoc assertion-2
                             :form    (:form assertion)
                             :message (:message assertion)))
                acc)))
          []
          assertion+))



(defmacro .t.ex


  ([form]

   `(.t.ex nil
           ~form))


  ([ex-code form]

   `(let [ex-code ~ex-code
          [ok?
           x]    (.state.safe* ~form)]
      (if ok?
        (syntax x
                {:test.status :fail})
        (if (nil? ex-code)
          true
          (or (= ex-code
                 (:code x))
              (syntax x
                      {:test.status :exception})))))))



(defmacro .t.def

  [name & assertion+]

  (let [[name-2
         meta-]      (if (syntax? name)
                       [(unsyntax name)
                        (meta name)]
                       [name
                        nil])
        first-assert (when-not (empty? assertion+)
                       (first assertion+))
        meta-2       (if (syntax? first-assert)
                       (merge meta-
                              (meta first-assert))
                       meta-)]
    `(defn ~(syntax name-2
                    (assoc meta-2
                           :test?
                           true))

       []

       ~(cons 'do
               assertion+))))



(defn .t.dev

  ^:private?

  ([required]

   (.t.dev required
           nil))


  ([required state]

   (= (:status (.t.run required
                       state))
      :pass)))



(defn .t.find

  ^:private?

  [state actor-sym actor-address]

  (let [account    (account actor-address)
        meta       (:metadata account)
        env        (:environment account)
        focus.test (get-in state
                           [:focus.test
                             actor-sym])
        skip.test  (get-in state
                           [:skip.test
                            actor-sym])]
    (reduce (fn [acc [sym x]]
              (let [sym-meta (get meta
                                  sym)]
                (if (and (fn? x)
                         (get-in meta
                                 [sym
                                  :test?])
                         (or (not focus.test)
                             (contains-key? focus.test
                                            sym))
                         (or (not skip.test)
                             (not (contains-key? skip.test
                                                 sym)))
                         (reduce (fn [_focus? k-focus]
                                   (if (get sym-meta
                                            k-focus)
                                     (reduced true)
                                     false))
                                 true
                                 (get state
                                      :focus.meta))
                         (reduce (fn [_skip? k-skip]
                                   (if (get sym-meta
                                            k-skip)
                                     (reduced false)
                                     true))
                                 true
                                 (get state
                                      :skip.meta)))
                  (conj acc
                        [sym
                         x])
                  acc)))
            []
            env)))



(defmacro .t.is


  ([form]

   `(.t.is ~form
           nil))


  ([form message]

   `(.t.assert.add {:form    (quote ~form)
                    :message ~message
                    :result  (.state.safe* ~form)})))



(defn .t.main

  ^:private?


  ([required]

   (.t.main required
            nil))


  ([required state]

   (.sys.exit (if (.t.dev required
                          state)
                0
                128))))



(defn .t.on.run.begin

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (str .sys.eol
                          "=========="
                          .sys.eol
                          .sys.eol
                          (.term.bold)
                          "["
                          (.term.reset)))
    (.stream.flush s))
  state)



(defn .t.on.run.end

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       (str (.term.bold)
                            "]"
                            (.term.reset)
                            .sys.eol
                            .sys.eol
                            "=========="
                            .sys.eol))
    (.docoll (fn [test]
               (if-let [f (get {:empty     .t.on.test.empty
                                :exception .t.on.test.ex
                                :fail      .t.on.test.fail}
                               (:status test))]
                 (f state
                    test)
                 nil))
             (:run state))
    (let [status (:status state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (cond
                                (= status
                                   :empty)
                                (str (.term.fg.red)
                                     "NO TESTS FOUND")
                                ;;
                                (= status
                                   :fail)
                                (str (.term.fg.red)
                                     "FAIL")
                                ;;
                                (= status
                                   :pass)
                                (str (.term.fg.green)
                                     "OK"))
                              (.term.bold)
                              .sys.eol)))
    (let [empty-actor+ (:empty-actor+ state)
          n-actor      (:n-actor state)
          n-test       (:n-test state)
          n-test-fail  (:n-test-fail state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (.term.fg.cyan)
                              n-test
                              " test"
                              (if (> n-test
                                     1)
                                "s"
                                "")
                              (.term.reset)
                              " run over "
                              (.term.bold)
                              (.term.fg.cyan)
                              n-actor
                              " actor"
                              (if (> n-actor
                                     1)
                                "s"
                               "")
                              (.term.reset)
                              ", "
                              (.term.bold)
                              (if (zero? n-test-fail)
                                (.term.fg.green)
                                (.term.fg.red))
                              n-test-fail
                              " failed"
                              (.term.reset)))
      (when-not (empty? empty-actor+)
        (.stream.txt.outln s
                           (str .sys.eol
                                .sys.eol
                                (.term.bold)
                                (.term.fg.red)
                                "Actors without tests:"
                                (.term.reset)
                                .sys.eol))
        (.docoll (fn [sym-actor]
                   (.stream.txt.outln s
                                      (str "  "
                                           sym-actor)))
                 empty-actor+))))
  state)



(defn .t.on.test.empty

  ^:private?

  [state test]

  (.t.print.test.name state
                      test)
  (.stream.txt.outln (:stream.out state)
                     "No assertions.")
  (.t.print.test.separator state))



(defn .t.on.test.ex

  ^:private?

  [state test]

  (.t.print.test.name state
                      test)
  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       "Exception thrown unexpectedly")
    (.ex.print s
               (:exception test)))
  (.t.print.test.separator state))



(defn .t.on.test.fail

  ^:private?

  [state test]

  (let [s (:stream.out state)]
    (.docoll (fn [failed]
               (.t.print.test.name state
                                   test)
               (when-let [message (:message failed)]
                 (.stream.txt.outln s
                                    (str message
                                         .sys.eol)))
               (.stream.txt.outln s
                                  (str (.term.bold)
                                       (.term.fg.cyan)
                                       "Form:   "
                                       (.term.reset)
                                       (:form failed)))
               (let [status (:status failed)]
                 (when-not (= status
                              :pass)
                   (cond
                     ;;
                     (= status
                        :fail)
                     (.stream.txt.outln s
                                        (str .sys.eol
                                             (.term.bold)
                                             (.term.fg.cyan)
                                             "Result: "
                                             (.term.reset)
                                             (:fail failed)))
                     ;;
                     (= status
                        :exception)
                     (.ex.print s
                                (:fail failed)))
                   (.t.print.test.separator state))))
             (:failed+ test))))



(defn .t.on.test.result

  [state result]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (if (= (:status result)
                            :pass)
                       (str (.term.bold)
                            (.term.fg.green)
                            "."
                            (.term.reset))
                       (str (.term.bold)
                            (.term.fg.red)
                            "X"
                            (.term.reset))))
    (.stream.flush s))
  state)



(defn .t.print.test.name

  ^:private?

  [state test]

  (.stream.txt.outln (:stream.out state)
                     (str (.term.bold)
                          (:name test)
                          (.term.reset)
                          .sys.eol))
  nil)



(defn .t.print.test.separator

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       "")
    (.stream.txt.outln s
                       "-----")
    (.stream.txt.outln s
                       ""))
  nil)



(defn .t.run

  ^:private?

  [actor-sym->addr state]

  (let [[ok?
         x]
        (.state.tmp
          (fn []
            (let [state          (merge {:on.run.begin   .t.on.run.begin
                                         :on.run.end     .t.on.run.end
                                         :on.test.result .t.on.test.result
                                         :stream.out     .stream.stdout}
                                        state)
                  on.run.begin   (:on.run.begin state)
                  on.run.end     (:on.run.end state)
                  state          (if on.run.begin
                                   (on.run.begin state)
                                   state)
                  state-2        (reduce (fn [state-2 [actor-sym actor-address]]
                                           (.t.run.actor state-2
                                                         actor-sym
                                                         actor-address))
                                         (assoc state
                                                :empty-actor+ []
                                                :n-actor      0
                                                :n-test       0
                                                :n-test-fail  0)
                                         actor-sym->addr)
                 state-3         (.t.run.finalize state-2)]
             (if on.run.end
               (on.run.end state-3)
               state-3))))]
    (if ok?
      x
      (.ex.rethrow x))))



(defn .t.run.actor

  ^:private?

  [state actor-sym actor-address]

  (let [found (.t.find state
                       actor-sym
                       actor-address)]
    (if (empty? found)
      (assoc state
             :empty-actor+
             (conj (:empty-actor+ state)
                   actor-sym))
      (reduce (fn [state-2 [test-sym test-f]]
                (.t.run.test state-2
                             actor-sym
                             actor-address
                             test-sym
                             test-f))
              (assoc state
                     :n-actor
                     (inc (:n-actor state)))
              found))))



(defn .t.run.finalize

  ^:private?

  [state]

  (assoc state
         :status
         (cond
           ;;
           (zero? (:n-test state))
           :empty
           ;;
           (zero? (:n-test-fail state))
           :pass
           ;;
           :else
           :fail)))



(defn .t.run.test

  ^:private?

  [state actor-sym actor-address test-sym test-f]

  (let [on.test.result (:on.test.result state)
        [ok?
         x]            (.state.tmp (fn []
                                     (.account.switch actor-address)
                                     (test-f)
                                     .t.*assert+*))
        test-result    (if ok?
                         (.t.run.test.finalize x)
                         (let [trace (:trace x)]
                           {:exception (assoc x
                                              :trace
                                              ;; Removing lines relating to calling the test.
                                              (slice trace
                                                     0
                                                     (- (count trace)
                                                        2)))
                            :status    :exception}))
        test-result-2  (assoc test-result
                              :name
                              (str actor-sym
                                   "/"
                                   test-sym))
        state-2        (assoc state
                              :run
                              (conj (:run state)
                                    test-result-2))
        state-3        (assoc state-2
                              :n-test
                              (inc (:n-test state-2)))
        state-4        (if on.test.result
                         (on.test.result state-3
                                         test-result-2)
                         state-3)]
    (if (= (:status test-result-2)
           :pass)
      state-4
      (assoc state-4
             :n-test-fail
             (inc (:n-test-fail state-4))))))



(defn .t.run.test.finalize

  ^:private

  [assertion+]

  (let [n (count assertion+)]
    (if (zero? n)
      {:status :empty}
      (let [failed+ (.t.assert.failed+ assertion+)
            result  {:n n}]
        (if (empty? failed+)
          (assoc result
                 :status
                 :pass)
          (assoc result
                 :failed+ failed+
                 :status  :fail))))))


;;;;;;;;;; Basic ANSI terminal commands


(def .term.*style?*

  ^{:doc {:description ["True if text styling with functions from this account is enabled."
                        "False means that functions returning a color will instead return an empty string."]}}

  true)



(defn .term.style

 ^{:private? true}

 [x]

 (if .term.*style?*
   x
   ""))



(defn .term.style.enable?

  ^{:callable? true}

  [enable?]

  (if (= *address*
         ~*address*)
    (def .term.*style?*
         (boolean enable?))
    (call ~*address*
          (.term.style.enable? enable?))))


;; ANSI background colors


(defn .term.bg.black

  ^{:doc {:description "Background color black."}}

  []

  (.term.style "\033[40m"))



(defn .term.bg.blue

  ^{:doc {:description "Background color blue."}}

  []

  (.term.style "\033[44m"))



(defn .term.bg.cyan

  ^{:doc {:description "Background color cyan."}}

  []

  (.term.style "\033[46m"))



(defn .term.bg.green

  ^{:doc {:description "Background color green."}}

  []

  (.term.style "\033[42m"))



(defn .term.bg.magenta

  ^{:doc {:description "Background color magenta."}}

  []

  (.term.style "\033[45m"))


(defn .term.bg.red

  ^{:doc {:description "Background color red."}}

  []

  (.term.style "\033[41m"))



(defn .term.bg.white

  ^{:doc {:description "Background color white."}}

  []

  (.term.style "\033[47m"))



(defn .term.bg.yellow

  ^{:doc {:description "Background color yellow."}}

  []

  (.term.style "\033[43m"))


;;


(defn .term.bg.rgb

  ^{:doc {:description "Computes RGB color escape code for background color."
          :examples    [{:code "($.term/bg.rgb 156 120 201)"}]
          :signature   [{:params [r g b]}]}}

  [r g b]

  (if .term.*style?*
    (str "\033[48;2;" r ";" g ";" b "m")
    ""))


;; ANSI foreground colors


(defn .term.fg.black

  ^{:doc {:description "Foreground color black."}}

  []

  (.term.style "\033[30m"))



(defn .term.fg.blue

  ^{:doc {:description "Foreground color blue."}}

  []

  (.term.style "\033[34m"))



(defn .term.fg.cyan

  ^{:doc {:description "Foreground color cyan."}}

  []

  (.term.style "\033[36m"))



(defn .term.fg.green

  ^{:doc {:description "Foreground color green."}}

  []

  (.term.style "\033[32m"))



(defn .term.fg.magenta

  ^{:doc {:description "Foreground color magenta."}}

  []

  (.term.style "\033[35m"))



(defn .term.fg.white

  ^{:doc {:description "Foreground color white."}}

  []

  (.term.style "\033[37m"))



(defn .term.fg.red

  ^{:doc {:description "Foreground color red."}}

  []

  (.term.style "\033[31m"))



(defn .term.fg.yellow

  ^{:doc {:description "Foreground color yellow."}}

  []

  (.term.style "\033[33m"))


;;


(defn .term.fg.rgb

  ^{:doc {:description "Computes RGB color escape code for foreground color."
          :examples    [{:code "($.term/fg.rgb 156 120 201)"}]
          :signature   [{:params [r g b]}]}}


  [r g b]

  (if .term.*style?*
    (str "\033[38;2;" r ";" g ";" b "m")
    ""))


;; Terminal effects


(defn .term.bold

  ^{:doc {:description "Bold effect."}}

  []

  (.term.style "\033[1m"))



(defn .term.reset

  ^{:doc {:description "Resets all colors and effects."}}

  []

  (.term.style "\033[0m"))



(defn .term.reversed

  ^{:doc {:description "Reverses background and foreground colors."}}

  []

  (.term.style "\033[7m"))



(defn .term.underline

  ^{:doc {:description "Underlines text."}}

  []

  (.term.style "\033[4m"))


;;;;;;;;;; Moving


(defn .term.col

  ^{:doc {:description "Moves to column `n`."
          :examples    [{:code "($.term/col 42)"}]
          :signature   [{:params [n]}]}}

  [n]

  (str "\033[" n "G"))



(def .term.cursor.save

  ^{:doc {:description ["Escape code for saving current cursor position."
                        "See `cursor.restore`."]}}

  "\033[s")



(def .term.cursor.restore

  ^{:doc {:description ["Escape code for restoring last saved cursor position."
                        "See `cursor.save`."]}}

  "\033[u")



(defn .term.down

  ^{:doc {:description ["Comptes escape code for moving the cursor `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code "($.term/down 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down 1))


  ([n]

   (str "\033[" n "B")))



(defn .term.down.begin

  ^{:doc {:description ["Comptes escape code for moving the cursor to the beginning of the line and then `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code "($.term/down-begin 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down.begin 1))


  ([n]

   (str "\033[" n "E")))



(defn .term.left

  ^{:doc {:description ["Comptes escape code for moving the cursor `n` columns left."
                        "Defaults to one column."]
          :examples    [{:code "($.term/left 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.left 1))


  ([n]

   (str "\033[" n "D")))



(defn .term.right

  ^{:doc {:description ["Comptes escape code for moving the cursor `n` columns right."
                        "Defaults to one column."]
          :examples    [{:code "($.term/right 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.right 1))


  ([n]

   (str "\033[" n "C")))



(defn .term.up

  ^{:doc {:description ["Comptes escape code for moving the cursor `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code "($.term/up 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up 1))


  ([n]

   (str "\033[" n "A")))



(defn .term.up.begin

  ^{:doc {:description ["Comptes escape code for moving the cursor to the beginning of the line and then `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code "($.term/up-begin 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up.begin 1))


  ([n]

   (str "\033[" n "F")))


;; Screen clearing


(defn .term.clear

  ^{:doc {:description "Escape code for clearing the whole screen."}}

  []

  (.term.style "\033[H\033[2J"))


;;


(defn .term.demo

  ^{:doc {:description "Prints a string to `$.stream/*out*` producing colored output as demo."
          :examples    [{:code "($.stream/!.outln ($.term/demo))"}]
          :signature   [{:params []}]}}
  []

  (.stream.txt.outln
    (str .sys.eol
         (.term.bg.black)
         "BG black"
         (.term.reset)
         .sys.eol
         (.term.bg.blue)
         "BG blue"
         (.term.reset)
         .sys.eol
         (.term.bg.cyan)
         "BG cyan"
         (.term.reset)
         .sys.eol
         (.term.bg.green)
         "BG green"
         (.term.reset)
         .sys.eol
         (.term.bg.magenta)
         "BG magenta"
         (.term.reset)
         .sys.eol
         (.term.bg.red)
         "BG red"
         (.term.reset)
         .sys.eol
         (.term.bg.white)
         (.term.fg.black)
         "BG white"
         (.term.reset)
         .sys.eol
         (.term.bg.yellow)
         "BG yellow"
         (.term.reset)
         .sys.eol
         (.term.bg.rgb 100 200 150)
         "BG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.fg.black)
         "FG black"
         (.term.reset)
         .sys.eol
         (.term.fg.blue)
         "FG blue"
         (.term.reset)
         .sys.eol
         (.term.fg.cyan)
         "FG cyan"
         (.term.reset)
         .sys.eol
         (.term.fg.green)
         "FG green"
         (.term.reset)
         .sys.eol
         (.term.fg.magenta)
         "FG magenta"
         (.term.reset)
         .sys.eol
         (.term.fg.red)
         "FG red"
         (.term.reset)
         .sys.eol
         (.term.fg.white)
         (.term.fg.black)
         "FG white"
         (.term.reset)
         .sys.eol
         (.term.fg.yellow)
         "FG yellow"
         (.term.reset)
         .sys.eol
         (.term.fg.rgb 100 200 150)
         "FG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.bold)
         "Bold text"
         .sys.eol
         (.term.fg.blue)
         "Bold makes also colors brighter"
         (.term.reset)))
  nil)


;;;;;;;;;; Time utilities


(defn .time.advance

  ^{:doc {:description ["Returns a request for advancing `*timestamp*` (state timestamp) by `millis` milliseconds."
                        "Argument must be > 0."
                        "Great match for the standard `schedule` macro."]
          :examples    [{:code "($.time/!.advance (* 60 60 1000))"}]
          :signature   [{:params [millis]}]}}

  [millis]

  (.shell.invoke '.time.advance
                 millis))



(defn .time.iso

  []

  (.time.unix->iso (.time.unix)))



(defn .time.iso->unix

  ^{:doc {:description ["Returns a request for converting an ISO 8601 UTC date-time string into a Unix timestamp."
                        ""
                        "Result will be available under `$/*result*` during the next transaction."]
          :examples    [{:code "($.time/!.iso->unix \"2022-09-14T11:43:34.633\")"}]
          :signature   [{:params [iso-string]}]}}

  [iso-string]

  (.shell.invoke '.time.iso->unix
                 iso-string))



(defn .time.nano

  ^{:doc {:description ["Returns a request for retrieving the current value of a high-resolution timer."
                        "Result in nanoseconds will be available under `$/*result*` during the next transaction."
                        ""
                        "Guarantees:"
                        ""
                        "  - Timer is monotonic if the OS supports it"
                        "  - Resolution is at least as good as that of `$.time/!.unix`"
                        ""
                        "Useful for timing things as it is usually more reliable than `$.time/!.unix`."
                        "This timer has no particular, predictable origin. Hence the first value is meaningless."
                        "However, the difference between 2 values from the same process offers a precise interval."
                        "It follows that values from different process are not comparable."]
          :examples    [{:code "($.time/!.nano)"}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.nano))



(defn .time.sleep

  [millis]

  (.shell.invoke '.time.sleep
                 millis))



(defn .time.unix

  ^{:doc {:description ["Returns a request for retrieving the current Unix timestamp in milliseconds."
                        "This reflects the machine's clock, not `*timestamp*` (state timestamp)."
                        "Resolution depends on the OS."
                        ""
                        "Result will be available under `$/*result*` during the next transaction."
                        ""
                        "For timing things, prefer `$.time/!.nano`."]
          :examples    [{:code "($.time/!.unix)"}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.unix))



(defn .time.unix->iso

  ^{:doc {:description ["Returns a request for converting a Unix timestamp into an ISO 8601 UTC date-time string."
                        ""
                        "Result will be available under `$/*result*` during the next transaction."]
          :examples    [{:code "($.time/!.unix->iso 1663155814633)"}]
          :signature   [{:params [unix-timestamp]}]}}

  [time-unix]

  (.shell.invoke '.time.unix->iso
                 time-unix))


;;;;;;;;;; Try-catch like helpers


(defmacro .try*

  [do-good do-bad]

  `(let [[ok?
          x]  (.state.safe (fn [] ~do-good))]
     (if ok?
       x
       ~do-bad)))
          


(defmacro .try.resrc*

  [binding+ & body]

  (when-not (and (vector? binding+)
                 (zero? (mod (count binding+)
                             3)))
    (fail :ARGUMENT
          "Bindings must be in a vector consisting of triples"))
  (loop [code (cons 'do
                    body)
         i    (- (count binding+)
                 3)]
    (if (< i
           0)
      code
      (recur
        (let [sym   (get binding+
                         i)
              open  (get binding+
                         (inc i))
              close (get binding+
                         (+ i
                            2))]
          `(let [~sym ~open
                 [ok?
                  x]  (.state.safe* ~code)]
             ~(if (symbol? close)
                (list close
                      sym)
                close)
             (if ok?
               x
               (.ex.rethrow x))))
        (- i
           3)))))


;;;;;;;;;; Versions


(def .version.convex

  .version.convex)



(def .version.java

  .version.java)



(def .version.shell

  .version.shell)


;;;;;;;;;; Help


(defn ?


  ([]

   (.stream.txt.outln "")
   (?.title "Information about an account")
   (?.txt "(? address)         ->  (? #8)")
   (?.title "Information about a symbol")
   (?.txt "(? symbol)          ->  (? 'inc)")
   (?.txt "(? address symbol)  ->  (? #8 'inc)")
   (.stream.txt.outln "")
   nil)


  ([query]

   (.stream.txt.outln "")
   (cond
     ;;
     (address? query)
     (?.account query)
     ;;
     (symbol? query)
     (?.sym query)
     ;;
     (.stream.txt.outln "Ask for an address or a symbol."))
   nil)


  ([addr sym]

    (.stream.txt.outln "")
    (?.sym addr
           sym)
    nil))



(defn ?.account

  [addr]

  (if-let [-account (account addr)]
    (?.print.account (assoc -account
                            :help.addr
                            addr))
    (.stream.txt.outln (str "Account not found for address "
                            addr))))



(defn ?.color

  [s]

  (str (.term.bold)
       (.term.fg.blue)
       s
       (.term.reset)))



(defn ?.color-2

  [s]

  (str (.term.bold)
       (.term.fg.green)
       s
       (.term.reset)))



(defn ?.print.account

  [-account]

  (.stream.txt.outln "")
  (let [addr   (:help.addr -account)
        lookup (call *registry*
                     (lookup addr))]
    (.docoll (fn [[title txt]]
               (?.title title)
               (?.txt txt))
             [["Address"     addr]
              ["Name"        (:name lookup)]
              ["Description" (:description lookup)]
              ["Allowance"   (:allowance -account)]
              ["Balance"     (:balance -account)]
              ["Controller"  (:controller -account)]
              ["Key"         (when-let [key (:key -account)]
                               (str "0x"
                                    key))]])
  
    (?.title "Overview")
    (let [env   (:environment -account)
          meta- (:metadata -account)]
      (if (empty? env)
        (?.txt "Empty environment.")
        (.docoll (fn [sym-str]
                   (let [sym      (symbol sym-str)
                         meta-sym (get meta-
                                       sym)]
                     (when (and (not (get-in meta-
                                             [sym
                                              :private?]))
                                (let [first-char (first (str sym))]
                                  (and (not (= first-char
                                               \.))
                                       (not (= first-char
                                               \?)))))
                       (?.txt (?.color-2 sym))
                       (?.txt-2 (when-let [desc (:description (:doc meta-sym))]
                                  (let [desc-2 (if (str? desc)
                                                 desc
                                                 (first desc))]
                                    (if (> (count desc-2)
                                           80)
                                      (str (slice desc-2
                                                  0
                                                  77)
                                           "...")
                                    desc-2)))))))
                 (.str.sort (keys env)))))))



(defn ?.print.sym

  [sym-meta]

  (?.title "Defined in")
  (?.txt (:help.addr sym-meta))
  (let [doc          (:doc sym-meta)
        code->reason (:errors doc)
        example+     (:examples doc)
        signature+   (:signature doc)]
    (?.title "Description")
    (?.txt (:description doc))
    (when-not (empty? signature+)
      (?.title (.str.pluralize (count signature+)
                               "Signature"))
      (.docoll (fn [signature]
                 (.stream.txt.outln (str "  "
                                         (:params signature))))
               signature+))
    (when-not (empty? code->reason)
      (?.title "Throws")
      (.docoll (fn [[code reason]]
                 (?.txt (str code
                             (?.color " <- ")
                             reason)))
               code->reason))
    (when-not (empty? example+))
      (?.title (.str.pluralize (count example+)
                               "Example"))
      (.docoll (fn [example]
                 (?.txt (:code example)))
               example+)))



(defn ?.sym


  ([sym]

   (if-let [sym-meta (or (?.sym.meta *address*
                                     sym)
                         (?.sym.meta .account.core
                                     sym))]
     (?.print.sym sym-meta)
     (.stream.txt.outln "Symbol not found in current account nor in core account.")))


  ([addr sym]

   (if-let [sym-meta (?.sym.meta addr
                                 sym)]
     (?.print.sym sym-meta)
     (.stream.txt.outln (str "Symbol not found in account "
                             addr)))))



(defn ?.sym.meta

  [addr sym]

  (when-let [sym-meta (get-in (account addr)
                              [:metadata
                               sym])]
    (assoc sym-meta
           :help.addr addr
           :help.sym  sym)))



(defn ?.title

  [s]

  (.stream.txt.outln (?.color (str s
                                   ":"))))



(defn ?.txt

  [s]

  (if s
    (if (vector? s)
      (.docoll (fn [s]
                 (.stream.txt.outln (str "  "
                                         s)))
               s)
      (.stream.txt.outln (str "  "
                              s)))
    (.stream.txt.outln "  None.")))



(defn ?.txt-2

  [s]

  (.stream.txt.out "  ")
  (?.txt s))
