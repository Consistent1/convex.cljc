


(def .account.0-key

  ^{:doc {:description "Fake key for turning an actor into a user account with standard `set-key`."
          :examples    [{:code "(deploy '(do (set-key $.account/fake-key) ...))"}]}}

  0x0000000000000000000000000000000000000000000000000000000000000000)



(defn .account.control


  ([address-target]

   (.account.control nil
                     address-target))

  ([address-controller address-target]

   (.shell.invoke '.account.control
                  address-controller
                  address-target)))



(def .account.core

  $CORE$)



(defn .account.key?

  ^{:doc {:description "Returns true if `x` is a 32-byte blob that can act as a key."
          :examples    [{:code "($.account/key? $.account/fake-key)"}
                        {:code "($.account/key? 42)"}]
          :signature   [{:params [x]}]}}

  [x]

  (and (blob? x)
       (= (count x)
          32)))



(def .account.genesis

  .account.genesis)



(defn .account.switch

  [address]

  (.shell.invoke '.account.switch
                 address))




                 











(defn .bench.trx

  ^{:doc {:description ["Returns a request for measuring the mean execution time of the given transaction."
                        "Executed in a query a high number of times."
                        ""
                        "Highly experimental and subject to change, probably useful for CVM developers only."
                        "Depending on the given transaction, takes between one and several minutes to complete."
                        ""
                        "Uses the Criterium library:"
                        "  https://github.com/hugoduncan/criterium"
                        ""
                        "Report map will be available during next transaction under `$/*result*`."
                        "Values are duration estimates in nanoseconds with an overhead due to forking the CVM"
                        "context which should be in the few nanoseconds. A nil transaction might provide a base."]
          :examples    [{:code "($.time/!.bench '(+ 2 2))"}
                        {:code "($.time/!.bench (compile '(+ 2 2)))"}]
          :signature   [{:params [trx]}]}}


  [trx]

  (.shell.invoke '.bench.trx
                 trx))


















(defn .dep.fetch

  [required]

  (.shell.invoke '.dep.fetch
                  (if (list? required)
                    ['_ required]
                    required)))



(defn .dep.deploy

  [required]

  (.shell.invoke '.dep.deploy
                 required))



(defn .dep.exec

  [required]

  (let [file       (.dep.read required)
        required-2 (:deploy file)]
    (when required-2
      (reduce (fn [_ [sym addr]]
                (eval `(def ~sym
                            ~addr))
                nil)
              nil
              (.dep.deploy required-2)))
    (eval (cons 'do
                (:src file)))))



(defn .dep.read

  [required]

  (if (list? required)
    (do
      (when (empty? required)
        (fail :ARGUMENT
              "Actor path is empty"))
      (get (.shell.invoke '.dep.read
                          ['x required])
           'x))
    (.shell.invoke '.dep.read
                   required)))







(defn .dep.require.filter

  [f required]

  (let [n (count required)]
    (loop [acc []
           i   0]
      (if (< i
             n)
        (recur (let [sym  (get required
                               i)
                     path (get required
                               (inc i))]
                 (if (f sym
                        path)
                   (conj acc
                         sym
                         path)
                   acc))
               (+ i
                  2))
        acc))))
                      
           




(defn .dep.test


  ([required]

   (.dep.test required
              nil))


  ([required option+]

   (let [test            (if .*dev?*
                           .t.dev
                           .t.main)
         required-2      (if (list? required)
                           (:deploy (.dep.read required))
                           required)

         focus           (:focus option+)
         focus.test      (reduce (fn [actor-sym->test+ x]
                                   (if (and (list? x)
                                            (not (empty? x))
                                            (= (first x)
                                               'lookup))
                                     (let [actor-sym (second x)]
                                       (assoc actor-sym->test+
                                              actor-sym
                                              (conj (or (get actor-sym->test+
                                                             actor-sym)
                                                        #{})
                                                    (nth x
                                                         2))))
                                     actor-sym->test+))
                                 {}
                                 focus)
         option-2+       (assoc option+
                                :focus.test
                                focus.test)
         focus-actor+    (union (set (filter symbol?
                                             focus))
                                (set (keys focus.test)))

         required-3      (if (empty? focus-actor+)
                           required-2
                           (.dep.require.filter (fn [sym _path]
                                                  (contains-key? focus-actor+
                                                                 sym))
                                                required-2))
         skip            (:skip option+)
         skip-actor+     (set (filter symbol?
                                      skip))
         required-4      (if (empty? skip-actor+)
                           required-3
                           (.dep.require.filter (fn [sym _path]
                                                  (not (contains-key? skip-actor+
                                                                      sym)))
                                                required-3))
                         ]
     (test (.dep.deploy required-4)
           option-2+))))





(def .*dev?*

  false)



(defn .dev.set

  ^:callable?

  [enable?]

  (if (= *address*
         $CORE$)
    (def .*dev?*
         (boolean enable?))
    (call $CORE$
          (.dev.set enable?))))









(defn .db.flush

  ^{:doc {:description ["Returns a request for flushing the current Etch instance."
                        "Instances are flushed when the CVX Shell terminates but it is still a"
                        "good idea flushing once in a while explicitly to ensure everything is"
                        "persisted on disk."]
          :examples    [{:code "($.db/!.flush)"}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.flush))



(defn .db.open

  ^{:doc {:description ["Returns a request for explicitly opening the Etch instance located at the given `path`."
                        "File is created if it does not exist."]
          :examples    [{:code "($.db/!.open \"path/to/file.etch\")"}]
          :signature   [{:params [path]}]}}


  ([]

   (.db.open nil))


  ([path]

   (.shell.invoke '.db.open
                  (or path
                      (.fs.tmp "convex-shell-"
                               ".etch")))))



(defn .db.path

  ^{:doc {:description ["Returns a request for retrieving the path of the current Etch instance."
                        "Filename will be available during the next transaction under `$/*result*`."]
          :examples    [{:code "($.db/!.flush)"}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.path))



(defn .db.read
  
  ^{:doc {:description ["Returns a request for retrieving a cell from the current Etch instance by `hash`."
                        ""
                        "Result will be available during the next transaction under `$/*result*` (nil when not found)."]
          :examples    [{:code "($.db/!.read 0x1fa0dd51b167d4cca60177d13d731c461eae9cdb4ecd75e1e8f2158251968c66)"}]
          :signature   [{:params [hash]}]}}

  [hash]

  (.shell.invoke '.db.read
                 hash))



(defn .db.root.read

  ^{:doc {:description ["Returns a request for reading the root cell of the current Etch instance."
                        "The root is simply a unique place that does not require providing a hash."
                        "Any cell can be written there using `!.root.write`."
                        "Otherwise, behaves exactly like `!.read`."]
          :examples    [{:code "($.db/!.root.read)"}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.root.read))



(defn .db.root.write

  ^{:doc {:description ["Behaves exactly like `!.write` but the given `cell` will be written at the root."
                        "See `!.root.read`."]
          :examples    [{:code "($.db/!.root.write [:my 'cell 42])"}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.root.write
                 cell))



(defn .db.write

  ^{:doc {:description ["Returns a request for writing the given `cell` to the current Etch instance."
                        "The hash of that cell will be available during the next transaction under `$/*result*`."
                        ""
                        "If the hash is nil, it means the cell what not persisted."
                        "This happens only with a few basic cells for optimization reasons."
                        "Precisely, those that are so simple they are usually embedded in more complex values:"
                        "  - Addresses"
                        "  - Empty collections"
                        "  - Primitives (booleans, bytes, doubles, longs)"
                        "  - Symbolic (keywords and symbols)"]
          :examples    [{:code "($.db/!.write [:my 'cell 42])"}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.write
                 cell))





(defn .docoll

  [f coll]

  (let [n (count coll)]
    (loop [i 0]
      (if (< i
             n)
        (do
          (f (nth coll
                  i))
          (recur (inc i)))
        nil))))





(defn .ex.print

  [ex]

  (let [msg        (:message ex)
        msg-2      (when (map? msg)
                     (:message msg))
        extra-data (when msg-2
                     (dissoc msg
                             :message))
        trace      (:trace ex)
        trace-2    trace]
    (.stream.txt.outln
      (str .sys.eol
           (.term.bold)
           (.term.fg.red)
           "Exception code:"
           (.term.reset)
           .sys.eol
           "  "
           (.term.bold)
           (:code ex)
           (.term.bold)
           (.term.fg.red)
           .sys.eol
           "Executing address:"
           (.term.reset)
           .sys.eol
           "  "
           (:address ex)
           .sys.eol
           (.term.bold)
           (.term.fg.red)
           "Message:"
           (.term.reset)
           .sys.eol
           "  "
           (or msg-2
               msg)
           .sys.eol
           (.term.bold)
           (.term.fg.red)
           "Trace:"
           (.term.reset)
           (if (empty? trace-2)
             (str .sys.eol
                  "  None.")
             (apply str
                    (reduce (fn [acc entry]
                              (conj acc
                                    .sys.eol
                                    "  "
                                    entry))
                            []
                            trace-2)))
           (if (and extra-data
                    (not (empty? extra-data)))
             (str .sys.eol
                  (.term.bold)
                  (.term.fg.red)
                  "Extra data:"
                  (.term.reset)
                  .sys.eol
                  "  "
                  extra-data)
             "")))))





(defn .file.-handle

  [x path]

  (if (nil? x)
    [(.gensym "file-")
     (.fs.resolve path)]
    x))



(defn .file.exec

  ^{:doc {:description ["Like `$.file/!.read` but the read cells are executed atomically as transactions."
                        "See `$.state/!.atomic`."]
          :examples    [{:code "($.file/!.exec \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}

  [path]

  (eval (cons 'do
              (.file.read path))))



(defn .file.-read

  ^:private?

  [f-in path]

  (let [handle (.file.stream.in path)
        [ok?
         x]    (.state.safe (fn []
                              (f-in handle)))]
    (.stream.close handle)
    (if ok?
      x
      (.rethrow x))))



(defn .file.read

  ^{:doc {:description ["Returns a request for reading the Convex Lisp file located under `path` in one go."
                        "List of read cells is available during next transaction under `$/*result*`."]
          :examples    [{:code "($.file/!.read \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}

  ;; Stream is closed automatically in the Clojure code.

  [path]

  (.file.-read .stream.in+
               path))



(defn .file.txt.read

  [path]

  (.file.-read .stream.txt.in
               path))



(defn .file.stream.in

  ^{:doc {:description ["Returns a request for opening an input stream for the file located under `path`."
                        ""
                        "Handle for that stream will available during the next transaction under `$/*result*`."
                        "See the `$.stream` library."
                        ""
                        "Any cell can be provided as a handle for identifying the stream."
                        "If not provided, one will be generated."
                        ""
                        "See the `$.stream` library."]
          :examples    [{:code "($.file/!.stream.in \"./my/file.cvx\")"}
                        {:code "($.file/!.stream.in :my-handle \"./my/file.cvx\")"}]
          :signature   [{:params [path]}
                        {:params [handle path]}]}}


  [path]

  (.shell.invoke '.file.stream.in
                 (.resrc.next)
                 (.fs.resolve path)
                 path))



(defn .file.stream.out

  ^{:doc {:description ["Returns a request for opening an output stream for the file located under `path`."
                        ""
                        "Handle will be available during the next transaction under `$/*result*`."
                        "See the `$.stream` library."
                        ""
                        "Any cell can be provided as a handle for identifying the stream."
                        "If not provided, one will be generated."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :append?"
                        "    Writes will be appended to the end if true, otherwise file will be overwritten if it exists."
                        "    False by default."]
          :examples    [{:code "($.file/!.stream.out \"./my/file.cvx\")"}
                        {:code "($.file/!.stream.out :my-handle \"./my/file.cvx\")"}
                        {:code "($.file/!.stream.out :my-handle \"./my/file.cvx\" {:append? true})"}]
          :signature   [{:params [path]}
                        {:params [handle path]}
                        {:params [handle path option+]}]}}


  ([path]

   (.file.stream.out path
                     nil))


  ([path option+]

   (.shell.invoke '.file.stream.out
                  (.resrc.next)
                  path
                  (:append? option+))))



(defn .file.-write

  ^:private?

  [f-out path cell option+]

  (let [handle (.file.stream.out path
                                  option+)
        [ok?
         x]    (.state.safe (fn []
                              (f-out handle
                                     cell)))]
    (.stream.close handle)
    (if ok?
      x
      (.rethrow x))))



(defn .file.write

  ^{:doc {:description ["Returns a request for writing `cell` to the file located under `path`, in one go."
                        "See `$.file/!.stream.out` for options."]
          :examples    [{:code "($.file/!.write \"./my/file.cvx\") {:foo :bar})"}
                        {:code "($.file/!.write \"./my/file.cvx\") {:foo :bar} {:append? true})"}]
          :signature   [{:params [path cell]}
                        {:params [path cell option+]}]}}


  ([path cell]

   (.file.write path
                cell
                nil))


  ([path cell option+]

   (.file.-write .stream.outln
                 path
                 cell
                 option+)))



(defn .file.txt.write


  ([path cell]

   (.file.txt.write path
                    cell
                    nil))


  ([path cell option+]

   (.file.-write .stream.txt.outln
                 path
                 cell
                 option+)))




(defn .fs.copy

  ^{:doc {:description ["Returns a requrest for copying the file at `path-source` to `path-destination`."
                        "If `path-destination` is a directory, `path-source` will be copied inside it."
                        "Behaves like Unix's `cp`."]
          :examples    [{:code "($.file/!.copy \"some_dir/foo.txt\" \"another_dir\")"}]
          :signature   [{:params [path-source path-destination]}]}}

  [path-source path-destination]

  (.shell.invoke '.fs.copy
                 path-source
                 path-destination))



(defn .fs.delete

  ^{:doc {:description "Returns a request for deleting the file or the empty folder at the given `path`."
          :examples    [{:code "($.file/!.delete \"some-file.cvx\")"}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.delete
                 path))



(defn .fs.exists?

  ^{:doc {:description ["Returns a request for testing if a file exists."
                        "Boolean result will be available during the next transaction under `$/*result*`."]
          :examples    [{:code "($.file/!.exists? \"some_dir/some_file.txt\")"}]
          :signatures  [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.exists?
                 path))



(defn .fs.resolve

  [path]

  (.shell.invoke '.fs.resolve
                 path))



(defn .fs.size

  [path]

  (.shell.invoke '.fs.size
                 path))



(defn .fs.tmp

  ^{:doc {:description ["Returns a request for creating a temporary file."
                        "`prefix` and `suffix` are both optional."]
          :examples    [{:code "($.file/!.tmp)"}
                        {:code "($.file/!.tmp \".cvx\")"}
                        {:code "($.file/!.tmp \"some-project\" \".cvx\")"}]
          :signature   [{:params []}
                        {:params [suffix]}
                        {:params [prefix suffix]}]}}


  ([]

   (.fs.tmp nil
            nil))


  ([suffix]

   (.fs.tmp nil
            suffix))


  ([prefix suffix]

   (.shell.invoke '.fs.tmp
                  (or prefix
                      "")
                  (or suffix
                      ""))))



(defn .fs.tmp.dir

  ^{:doc {:description ["Returns a request for creating a temporary directory."
                        "`prefix` is optional."]
          :examples    [{:code "($.file/!.tmp-dir)"}
                        {:code "($.file/!.tmp-dir \"some-prefix\")"}]
          :signature   [{:params []}
                        {:params [prefix]}]}}


  ([]

   (.fs.tmp.dir nil))


  ([prefix]

   (.shell.invoke '.fs.tmp.dir
                  (or prefix
                      ""))))






(def .*gensym*

  ^{:private? true}

  0)



(defn .gensym

  ^{:callable? true
    :doc       {:description ["Returns a symbol guaranteed to be unique relative to other symbols generated"
                              "with this function in the context of a single process."
                              ""
                              "A prefix string may be provided (default to \"G_\")."
                              ""
                              "Useful for metaprogramming."]
                :examples    [{:code "($.gensym)"}
                              {:code "($.gensym \"some-prefix-b\")"}]
                :signature   [{:params []}
                              {:params [prefix]}]}}

  
  ([]

   (.gensym nil))


  ([prefix]

   (if (= *address*
          $CORE$)
     (do
       (let [id .*gensym*]
         (def .*gensym*
              (inc id))
         (symbol (str (or prefix
                          "G_")
                      id))))
     (call $CORE$
           (.gensym prefix)))))







(defn .juice.get

  []

  (.shell.invoke '.juice.get))



(defn .juice.refill

  []

  (.juice.set 9223372036854775807))



(defn .juice.set

  [n-unit]

  (.shell.invoke '.juice.set
                 n-unit))



(defn .juice.track

  [trx]

  (conj (.shell.invoke '.juice.track
                       trx)
        (second (.shell.invoke '.juice.track
                               (compile trx)))
        (second (.shell.invoke '.juice.track
                               (expand trx)))))






(defn .log.clear

  ^{:doc {:description "Returns a request for clearing the state of the CVM log."
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.log.clear))



(defn .log.get

  ^{:doc {:description ["Returns a request for retrieving the current state of the CVM log."
                        "Result is available during next transaction under `$/*result*`."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.log.get))






(def .project.*dir*

  "./")



(defn .project.dir.set

  ^{:callable? true}

  [dir]

  (if (= *address*
         $CORE$)
    (do
      (when-not (.fs.exists? dir)
        (fail :FS
              "Given project directory does not exist"))
      (def .project.*dir*
           dir))
    (call $CORE$
          (.project.dir.set dir))))





(defn .read+

  [string]

  (.shell.invoke '.read+
                 string))







(defn .repl.eval

  [state]

  (assoc state
         :result
         (eval (concat `(let [$ (quote ~(:result state))])
               (:form+ state)))))







  


(defn .repl.on.ex

  ^{:doc {:description ["Turns given `exception` into a nice human-readable string." 
                        "Used by the REPL when handling exceptions thrown during evaluation."]
          :signature   [{:params [exception]}]}}

  [state]

  (let [ex    (:result state)
        trace (:trace ex)
        ex-2  (assoc ex
                     :trace
                     (slice trace
                            0
                            ;; Removing lines relating to the REPL, not interesting.
                            (- (count trace)
                               3)))]
    (.ex.print ex-2)
    (.stream.txt.outln "")
    (assoc state
           :result
           ex-2)))



(defn .repl.on.ex.reader

  [state message]

  (.stream.txt.outln (str .sys.eol
                          (.term.fg.red)
                          (.term.bold)
                          "Input cannot be parsed as Convex Lisp:"
                          (.term.reset)
                          .sys.eol
                          "  "
                          message
                          .sys.eol))
  state)



(defn .repl.on.prompt

  [state]

  (let [out (:stream.out state)]
    (.stream.txt.out out
                     (str (.term.bold)
                          (.term.fg.blue)
                          "> "
                          (.term.reset)))
    (.stream.flush out))
  state)



(defn .repl.on.result

  [state]

  (.stream.txt.out .sys.eol)
  (.stream.out (:result state))
  (.stream.txt.out .sys.eol)
  (.stream.txt.out .sys.eol)
  (.stream.flush)
  state)



(defn .repl.stop?

  [state]

  (contains-key? #{:exit
                   :q
                   :quit
                   :stop}
                 (first (:form+ state))))



(defn .repl


  ([]

   (.repl nil))


  ([option+]

   (loop [state (merge {:eval         .repl.eval
                        :on.ex        .repl.on.ex
                        :on.ex.reader .repl.on.ex.reader
                        :on.prompt    .repl.on.prompt
                        :on.result    .repl.on.result
                        :stop?        .repl.stop?
                        :stream.in    .stream.*in*
                        :stream.out   .stream.*out*}
                       option+)]
     ((:on.prompt state) state)
     (let [[read?
            x]    (.state.safe (fn []
                                 (.stream.line (:stream.in state))))]
       (if read?
         ;;
         ;; Successful read.
         ;;
         (let [form+   x
               state-2 (assoc state
                              :form+
                              form+)]
           (cond
             ;;
             (nil? form+)
             state-2
             ;;
             (empty? form+)
             (recur state-2)
             ;;
             ((:stop? state-2) state-2)
             state-2
             ;;
             (let [[ok?
                    x]     (.state.safe (fn []
                                          ((:eval state-2) (assoc state-2
                                                                  :form+
                                                                  form+))))
                   state-3 (if ok?
                             (let [state-3 x]
                               ((:on.result state-3) state-3))
                             (let [ex x]
                               ((:on.ex state) (assoc state-2
                                                      :result
                                                      ex))))]
               (if (contains-key? state-3
                                  :result)
                 (recur state-3)
                 state-3))))
         ;;
         ;; Reading input failed.
         ;;
         (let [ex x]
           (if (= (:code ex)
                  :READER)
             (let [state-2 ((:on.ex.reader state) state
                                                  (:message ex))]
               (if (contains-key? state-2
                                  :result)
                 (recur state-2)
                 state-2))
             (.rethrow ex))))))))





  






(def .resrc.*count*

  0)



(defn .resrc.next

  ^{:callable? true}

  []

  (if (= *address*
         $CORE$)
    (def .resrc.*count*
         (inc .resrc.*count*))
    (call $CORE$
          (.resrc.next))))





(defn .rethrow

  [exception]

  (.shell.invoke '.rethrow
                 exception))





(defn .shell.inspect

  []

  (.shell.invoke '.shell.inspect))



(defn .shell.limit

  [feature-set]

  (.shell.invoke '.shell.limit
                 feature-set))



(def .shell.invoke

  nil)



(defn .shell.main

  [src]

  (let [[ok?
         x]  (.state.safe (fn []
                            (.read+ src)))]
    (cond
      ;;
      ok?
      (let [form+ x]
        (if (empty? form+)
          (do
            (.dev.set true)
            (.stream.txt.outln
              (str (.term.fg.blue)
                   (.term.bold)
                   "Convex Shell (REPL mode)"
                   (.term.reset)
                   .sys.eol
                   "Enter transactions and build a new world."
                   .sys.eol
                   .sys.eol
                   "Powered by Protosens SRL and collaborators."
                   .sys.eol
                   "For help, type: "
                   (.term.bold)
                   "(?)"
                   (.term.reset)
                   .sys.eol))
            (.repl)
            nil)
          (eval (cons 'do
                      form+))))
      ;;
      (= (:code x)
         :READER)
      (do
        (.stream.txt.outln
           (str .sys.eol
                (.term.fg.red)
                (.term.bold)
                "Input cannot be parsed as Convex Lisp:"
                (.term.reset)
                .sys.eol
                "  "
                (:message x)
                .sys.eol))
        (.sys.exit 4))
      ;;
      (fail :SHELL.FATAL
            {:message "Initialization problem while reading input"}))))



(def .shell.root

  "~/.convex-shell")





(defn .state.genesis


  ([]

   (.state.genesis nil))


  ([key+]

   (.shell.invoke '.state.genesis
                  (or key+
                      [.account.0-key]))))



(defn .state.safe

  [f]

  (.shell.invoke '.state.safe
                 f))



(defmacro .state.safe*

  [& form+]

  `(~$CORE$/.state.safe (fn []
                          ~(cons 'do
                                 form+))))
 


(defn .state.switch


  ([state]

   (.state.switch nil
                  state))


  ([address state]

   (.shell.invoke '.state.switch
                  (or address
                      *address*)
                  state)))



(defn .state.tmp

  [f]

  (.shell.invoke '.state.tmp
                 f))



(defmacro .state.tmp*

  [& form+]

  `(~$CORE$/.state.tmp (fn []
                         ~(cons 'do
                                form+))))
 




(defn .str.stream.in

  [string]

  (.shell.invoke '.str.stream.in
                 (.resrc.next)
                 string))



(defn .str.stream.out

  []

  (.shell.invoke '.str.stream.out
                 (.resrc.next)))



(defn .str.stream.unwrap

  [handle]

  (.shell.invoke '.str.stream.unwrap
                 handle))





;;;;;;;;;; STDIO handles (defined in Clojure)


(def .stream.stderr

  ^{:doc {:description "Stream for STDERR"}}

  .stream.stderr)



(def .stream.stdin

  ^{:doc {:description "Stream for STDIN."}}

  .stream.stdin)



(def .stream.stdout

  ^{:doc {:description "Stream for STDOUT"}}

  .stream.stdout)


;;;;;;;;;; Default handles


(def .stream.*err*

  ^{:doc {:description ["Default error stream, originally set to `stderr`."
                        "See `set.err`."]}}

  .stream.stderr)



(def .stream.*in*

  ^{:doc {:description ["Default input stream, originally set to `stdin`."
                        "See `set.in`."]}}

  .stream.stdin)



(def .stream.*out*

  ^{:doc {:description ["Default output stream, originally set to `stdout`."
                        "See `set.out`."]}}

  .stream.stdout)


;;;;;;;;;; Setting dynamic values


(defn .stream.set.err

  ^{:callable? true
    :doc       {:description "Sets `*err*` to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*err*
         handle)
    (call $CORE$
          (.stream.set.err handle))))



(defn .stream.set.in

  ^{:callable? true
    :doc       {:description "Sets `*in*` to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*in*
         handle)
    (call $CORE$
          (.stream.set.in handle))))



(defn .stream.set.out

  ^{:callable? true
    :doc       {:description "Sets `*out* to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*out*
         handle)
    (call $CORE$
          (.stream.set.out handle))))


;;;;;;;;;; Requests for handling streams


(defn .stream.close

  ^{:doc {:description ["Returns a request for closing the given `handle`."
                        "`$.stream/stderr` cannot be closed."]
          :examples    [{:code "($.stream/!.close $.stream/stdout)"}]
          :signature   [{:params [handle]}]}}

  [handle]

  ;(assert (not (= handle
  ;                stderr)))
  (.shell.invoke '.stream.close
                 handle))



(defn .stream.err

  ^{:doc {:description "Uses `$.stream/!.out` ont `*err*` for printing `x` to the default error stream."
          :examples    [{:code "($.stream/!.err {:some :error})"}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.out .stream.*err*
               x))



(defn .stream.errln

  ^{:doc {:description "Uses `$.stream/!.outln` ont `*err*` for printing `x` to the default error stream."
          :examples    [{:code "($.stream/!.errln {:some :error})"}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.outln .stream.*err*
                 x))



(defn .stream.flush

  ^{:doc {:description ["Returns a request for flushing the given output `handle` and ensuring all outputs are processed."
                        "Flushes `*out*` by default."]
          :examples    [{:code "($.stream/!.flush)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.flush .stream.*out*))


  ([handle]

   (.shell.invoke '.stream.flush
                  handle)))



(defn .stream.in+

  ^{:doc {:description ["Returns a request for reading the given input `handle`."
                        "Reads from `*in*` by default."
                        "Whole input is read and `handle` is automatically closed."
                        "List of read cells becomes available during next transaction under `$/*result*`."]
          :examples    [{:code "($.stream/!.in+ $.stream/stdin)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.in+ .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.in+
                  handle)))



(defn .stream.line

  ^{:doc {:description ["Returns a request for reading a line from the given input `handle`."
                        "Reads from `*in*` by default."
                        "Stops when a new line is encountered."
                        "List of read cells becomes available during next the transaction under `$/*result*`."
                        "Result is `nil` when the end of the stream is reached. The stream is then closed"
                        "automatically."]
          :examples    [{:code "($.stream/!.line)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.line .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.line
                  handle)))



(defn .stream.open?

  ^{:doc {:description ["Returns a request for inspecting if the given `handle` is open."
                        "Boolean response will be available during the next transaction under `$/*result*`."]
          :examples    [{:code "($.stream/!.open? 42)"}]
          :signature   [{:params [handle]}]}}

  [handle]

  (.shell.invoke '.stream.open?
                 handle))



(defn .stream.out

  ^{:doc {:description ["Returns a request for writing `x` to the given output `handle`."
                        "Writes to `*out*` by default."]
          :examples    [{:code "($.stream/!.out :foo)"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.out .stream.*out*
                x))


  ([handle x]

   (.shell.invoke '.stream.out
                  handle
                  x)))



(defn .stream.outln

  ^{:doc {:description "Likes `$.stream/!.out` but also outputs a new line and flushes the `handle`."
          :examples    [{:code "($.stream/!.outln :foo)"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.outln .stream.*out*
                  x))


  ([handle x]
   
   (.shell.invoke '.stream.outln
                  handle
                  x)))



(defn .stream.txt.in

  ^{:doc {:description ["Returns a request for reading the rest of the given input `handle` as text."
                        "Reads from `*in*` by default."
                        "String will be available during the next transaction under `$/*result*`."
                        "Stream is closed automatically."]
          :examples    [{:code "($.stream/!.txt.in 42)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.in .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.txt.in
                  handle)))



(defn .stream.txt.line

  ^{:doc {:description ["Returns a request for reading a line from the given input `handle` as text."
                        "Reads from `*in*` by default."
                        "String will be available during the next transaction under `$/*result*`."
                        "Result is `nil` when the end of the stream is reached. The stream is then closed"
                        "automatically."]
          :examples    [{:code "($.stream/!.txt.line)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.line .stream.*in*))


  ([handle]

   (.shell.invoke '.stream.txt.line
                  handle)))



(defn .stream.txt.out

  ^{:doc {:description ["Like `$.stream/!.out` but if `cell` is a string, it will not be double-quoted."
                        "Hence, the output might not be readable as Convex Lisp."]
          :examples    [{:code "($.stream/!.txt.out \"This is some text\")"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.out .stream.*out*
                    x))


  ([handle x]

   (.shell.invoke '.stream.txt.out
                  handle
                  x)))



(defn .stream.txt.outln

  ^{:doc {:description ["Like `$.stream/!.outln` but if `cell` is a string, it will not be double-quoted."
                        "Hence, the output might not be readable as Convex Lisp."]
          :examples    [{:code "($.stream/!.txt.outln \"This is some text\")"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.outln .stream.*out*
                      x))


  ([handle x]

   (.shell.invoke '.stream.txt.outln
                  handle
                  x)))






(defn .sys.arch

  []

  (.shell.invoke '.sys.arch))



(defn .sys.cwd

  []

  (.shell.invoke '.sys.cwd))



(defn .sys.env

  []

  (.shell.invoke '.sys.env))



(defn .sys.env.var

  [var]

  (.shell.invoke '.sys.env.var
                 var))



(def .sys.eol

  ;; Set from Clojure.

  .sys.eol)



(defn .sys.exit

  [code]

  (.shell.invoke '.sys.exit
                 code))



(defn .sys.home

  []

  (.shell.invoke '.sys.home))



(defn .sys.os

  []

  (.shell.invoke '.sys.os))
















(def .t.*assert+*

  [])



(defn .t.assert.add

  ^:callable?

  [assertion]

  (if (= *address*
         ~*address*)
    (def .t.*assert+*
         (conj .t.*assert+*
               assertion))
    (call ~*address*
          (.t.assert.add assertion))))



(defn .t.assert.failed+

  [assertion+]

  (reduce (fn [acc assertion]
            (let [[ok?
                   x]         (:result assertion)
                  assertion-2 (if ok?
                                (when-not (= x
                                             true)
                                  {:fail   x
                                   :status :fail})
                                {:fail   x
                                 :status :exception})]
              (if assertion-2
                (conj acc
                      (assoc assertion-2
                             :form    (:form assertion)
                             :message (:message assertion)))
                acc)))
          []
          assertion+))



(defmacro .t.is


  ([form]

   `(.t.is ~form
           nil))


  ([form message]

   `(.t.assert.add {:form    (quote ~form)
                    :message ~message
                    :result  (.state.safe* ~form)})))



(defmacro .t.def

  [name & assertion+]

  (let [[name-2
         meta-]      (if (syntax? name)
                       [(unsyntax name)
                        (meta name)]
                       [name
                        nil])
        first-assert (when-not (empty? assertion+)
                       (first assertion+))
        meta-2       (if (syntax? first-assert)
                       (merge meta-
                              (meta first-assert))
                       meta-)]
    `(defn ~(syntax name-2
                    (assoc meta-2
                           :test?
                           true))

       []

       ~(cons 'do
               assertion+))))



(defn .t.dev


  ([required]

   (.t.dev required
           nil))


  ([required state]

   (= (:status (.t.run required
                       state))
      :pass)))



(defn .t.find

  [state actor-sym actor-address]

  (let [account (account actor-address)
        meta    (:metadata account)
        env     (:environment account)
        focus   (get-in state
                        [:focus.test
                          actor-sym])]
    (reduce (fn [acc [sym x]]
              (if (and (fn? x)
                       (get-in meta
                               [sym
                                :test?])
                       (or (not focus)
                           (contains-key? focus
                                          sym)))
                (conj acc
                      [sym
                       x])
                acc))
            []
            env)))



(defn .t.main


  ([required]

   (.t.main required
            nil))


  ([required state]

   (.sys.exit (if (.t.dev required
                          state)
                0
                128))))



(defn .t.on.run.begin

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (str .sys.eol
                          "=========="
                          .sys.eol
                          .sys.eol
                          (.term.bold)
                          "["
                          (.term.reset)))
    (.stream.flush s))
  state)



(defn .t.on.run.end

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       (str (.term.bold)
                            "]"
                            (.term.reset)
                            .sys.eol
                            .sys.eol
                            "=========="
                            .sys.eol))
    (.docoll (fn [test]
               (if-let [f (get {:empty     .t.on.test.empty
                                :exception .t.on.test.ex
                                :fail      .t.on.test.fail}
                               (:status test))]
                 (do
                   (f test)
                   (.stream.txt.outln s
                                      "")
                   (.stream.txt.outln s
                                      "-----")
                   (.stream.txt.outln s
                                      ""))
                 nil))
             (:run state))
    (let [status (:status state)]
      (.stream.txt.outln (str (.term.bold)
                              (cond
                                (= status
                                   :empty)
                                (str (.term.fg.red)
                                     "NO TESTS FOUND")
                                ;;
                                (= status
                                   :fail)
                                (str (.term.fg.red)
                                     "FAIL")
                                ;;
                                (= status
                                   :pass)
                                (str (.term.fg.green)
                                     "OK"))
                              (.term.bold)
                              .sys.eol)))
    (let [empty-actor+ (:empty-actor+ state)
          n-actor      (:n-actor state)
          n-test       (:n-test state)
          n-test-fail  (:n-test-fail state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (.term.fg.cyan)
                              n-test
                              " test"
                              (if (> n-test
                                     1)
                                "s"
                                "")
                              (.term.reset)
                              " run over "
                              (.term.bold)
                              (.term.fg.cyan)
                              n-actor
                              " actor"
                              (if (> n-actor
                                     1)
                                "s"
                               "")
                              (.term.reset)
                              ", "
                              (.term.bold)
                              (if (zero? n-test-fail)
                                (.term.fg.green)
                                (.term.fg.red))
                              n-test-fail
                              " failed"
                              (.term.reset)))
      (when-not (empty? empty-actor+)
        (.stream.txt.outln (str .sys.eol
                                .sys.eol
                                (.term.bold)
                                (.term.fg.red)
                                "Actors without tests:"
                                (.term.reset)
                                .sys.eol))
        (.docoll (fn [sym-actor]
                   (.stream.txt.outln (str "  "
                                           sym-actor)))
                 empty-actor+))))
  state)



(defn .t.on.test.empty

  [test]

  (.t.print.test.name test)
  (.stream.txt.outln "No assertions."))



(defn .t.on.test.ex

  [test]

  (.t.print.test.name test)
  (.stream.txt.outln "Exception thrown unexpectedly")
  (.ex.print (:exception test)))



(defn .t.on.test.fail

  [test]

  (.docoll (fn [failed]
             (.t.print.test.name test)
             (when-let [message (:message failed)]
               (.stream.txt.outln (str message
                                       .sys.eol)))
             (.stream.txt.outln (str (.term.bold)
                                     (.term.fg.cyan)
                                     "Form:   "
                                     (.term.reset)
                                     (:form failed)))
             (let [status (:status failed)]
               (cond
                 ;;
                 (= status
                    :fail)
                 (.stream.txt.outln (str .sys.eol
                                         (.term.bold)
                                         (.term.fg.cyan)
                                         "Result: "
                                         (.term.reset)
                                         (:fail failed)))
                 ;;
                 (= status
                    :exception)
                 (.ex.print (:fail failed)))))
           (:failed+ test)))



(defn .t.on.test.result

  [state result]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (if (= (:status result)
                            :pass)
                       (str (.term.bold)
                            (.term.fg.green)
                            "."
                            (.term.reset))
                       (str (.term.bold)
                            (.term.fg.red)
                            "X"
                            (.term.reset))))
    (.stream.flush s))
  state)



(defn .t.print.test.name

  [test]

  (.stream.txt.outln (str (.term.bold)
                          (:name test)
                          (.term.reset)
                          .sys.eol)))



(defn .t.run

  [actor-sym->addr state]

  (.state.tmp
    (fn []
      (let [state          (merge {:on.run.begin   .t.on.run.begin
                                   :on.run.end     .t.on.run.end
                                   :on.test.result .t.on.test.result
                                   :stream.out     .stream.stdout}
                                  state)
            on.run.begin   (:on.run.begin state)
            on.run.end     (:on.run.end state)
            state          (if on.run.begin
                             (on.run.begin state)
                             state)
            state-2        (reduce (fn [state-2 [actor-sym actor-address]]
                                     (.t.run.actor state-2
                                                   actor-sym
                                                   actor-address))
                                   (assoc state
                                          :empty-actor+ []
                                          :n-actor      0
                                          :n-test       0
                                          :n-test-fail  0)
                                   actor-sym->addr)
           state-3         (.t.run.finalize state-2)]
       (if on.run.end
         (on.run.end state-3)
         state-3)))))



(defn .t.run.actor

  [state actor-sym actor-address]

  (let [found (.t.find state
                       actor-sym
                       actor-address)]
    (if (empty? found)
      (assoc state
             :empty-actor+
             (conj (:empty-actor+ state)
                   actor-sym))
      (reduce (fn [state-2 [test-sym test-f]]
                (.t.run.test state-2
                             actor-sym
                             test-sym
                             test-f))
              (assoc state
                     :n-actor
                     (inc (:n-actor state)))
              found))))



(defn .t.run.finalize

  [state]

  (assoc state
         :status
         (cond
           ;;
           (zero? (:n-test state))
           :empty
           ;;
           (zero? (:n-test-fail state))
           :pass
           ;;
           :else
           :fail)))



(defn .t.run.test

  [state actor-sym test-sym test-f]

  (let [on.test.result (:on.test.result state)
        [ok?
         x]            (.state.tmp (fn []
                                     (test-f)
                                     .t.*assert+*))
        test-result    (if ok?
                         (.t.run.test.finalize x)
                         {:exception x
                          :status    :exception})
        test-result-2  (assoc test-result
                              :name
                              (str actor-sym
                                   "/"
                                   test-sym))
        state-2        (assoc state
                              :run
                              (conj (:run state)
                                    test-result-2))
        state-3        (assoc state-2
                              :n-test
                              (inc (:n-test state-2)))
        state-4        (if on.test.result
                         (on.test.result state-3
                                         test-result-2)
                         state-3)]
    (if (= (:status test-result-2)
           :pass)
      state-4
      (assoc state-4
             :n-test-fail
             (inc (:n-test-fail state-4))))))



(defn .t.run.test.finalize

  ^:private

  [assertion+]

  (let [n (count assertion+)]
    (if (zero? n)
      {:status :empty}
      (let [failed+ (.t.assert.failed+ assertion+)
            result  {:n n}]
        (if (empty? failed+)
          (assoc result
                 :status
                 :pass)
          (assoc result
                 :failed+ failed+
                 :status  :fail))))))



















(def .term.style?

  ^{:doc {:description ["True if text styling with functions from this account is enabled."
                        "False means that functions returning a color will instead return an empty string."]}}

  true)



(defn .term.style

 ^{:private? true}

 [x]

 (if .term.style?
   x
   ""))



(defn .term.style.enable?

  ^{:callable? true}

  [enable?]

  (if (= *address*
         ~*address*)
    (def .term.style?
         (boolean enable?))
    (call ~*address*
          (.term.style.enable? enable?))))


;;;;;;;;;; Background colors


(defn .term.bg.black

  ^{:doc {:description "Background color black."}}

  []

  (.term.style "\033[40m"))



(defn .term.bg.blue

  ^{:doc {:description "Background color blue."}}

  []

  (.term.style "\033[44m"))



(defn .term.bg.cyan

  ^{:doc {:description "Background color cyan."}}

  []

  (.term.style "\033[46m"))



(defn .term.bg.green

  ^{:doc {:description "Background color green."}}

  []

  (.term.style "\033[42m"))



(defn .term.bg.magenta

  ^{:doc {:description "Background color magenta."}}

  []

  (.term.style "\033[45m"))


(defn .term.bg.red

  ^{:doc {:description "Background color red."}}

  []

  (.term.style "\033[41m"))



(defn .term.bg.white

  ^{:doc {:description "Background color white."}}

  []

  (.term.style "\033[47m"))



(defn .term.bg.yellow

  ^{:doc {:description "Background color yellow."}}

  []

  (.term.style "\033[43m"))


;;


(defn .term.bg.rgb

  ^{:doc {:description "Computes RGB color escape code for background color."
          :examples    [{:code "($.term/bg.rgb 156 120 201)"}]
          :signature   [{:params [r g b]}]}}

  [r g b]

  (if .term.style?
    (str "\033[48;2;" r ";" g ";" b "m")
    ""))


;;;;;;;;;; Foreground colors


(defn .term.fg.black

  ^{:doc {:description "Foreground color black."}}

  []

  (.term.style "\033[30m"))



(defn .term.fg.blue

  ^{:doc {:description "Foreground color blue."}}

  []

  (.term.style "\033[34m"))



(defn .term.fg.cyan

  ^{:doc {:description "Foreground color cyan."}}

  []

  (.term.style "\033[36m"))



(defn .term.fg.green

  ^{:doc {:description "Foreground color green."}}

  []

  (.term.style "\033[32m"))



(defn .term.fg.magenta

  ^{:doc {:description "Foreground color magenta."}}

  []

  (.term.style "\033[35m"))



(defn .term.fg.white

  ^{:doc {:description "Foreground color white."}}

  []

  (.term.style "\033[37m"))



(defn .term.fg.red

  ^{:doc {:description "Foreground color red."}}

  []

  (.term.style "\033[31m"))



(defn .term.fg.yellow

  ^{:doc {:description "Foreground color yellow."}}

  []

  (.term.style "\033[33m"))


;;


(defn .term.fg.rgb

  ^{:doc {:description "Computes RGB color escape code for foreground color."
          :examples    [{:code "($.term/fg.rgb 156 120 201)"}]
          :signature   [{:params [r g b]}]}}


  [r g b]

  (if .term.style?
    (str "\033[38;2;" r ";" g ";" b "m")
    ""))


;;;;;;;;;; Effects


(defn .term.bold

  ^{:doc {:description "Bold effect."}}

  []

  (.term.style "\033[1m"))



(defn .term.reset

  ^{:doc {:description "Resets all colors and effects."}}

  []

  (.term.style "\033[0m"))



(defn .term.reversed

  ^{:doc {:description "Reverses background and foreground colors."}}

  []

  (.term.style "\033[7m"))



(defn .term.underline

  ^{:doc {:description "Underlines text."}}

  []

  (.term.style "\033[4m"))


;;;;;;;;;; Moving


(defn .term.col

  ^{:doc {:description "Moves to column `n`."
          :examples    [{:code "($.term/col 42)"}]
          :signature   [{:params [n]}]}}

  [n]

  (str "\033[" n "G"))



(def .term.cursor.save

  ^{:doc {:description ["Escape code for saving current cursor position."
                        "See `cursor.restore`."]}}

  "\033[s")



(def .term.cursor.restore

  ^{:doc {:description ["Escape code for restoring last saved cursor position."
                        "See `cursor.save`."]}}

  "\033[u")



(defn .term.down

  ^{:doc {:description ["Comptes escape code for moving the cursor `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code "($.term/down 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down 1))


  ([n]

   (str "\033[" n "B")))



(defn .term.down.begin

  ^{:doc {:description ["Comptes escape code for moving the cursor to the beginning of the line and then `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code "($.term/down-begin 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down.begin 1))


  ([n]

   (str "\033[" n "E")))



(defn .term.left

  ^{:doc {:description ["Comptes escape code for moving the cursor `n` columns left."
                        "Defaults to one column."]
          :examples    [{:code "($.term/left 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.left 1))


  ([n]

   (str "\033[" n "D")))



(defn .term.right

  ^{:doc {:description ["Comptes escape code for moving the cursor `n` columns right."
                        "Defaults to one column."]
          :examples    [{:code "($.term/right 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.right 1))


  ([n]

   (str "\033[" n "C")))



(defn .term.up

  ^{:doc {:description ["Comptes escape code for moving the cursor `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code "($.term/up 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up 1))


  ([n]

   (str "\033[" n "A")))



(defn .term.up.begin

  ^{:doc {:description ["Comptes escape code for moving the cursor to the beginning of the line and then `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code "($.term/up-begin 4)"}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up.begin 1))


  ([n]

   (str "\033[" n "F")))


;;;;;;;;;; Clearing


(defn .term.clear

  ^{:doc {:description "Escape code for clearing the whole screen."}}

  []

  (.term.style "\033[H\033[2J"))


;;;;;;;;;;


(defn .term.demo

  ^{:doc {:description "Prints a string to `$.stream/*out*` producing colored output as demo."
          :examples    [{:code "($.stream/!.outln ($.term/demo))"}]
          :signature   [{:params []}]}}
  []

  (.stream.txt.outln
    (str .sys.eol
         (.term.bg.black)
         "BG black"
         (.term.reset)
         .sys.eol
         (.term.bg.blue)
         "BG blue"
         (.term.reset)
         .sys.eol
         (.term.bg.cyan)
         "BG cyan"
         (.term.reset)
         .sys.eol
         (.term.bg.green)
         "BG green"
         (.term.reset)
         .sys.eol
         (.term.bg.magenta)
         "BG magenta"
         (.term.reset)
         .sys.eol
         (.term.bg.red)
         "BG red"
         (.term.reset)
         .sys.eol
         (.term.bg.white)
         (.term.fg.black)
         "BG white"
         (.term.reset)
         .sys.eol
         (.term.bg.yellow)
         "BG yellow"
         (.term.reset)
         .sys.eol
         (.term.bg.rgb 100 200 150)
         "BG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.fg.black)
         "FG black"
         (.term.reset)
         .sys.eol
         (.term.fg.blue)
         "FG blue"
         (.term.reset)
         .sys.eol
         (.term.fg.cyan)
         "FG cyan"
         (.term.reset)
         .sys.eol
         (.term.fg.green)
         "FG green"
         (.term.reset)
         .sys.eol
         (.term.fg.magenta)
         "FG magenta"
         (.term.reset)
         .sys.eol
         (.term.fg.red)
         "FG red"
         (.term.reset)
         .sys.eol
         (.term.fg.white)
         (.term.fg.black)
         "FG white"
         (.term.reset)
         .sys.eol
         (.term.fg.yellow)
         "FG yellow"
         (.term.reset)
         .sys.eol
         (.term.fg.rgb 100 200 150)
         "FG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.bold)
         "Bold text"
         .sys.eol
         (.term.fg.blue)
         "Bold makes also colors brighter"
         (.term.reset)))
  nil)








(defn .time.advance

  ^{:doc {:description ["Returns a request for advancing `*timestamp*` (state timestamp) by `millis` milliseconds."
                        "Argument must be > 0."
                        "Great match for the standard `schedule` macro."]
          :examples    [{:code "($.time/!.advance (* 60 60 1000))"}]
          :signature   [{:params [millis]}]}}

  [millis]

  (.shell.invoke '.time.advance
                 millis))



(defn .time.iso

  []

  (.time.unix->iso (.time.unix)))



(defn .time.iso->unix

  ^{:doc {:description ["Returns a request for converting an ISO 8601 UTC date-time string into a Unix timestamp."
                        ""
                        "Result will be available under `$/*result*` during the next transaction."]
          :examples    [{:code "($.time/!.iso->unix \"2022-09-14T11:43:34.633\")"}]
          :signature   [{:params [iso-string]}]}}

  [iso-string]

  (.shell.invoke '.time.iso->unix
                 iso-string))



(defn .time.nano

  ^{:doc {:description ["Returns a request for retrieving the current value of a high-resolution timer."
                        "Result in nanoseconds will be available under `$/*result*` during the next transaction."
                        ""
                        "Guarantees:"
                        ""
                        "  - Timer is monotonic if the OS supports it"
                        "  - Resolution is at least as good as that of `$.time/!.unix`"
                        ""
                        "Useful for timing things as it is usually more reliable than `$.time/!.unix`."
                        "This timer has no particular, predictable origin. Hence the first value is meaningless."
                        "However, the difference between 2 values from the same process offers a precise interval."
                        "It follows that values from different process are not comparable."]
          :examples    [{:code "($.time/!.nano)"}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.nano))



(defn .time.unix

  ^{:doc {:description ["Returns a request for retrieving the current Unix timestamp in milliseconds."
                        "This reflects the machine's clock, not `*timestamp*` (state timestamp)."
                        "Resolution depends on the OS."
                        ""
                        "Result will be available under `$/*result*` during the next transaction."
                        ""
                        "For timing things, prefer `$.time/!.nano`."]
          :examples    [{:code "($.time/!.unix)"}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.unix))



(defn .time.unix->iso

  ^{:doc {:description ["Returns a request for converting a Unix timestamp into an ISO 8601 UTC date-time string."
                        ""
                        "Result will be available under `$/*result*` during the next transaction."]
          :examples    [{:code "($.time/!.unix->iso 1663155814633)"}]
          :signature   [{:params [unix-timestamp]}]}}

  [time-unix]

  (.shell.invoke '.time.unix->iso
                 time-unix))






(defmacro .try*

  [do-good do-bad]

  `(let [[ok?
          x]  (.state.safe (fn [] ~do-good))]
     (if ok?
       x
       ~do-bad)))
          


(defmacro .try.resrc*

  [binding+ & body]

  (when-not (and (vector? binding+)
                 (zero? (mod (count binding+)
                             3)))
    (fail :ARGUMENT
          "Bindings must be in a vector consisting of triples"))
  (loop [code (cons 'do
                    body)
         i    (- (count binding+)
                 3)]
    (if (< i
           0)
      code
      (recur
        (let [sym   (get binding+
                         i)
              open  (get binding+
                         (inc i))
              close (get binding+
                         (+ i
                            2))]
          `(let [~sym ~open
                 [ok?
                  x]  (.state.safe* ~code)]
             ~(if (symbol? close)
                (list close
                      sym)
                close)
             (if ok?
               x
               (.rethrow x))))
        (- i
           3)))))








(def .prn
     .stream.outln)





(def .version.shell

  nil)



(def .version.convex

  nil)
