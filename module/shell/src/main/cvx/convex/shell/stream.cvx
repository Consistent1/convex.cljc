(call *registry*
      (cns-update 'convex.shell.stream
                  *address*))


(call *registry*
      (register {:description ["Stream are able to read or write text or cells."
                               "When handled, they are designated by a handle that can be any cell"
                               "often provided by the user."
                               ""
                               "For instance, see the `$.file` library for dealing with files."]
                 :name        "Stream library for the Convex Shell"}))


;;;;;;;;; Private


(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))
 

;;;;;;;;;; STDIO handles


(def stderr

  ^{:doc {:description "Stream for STDERR"}}

  :stderr)



(def stdin

  ^{:doc {:description "Stream for STDIN."}}

  :stdin)



(def stdout

  ^{:doc {:description "Stream for STDOUT"}}

  :stdout)


;;;;;;;;;; Default handles


(def *err*

  ^{:doc {:description ["Default error stream, originally set to `stderr`."
                        "See `set.err`."]}}

  stderr)



(def *in*

  ^{:doc {:description ["Default input stream, originally set to `stdin`."
                        "See `set.in`."]}}

  stdin)



(def *out*

  ^{:doc {:description ["Default output stream, originally set to `stdout`."
                        "See `set.out`."]}}

  stdout)


;;;;;;;;;; Setting dynamic values


(defn set.err

  ^{:callable? true
    :doc       {:description "Sets `*err*` to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         ~*address*)
    (def *err*
         handle)
    (call ~*address*
          (set.err handle))))



(defn set.in

  ^{:callable? true
    :doc       {:description "Sets `*in*` to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         ~*address*)
    (def *in*
         handle)
    (call ~*address*
          (set.in handle))))



(defn set.out

  ^{:callable? true
    :doc       {:description "Sets `*out* to the given `handle`."
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         ~*address*)
    (def *out*
         handle)
    (call ~*address*
          (set.out handle))))


;;;;;;;;;; Requests for handling streams


(defn !.close

  ^{:doc {:description ["Returns a request for closing the given `handle`."
                        "`$.stream/stderr` cannot be closed."]
          :examples    [{:code "($.stream/!.close $.stream/stdout)"}]
          :signature   [{:params [handle]}]}}

  [handle]

  (assert (not (= handle
                  stderr)))
  [:cvm.sreq :stream.close handle])



(defn !.err

  ^{:doc {:description "Uses `$.stream/!.out` ont `*err*` for printing `x` to the default error stream."
          :examples    [{:code "($.stream/!.err {:some :error})"}]
          :signature   [{:params [x]}]}}

  [x]

  (!.out *err*
         x))



(defn !.errln

  ^{:doc {:description "Uses `$.stream/!.outln` ont `*err*` for printing `x` to the default error stream."
          :examples    [{:code "($.stream/!.errln {:some :error})"}]
          :signature   [{:params [x]}]}}

  [x]

  (!.outln *err*
           x))



(defn !.flush

  ^{:doc {:description ["Returns a request for flushing the given output `handle` and ensuring all outputs are processed."
                        "Flushes `*out*` by default."]
          :examples    [{:code "($.stream/!.flush)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (!.flush *out*))


  ([handle]

   [:cvm.sreq :stream.flush handle]))



(defn !.in+

  ^{:doc {:description ["Returns a request for reading the given input `handle`."
                        "Reads from `*in*` by default."
                        "Whole input is read and `handle` is automatically closed."
                        "List of read cells becomes available during next transaction under `$/*result*`."]
          :examples    [{:code "($.stream/!.in+ $.stream/stdin)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (!.in+ *in*))


  ([handle]

   [:cvm.sreq :stream.in+ handle]))



(defn !.line

  ^{:doc {:description ["Returns a request for reading a line from the given input `handle`."
                        "Reads from `*in*` by default."
                        "Stops when a new line is encountered."
                        "List of read cells becomes available during next the transaction under `$/*result*`."
                        "Result is `nil` when the end of the stream is reached. The stream is then closed"
                        "automatically."]
          :examples    [{:code "($.stream/!.line)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (!.line *in*))


  ([handle]

   [:cvm.sreq :stream.line handle]))



(defn !.open?

  ^{:doc {:description ["Returns a request for inspecting if the given `handle` is open."
                        "Boolean response will be available during the next transaction under `$/*result*`."]
          :examples    [{:code "($.stream/!.open? 42)"}]
          :signature   [{:params [handle]}]}}

  [handle]

  [:cvm.sreq :stream.open? handle])



(defn !.out

  ^{:doc {:description ["Returns a request for writing `x` to the given output `handle`."
                        "Writes to `*out*` by default."]
          :examples    [{:code "($.stream/!.out :foo)"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (!.out *out*
          x))


  ([handle x]

   [:cvm.sreq :stream.out handle x]))



(defn !.outln

  ^{:doc {:description "Likes `$.stream/!.out` but also outputs a new line and flushes the `handle`."
          :examples    [{:code "($.stream/!.outln :foo)"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (!.outln *out*
            x))


  ([handle x]

   [:cvm.sreq :stream.outln handle x]))



(defn !.txt.in

  ^{:doc {:description ["Returns a request for reading the rest of the given input `handle` as text."
                        "Reads from `*in*` by default."
                        "String will be available during the next transaction under `$/*result*`."
                        "Stream is closed automatically."]
          :examples    [{:code "($.stream/!.txt.in 42)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (!.txt.in *in*))


  ([handle]

   [:cvm.sreq :stream.txt.in handle]))



(defn !.txt.line

  ^{:doc {:description ["Returns a request for reading a line from the given input `handle` as text."
                        "Reads from `*in*` by default."
                        "String will be available during the next transaction under `$/*result*`."
                        "Result is `nil` when the end of the stream is reached. The stream is then closed"
                        "automatically."]
          :examples    [{:code "($.stream/!.txt.line)"}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (!.txt.line *in*))


  ([handle]

   [:cvm.sreq :stream.txt.line handle]))



(defn !.txt.out

  ^{:doc {:description ["Like `$.stream/!.out` but if `cell` is a string, it will not be double-quoted."
                        "Hence, the output might not be readable as Convex Lisp."]
          :examples    [{:code "($.stream/!.txt.out \"This is some text\")"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (!.txt.out *out*
              x))


  ([handle x]

   [:cvm.sreq :stream.txt.out handle x]))



(defn !.txt.outln

  ^{:doc {:description ["Like `$.stream/!.outln` but if `cell` is a string, it will not be double-quoted."
                        "Hence, the output might not be readable as Convex Lisp."]
          :examples    [{:code "($.stream/!.txt.outln \"This is some text\")"}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (!.txt.outln *out*
                x))


  ([handle x]

   [:cvm.sreq :stream.txt.outln handle x]))
