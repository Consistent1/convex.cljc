(ns convex.lisp.test.core.pred

  "Tests Convex core type predicate. 
  
   Specialized predicates such as `contains-key?` or `fn?` are located in relevant namespace."

  {:author "Adam Helinski"}

  (:require [clojure.test            :as t]
            [convex.lisp.form        :as $.form]
            [convex.lisp.test.eval   :as $.test.eval]
            [convex.lisp.test.prop   :as $.test.prop]
            [convex.lisp.test.schema :as $.test.schema]))


;;;;;;;;;;


(defn- -prop

  ;; Used by [[pred-data-false]] and [[pred-data-true]].


  ([form result? schema]

   (-prop form
          result?
          nil
          schema))


  ([form result? f-clojure schema]

   ($.test.prop/check schema
                      (let [suite   (fn [_x x-2]
                                      [["Always returns false"
                                        #(result? x-2)]])
                            suite-2 (if f-clojure
                                      (fn [x x-2]
                                        (conj (suite x
                                                     x-2)
                                              ["Consistent with Clojure"
                                               #(= x-2
                                                   (f-clojure x))]))
                                      suite)]

                        (fn [x]
                          ($.test.prop/mult (suite-2 x
                                                     ($.test.eval/result (list form
                                                                               ($.form/quoted x))))))))))



(defn prop-false

  "Like [[pred-data-true]] but tests for negative results.
  
   Provided schema is a set of data types meant to be removed from `:convex/data`."


  ([form schema-without]

   (prop-false form
               nil
               schema-without))


  ([form f-clojure schema-without]

   (-prop form
          false?
          f-clojure
          ($.test.schema/data-without schema-without))))



(defn prop-true

  "Tests if a value generated by Â´schema` passes a data predicate on the CVM.
  
   If `f-clojure` is given, also ensures that the very same value produces the exact same result
   in Clojure."


  ([form schema]

   (prop-true form
              nil
              schema))


  ([form f-clojure schema]

   (-prop form
          true?
          f-clojure
          schema)))


;;;;;;;;;;


#_($.test.prop/deftest ^:recur account?--false

  ;; TODO. Fails because of #90

  (prop-false 'account?
              #{:convex/address
                :convex/boolean  ;; TODO. See #73
                :convex/char     ;; TODO. See #68
                :convex/double
                :convex/long}))



($.test.prop/deftest ^:recur address?--false

  (prop-false 'address?
              #{:convex/address
                :convex/boolean  ;; TODO. See #73
                :convex/char     ;; TODO. See #68
                :convex/double
                :convex/long}))



($.test.prop/deftest address?--true

  ($.test.prop/check :convex/address
                     (fn [x]
                       ($.test.eval/result (list 'address?
                                                 x)))))



($.test.prop/deftest ^:recur blob?--false

  (prop-false 'blob?
              #{:convex/blob}))



($.test.prop/deftest blob?--true

  (prop-true 'blob?
             :convex/blob))



($.test.prop/deftest ^:recur boolean?--false

  (prop-false 'boolean?
              boolean?
              #{:convex/boolean}))



(t/deftest boolean?--true

  (t/is (true? ($.test.eval/result true))
        "True")

  (t/is (false? ($.test.eval/result false))
        "False"))



($.test.prop/deftest ^:recur coll?--false

  (prop-false 'coll?
              coll?
              #{:convex/list
                :convex/map
                :convex/set
                :convex/vector}))



($.test.prop/deftest ^:recur coll?--true

  (prop-true 'coll?
             coll?
             :convex/collection))



($.test.prop/deftest ^:recur keyword?--false

  (prop-false 'keyword?
              keyword?
              #{:convex/keyword}))



($.test.prop/deftest keyword?--true

  (prop-true 'keyword?
             keyword?
             :convex/keyword))



($.test.prop/deftest ^:recur list?--false

  (prop-false 'list?
              list?
              #{:convex/list}))



($.test.prop/deftest ^:recur list?--true

  (prop-true 'list?
             seq?
             :convex/list))



($.test.prop/deftest ^:recur long?--false

  (prop-false 'long?
              int?
              #{:convex/long}))



($.test.prop/deftest long?--true

  (prop-true 'long?
             int?
             :convex/long))



($.test.prop/deftest ^:recur map?--false

  (prop-false 'map?
              map?
              #{:convex/map}))



($.test.prop/deftest ^:recur map?--true

  (prop-true 'map?
             map?
             :convex/map))



($.test.prop/deftest ^:recur nil?--false

  (prop-false 'nil?
              nil?
              #{:convex/nil}))



(t/deftest nil?--true

  (t/is (true? (nil? ($.test.eval/result nil))))

  (t/is (true? (nil? ($.test.eval/result '(do nil))))))



($.test.prop/deftest ^:recur number?--false

  (prop-false 'number?
              number?
              #{:convex/boolean ;; TODO. See #73.
                :convex/char    ;; TODO. See #68.
                :convex/double
                :convex/long}))



($.test.prop/deftest number?--true

  (prop-true 'number?
             number?
             :convex/number))



($.test.prop/deftest ^:recur set?--false

  (prop-false 'set?
              set?
              #{:convex/set}))



($.test.prop/deftest ^:recur set?--true

  (prop-true 'set?
             set?
             :convex/set))



($.test.prop/deftest ^:recur str?--false

  (prop-false 'str?
              string?
              #{:convex/string}))



($.test.prop/deftest str?--true

  (prop-true 'str?
             string?
             :convex/string))



($.test.prop/deftest symbol?--true

  (prop-true 'symbol?
             symbol?
             :convex/symbol))



($.test.prop/deftest ^:recur symbol?--false

  (prop-false 'symbol?
              (partial $.test.schema/valid?
                       :convex/symbol)
              #{:convex/symbol}))



($.test.prop/deftest ^:recur vector?--false

  (prop-false 'vector?
              vector?
              #{:convex/vector}))



($.test.prop/deftest ^:recur vector?--true

  (prop-true 'vector?
             vector?
             :convex/vector))
