;;
;;
;; Special transactions supported by the runner.
;;
;; Defined as function but they throw a fatal error when used as regular Convex Lisp code.
;; Also act as documentation holders.
;;
;;
(do

  ;; HELPERS

  (defn -fail

    ^{:doc {:description "Used inside special transactions when they are called inside regular ones. Fails with a fatal error."}}

    []

    (fail :FATAL
          "Special transaction cannot be used as a regular function"))


  ;; SPECIAL TRANSACTIONS


  (defn catch

    ^{:doc {:description ["If used, must be the last form in `try`."
                          "See `try` for an example"]
            :signature   [{:params [& trx+]}]
            :type        :special-transaction}}

    [& trx+]

    (-fail))



  (defn dep

    ^{:doc {:description ["Special transaction which loads Convex Lisp dependencies files. During watch mode, those files are live-reloaded as well."
                          "Takes a map of `symbol` -> `path to file`. Files are read as vectors of Convex Lisp forms and then defined under their corresponding symbol."
                          "Then, those forms can be used as needed. It is common to use `deploy` or `eval`, depending on the purpose of a given file."]
            :examples    [{:code "(cvm/dep {my-lib \"path/to/lib.cvx\"})"}]
            :signature   [{:params [sym->file]}]
            :type        :special-transaction}}

    [sym->file]

    (-fail))



  (defn do

    ^{:doc {:description ["Executes each argument as a transaction."
                          "Useful when composing special transactions in some way"]
            :examples    [{:code "(cvm/do (def foo 42) (cvm/out foo))"}]
            :signature   [{:params [& trx+]}]
            :type        :special-transaction}}

    [& trx+]

    (-fail))



  (defn env

    ^{:doc {:description ["Retrieves environment variable from the current process. Useful when some information must be passed to the runner from the outside."
                          "When a symbol is given, defines under that symbol the entire map of `env property (string)` -> `env value (string)`."
                          "When a env variable is given as well, defines only the value for that variable"]
            :examples    [{:code "(cvm/env env-map"}
                          {:code "(cvm/env my-x-value \"MY_X\")"}]
            :signature   [{:params [sym]}
                          {:params [sym env-var]}]
            :type        :special-transaction}}


    ([sym]

     (-fail))


    ([sym env-var]

     (-fail)))



  (defn hook.end

    ^{:doc {:description ["Registers the given transactions to be executed at the end, even if an error occured."
                          "Overwrites what was previously registers."
                          "Providing no transaction cancels what was previously registered."]
            :examples    [{:code "(cvm/hook.end)"}
                          {:code "(cvm/hook.end (def foo 42) (cvm/out [:end :foo foo]))}"}]
            :signature   [{:params [& trx+]}]
            :type        :special-transaction}}

    [& trx+]

    (-fail))



  (defn hook.error

    ^{:doc {:description ["When an exception occurs, the given function is called with that exception. The result is code that is interpreted."
                          "Returned code can be a special transaction."
                          "Default is outputting the error without any modification"
                          "Overwrites any previously registered function, `nil` removes it."]
            :examples    [{:code "(cvm/hook.error (fn [ex] `(cvm/out [:EXCEPTION ~ex])))"}]
            :signature   [{:params [f]}]
            :type        :special-transaction}}

    [f]

    (-fail))



  (defn hook.out

    ^{:doc {:description ["Registers a function that modifies any value prior to being outputted with `out`"
                          "Default is `identity`"
                          "If the function returns nil, then nothing is outputted."
                          "Overwrites any previously registered function, `nil` removes it."]
            :examples    [{:code "(cvm/hook.out (fn [x] (when-not (:foo x) x)))"}]
            :signature   [{:params [f]}]
            :type        :special-transaction}}

    [f]

    (-fail))



  (defn hook.trx

    ^{:doc {:description ["Registers a function that modifies a regular transaction (not any special one)."
                          "Useful for decorating all subsequent transactions or filtering them based on metadata."
                          "Overwrites any previously registered function, `nil` removes it."]
            :examples    [{:code "(cvm/hook.trx (fn [trx] `(cvm/out [(quote ~trx) ~trx])))"}]
            :signature   [{:params [f]}]
            :type        :special-transaction}}

    [f]

    (-fail))

                                                        

  (defn log

    ^{:doc {:description "Defines the current CVM log under the given symbol"
            :examples    [{:code "(cvm/do (log :foo) (cvm/log l) (cvm/out l))"}]
            :signature   [{:params [sym]}]
            :type        :special-transaction}}

    [sym]

    (-fail))



  (defn out

    ^{:doc {:description "Special transaction which outputs the given argument."
            :examples    [{:code "(cvm/out 42)"}]
            :signature   [{:params [x]}]
            :type        :special-transaction}}

    [x]

    (-fail))



  (defn read

    ^{:doc {:description ["Passes the given string through the Convex Lisp reader and returns a vector forms."
                          "Those forms can be compiled, evaluated, ..."]
            :examples    [{:code "(cvm/read \"(+ 2 2)\")"}]
            :signature   [{:params [string]}]
            :type        :special-transaction}}

    [string]

    (-fail))



  (defn splice

    ^{:doc {:description ["Evaluates the given argument, result must be a vector of transactions."
                          "Executes those transactions one by one."
                          "Similar to `do` but more dynamic."]
            :examples    [{:code "(cvm/do (def x (quote [(def foo 42) (cvm/out foo)])) (cvm/splice x))"}]
            :signature   [{:params [trx+]}]
            :type        :special-transaction}}

    [trx+]

    (-fail))



  (defn screen.clear

    ^{:doc {:description ["Clears the screen."
                          "Useful only if the output is printed in the terminal."]
            :examples    [{:code "(cvm/clear.screen)"}]
            :signature   [{:params []}]
            :type        :special-transaction}}

    []

    (-fail))



  (defn try

    ^{:doc {:description ["Given transactions are executed one by one until an exception is thrown."
                          "In such case, the exeception is defined under `*cvm.error*` and transactions in the catch form are executed (see `catch`)."
                          "With or without a catch form, execution outside of `try` continues."]
            :examples    [{:code "(cvm/try (def foo 42) (fail \"Oops\") (cvm/catch (cvm/out [:error *cvm.error*])))"}]
            :signature   [{:params [& trx+]}]
            :type        :special-transaction}}
                        

    [& trx+]

    (-fail))
                

  ) ;; END
