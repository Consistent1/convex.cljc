;;
;;
;; Special transactions supported by the runner.
;;
;; Defined as function but they throw a fatal error when used as regular Convex Lisp code.
;; Also act as documentation holders.
;;
;;
(do

  (def sreq
       (deploy '(do

                  (call *registry*
                        (cns-update 'convex.run.sreq 
                                    *address*))

                
                  ;; SPECIAL REQUESTS
                
                
                  (defn dep
                
                    ^{:doc {:description ["Special transaction which loads Convex Lisp dependencies files. During watch mode, those files are live-reloaded as well."
                                          "If needed, MUST be written as the very first transaction found in the main file."
                                          "Takes a map of `symbol` -> `path to file`. Files are read as vectors of Convex Lisp forms and then defined under their corresponding symbol."
                                          "Then, those forms can be used as needed. It is common to use `deploy` or `eval`, depending on the purpose of a given file."]
                            :examples    [{:code "(sreq/dep {my-lib \"path/to/lib.cvx\"})"}]
                            :signature   [{:params [sym->file]}]
                            :type        :function}}
                
                    [sym->file]
                
                    (assert (not "First transaction")))
                
                
                
                  (defn do
                
                    ^{:doc {:description ["Executes each argument as a transaction."
                                          "Useful when composing special transactions in some way"]
                            :examples    [{:code "(sreq/do (def foo 42) (sreq/out foo))"}]
                            :signature   [{:params [& trx+]}]
                            :type        :function}}
                
                    [trx+]

                    (assert (or (list? trx+)
                                (vector? trx+)))
                    [:cvm.sreq :do trx+])
                


                  (defn env
                
                    ^{:doc {:description ["Retrieves environment variable from the current process. Useful when some information must be passed to the runner from the outside."
                                          "When a symbol is given, defines under that symbol the entire map of `env property (string)` -> `env value (string)`."
                                          "When a env variable is given as well, defines only the value for that variable"]
                            :examples    [{:code "(sreq/env env-map"}
                                          {:code "(sreq/env my-x-value \"MY_X\")"}]
                            :signature   [{:params [sym]}
                                          {:params [sym env-var]}]
                            :type        :function}}
                
                
                    ([sym]

                     (-env sym
                           nil))
                
                
                    ([sym env-var]

                     (assert (symbol? sym))
                     (assert (or (str? env-var)
                                 (nil? env-var)))
                     [:cvm.sreq :env sym env-var]))
                
                
                
                  (defn hook.end
                
                    ^{:doc {:description ["Registers the given transactions to be executed at the end, even if an error occured."
                                          "Overwrites what was previously registers."
                                          "Providing no transaction cancels what was previously registered."]
                            :examples    [{:code "(sreq/hook.end)"}
                                          {:code "(sreq/hook.end (def foo 42) (sreq/out [:end :foo foo]))}"}]
                            :signature   [{:params [& trx+]}]
                            :type        :function}}
                
                    [trx+]
                
                    (assert (or (list? trx+)
                                (vector? trx+)))
                    [:cvm.sreq :hook.end trx+])
                
                
                
                  (defn hook.error
                
                    ^{:doc {:description ["When an exception occurs, the given function is called with that exception. The result is code that is interpreted."
                                          "Returned code can be a special transaction."
                                          "Default is outputting the error without any modification"
                                          "Overwrites any previously registered function, `nil` removes it."]
                            :examples    [{:code "(sreq/hook.error (fn [ex] `(sreq/out [:EXCEPTION ~ex])))"}]
                            :signature   [{:params [f]}]
                            :type        :function}}
                
                    [f]
                
                    (assert (fn? f))
                    [:cvm.sreq :hook.error f])
                
                
                
                  (defn hook.out
                
                    ^{:doc {:description ["Registers a function that modifies any value prior to being outputted with `out`"
                                          "Default is `identity`"
                                          "If the function returns nil, then nothing is outputted."
                                          "Overwrites any previously registered function, `nil` removes it."]
                            :examples    [{:code "(sreq/hook.out (fn [x] (when-not (:foo x) x)))"}]
                            :signature   [{:params [f]}]
                            :type        :function}}
                
                    [f]

                    (assert (fn? f))
                    [:cvm.sreq :hook.out f])
                
                
                
                  (defn hook.trx
                
                    ^{:doc {:description ["Registers a function that modifies a regular transaction (not any special one)."
                                          "Useful for decorating all subsequent transactions or filtering them based on metadata."
                                          "Overwrites any previously registered function, `nil` removes it."]
                            :examples    [{:code "(sreq/hook.trx (fn [trx] `(sreq/out [(quote ~trx) ~trx])))"}]
                            :signature   [{:params [f]}]
                            :type        :function}}
                
                    [f]

                    [:cvm.sreq :hook.trx f])
                
                                                                        
                
                  (defn log
                
                    ^{:doc {:description "Defines the current CVM log under the given symbol"
                            :examples    [{:code "(sreq/do (log :foo) (sreq/log l) (sreq/out l))"}]
                            :signature   [{:params [sym]}]
                            :type        :function}}
                
                    [sym]
                
                    (assert (symbol? sym))
                    [:cvm.sreq :log sym])
                
                
                
                  (defn out
                
                    ^{:doc {:description "Special transaction which outputs the given argument."
                            :examples    [{:code "(sreq/out 42)"}]
                            :signature   [{:params [x]}]
                            :type        :function}}
                
                    [x]

                    [:cvm.sreq :out x])
                
                
                
                  (defn read
                
                    ^{:doc {:description ["Passes the given string through the Convex Lisp reader and returns a list of forms."
                                          "Those forms can be compiled, evaluated, ..."]
                            :examples    [{:code "(sreq/read \"(+ 2 2)\")"}]
                            :signature   [{:params [string]}]
                            :type        :function}}
                
                    [sym src]
                
                    (assert (str? src))
                    (assert (symbol? sym))
                    [:cvm.sreq :read src])
                

                
                  (defn screen.clear
                
                    ^{:doc {:description ["Clears the screen."
                                          "Useful only if the output is printed in the terminal."]
                            :examples    [{:code "(sreq/clear.screen)"}]
                            :signature   [{:params []}]
                            :type        :function}}
                
                    []

                    [:cvm.sreq :screen.clear])
                
                

                  (defn try
                
                    ^{:doc {:description ["Given transactions are executed one by one until an exception is thrown."
                                          "In such case, the exception is defined under `*cvm.error*` and transactions in the catch form are executed (see `catch`)."
                                          "With or without a catch form, execution outside of `try` continues."]
                            :examples    [{:code "(sreq/try (def foo 42) (fail \"Oops\") (sreq/catch (sreq/out [:error *cvm.error*])))"}]
                            :signature   [{:params [& trx+]}]
                            :type        :function}}
                                        
                
                    ([try-trx+]

                     (try try-trx+
                          nil))


                    ([try-trx+ catch-trx+]

                     (assert (or (list? try-trx+)
                                 (vector? try-trx+)))
                     (assert (or (nil? catch-trx+)
                                 (list? catch-trx+)
                                 (vector? catch-trx+)))
                     [:cvm.sreq :try try-trx+ catch-trx+]))
                              
                
                  ))) ;; END - STRX



  (def help
       (deploy '(do

                  (call *registry*
                        (cns-update 'convex.run.help
                                    *address*))


                  (import convex.run.sreq :as sreq)


                  ;; SPECIAL VALUES

                  (def *cycle*

                    ^{:doc {:description ["Starting at 0, is incremented every time the main file is run."
                                          "Potentially useful for watch mode."]}}

                    nil)



                  (def *error*

                    ^{:doc {:description ["Any thrown exception is defined under this symbol."
                                          "Notably useful in try-catch (see `try`)"]}}

                    nil)



                  (def *file*

                    ^{:doc {:description "Canonical path of the invoked main file."}}

                    nil)



                  (def *juice.last*

                    ^{:doc {:description "The amount of juice consumed by the previous transaction."}}

                    nil)



                  (def *juice.total*

                    ^{:doc {:description "Total amount of juice consumed up to now."}}

                    nil)



                  (def *trx.form*

                    ^{:doc {:description "Form representing the current transaction."}}

                    nil)



                  (def *trx.id*

                    ^{:doc {:description ["Starting at 0, is incremented on every transaction."
                                          "Resets on each run in watch mode."]}}

                    nil)


                  ;; FUNCTIONS


                  (defn line+

                    [section+]

                    (apply str
                           (reduce (fn [acc [section line+]]
                                     (reduce (fn [acc-2 line]
                                               (conj acc-2
                                                     \newline
                                                     \newline
                                                     line))
                                             (conj acc
                                                   \newline
                                                   \newline
                                                   \newline
                                                   section
                                                   \newline
                                                   (loop [acc []
                                                          i   (count section)]
                                                    (if (> i
                                                           0)
                                                      (recur (conj acc
                                                                   "=")
                                                             (dec i))
                                                      (apply str
                                                             acc))))
                                             line+))
                                   []
                                   section+)))



                  (let [-doc (fn [target meta]
                               (let [doc         (:doc meta)
                                     description (:description doc)
                                     example+    (:examples doc)
                                     signature   (:signature doc)
                                     type        (:type doc)
                                     target-sym  (symbol target)
                                     section+    [["HELP"
                                                   [target]]]
                                     section-2+  (if type
                                                   (conj section+
                                                         ["TYPE"
                                                          [type]])
                                                   section+)
                                     section-3+  (if signature
                                                   (conj section-2+
                                                         ["SIGNATURE"
                                                          (map (fn [sign]
                                                                 (cons target-sym
                                                                       (:params sign)))
                                                               signature)])
                                                   section-2+)
                                     section-4+  (if description
                                                   (conj section-3+
                                                         ["DESCRIPTION"
                                                          (cond
                                                            (str? description)    [description]
                                                            (vector? description) description
                                                            :else                 ["Malformed, description must be a string or a vector or strings."])])
                                                   section-3+)
                                     section-5+  (if example+
                                                   (conj section-4+
                                                         ["EXAMPLES"
                                                          (map :code
                                                               example+)])
                                                   section-4+)]
                                 (line+ section-5+)))]

                      (defn about-str


                        ([addr-or-sym]

                         (if (symbol? addr-or-sym)
                           (-doc (str addr-or-sym)
                                 (lookup-meta addr-or-sym))
                           (if-let [acc (account addr-or-sym)]
                             (let [allowance   (acc :allowance)
                                   balance     (acc :balance)
                                   controller  (acc :controller)
                                   env         (acc :environment)
                                   key         (acc :key)
                                   meta        (acc :metadata)
                                   section+    [["ACCOUNT"
                                                 [addr-or-sym]]
                                                ["KEY"
                                                 [(or key
                                                      "None (this is an actor)")]]
                                                ["ALLOWANCE"
                                                 [allowance]]
                                                ["BALANCE"
                                                 [balance]]
                                                ["CONTROLLER"
                                                 [(or controller
                                                      "None")]]]]
                               (line+ (if (> (count env)
                                             0)
                                        (conj section+
                                              ["ENVIRONMENT"
                                               (reduce (fn [line+ [k _v]]
                                                         (if-let [desc (get-in meta
                                                                               [k
                                                                                :doc
                                                                                :description])]
                                                           (conj line+
                                                                 k
                                                                 (str "  "
                                                                      (if (str? desc)
                                                                        desc
                                                                        (first desc))))
                                                           (conj line+
                                                                 k)))
                                                       []
                                                       env)])
                                        section+)))
                             (str "Account "
                                  addr-of-sym
                                  " does not exist."))))


                        ([addr sym]

                         (-doc (str (address addr)
                                             "/"
                                             sym)
                               (lookup-meta addr
                                            sym)))))



                    (defn about


                      ([addr-or-sym]

                       (sreq/out (about-str addr-or-sym)))


                      ([addr sym]

                       (sreq/out (about-str addr
                                            sym))))


                    )))  ;; End - HELP



  ;; CVM result, needed for easily getting the addresses of the libraries.
  ;;
  [help
   sreq]


  ) ;; END 
