;;
;;
;; Special transactions supported by the runner.
;;
;; Defined as function but they throw a fatal error when used as regular Convex Lisp code.
;; Also act as documentation holders.
;;
;;
(do

  (def strx
       (deploy '(do

                  (call *registry*
                        (cns-update 'convex.run.strx 
                                    *address*))

                  ;; HELPERS
                
                  (defn -fail
                
                    ^{:doc {:description "Used inside special transactions when they are called inside regular ones. Fails with a fatal error."}}
                
                    []
                
                    (fail :FATAL
                          "Special transaction cannot be used as a regular function"))
                
                
                  ;; SPECIAL TRANSACTIONS
                
                
                  (defn catch
                
                    ^{:doc {:description ["If used, must be the last form in `try`."
                                          "See `try` for an example"]
                            :signature   [{:params [& trx+]}]
                            :type        :special-transaction}}
                
                    [& trx+]
                
                    (-fail))
                
                
                
                  (defn dep
                
                    ^{:doc {:description ["Special transaction which loads Convex Lisp dependencies files. During watch mode, those files are live-reloaded as well."
                                          "Takes a map of `symbol` -> `path to file`. Files are read as vectors of Convex Lisp forms and then defined under their corresponding symbol."
                                          "Then, those forms can be used as needed. It is common to use `deploy` or `eval`, depending on the purpose of a given file."]
                            :examples    [{:code "(strx/dep {my-lib \"path/to/lib.cvx\"})"}]
                            :signature   [{:params [sym->file]}]
                            :type        :special-transaction}}
                
                    [sym->file]
                
                    (-fail))
                
                
                
                  (defn do
                
                    ^{:doc {:description ["Executes each argument as a transaction."
                                          "Useful when composing special transactions in some way"]
                            :examples    [{:code "(strx/do (def foo 42) (strx/out foo))"}]
                            :signature   [{:params [& trx+]}]
                            :type        :special-transaction}}
                
                    [& trx+]
                
                    (-fail))
                
                
                
                  (defn env
                
                    ^{:doc {:description ["Retrieves environment variable from the current process. Useful when some information must be passed to the runner from the outside."
                                          "When a symbol is given, defines under that symbol the entire map of `env property (string)` -> `env value (string)`."
                                          "When a env variable is given as well, defines only the value for that variable"]
                            :examples    [{:code "(strx/env env-map"}
                                          {:code "(strx/env my-x-value \"MY_X\")"}]
                            :signature   [{:params [sym]}
                                          {:params [sym env-var]}]
                            :type        :special-transaction}}
                
                
                    ([sym]
                
                     (-fail))
                
                
                    ([sym env-var]
                
                     (-fail)))
                
                
                
                  (defn hook.end
                
                    ^{:doc {:description ["Registers the given transactions to be executed at the end, even if an error occured."
                                          "Overwrites what was previously registers."
                                          "Providing no transaction cancels what was previously registered."]
                            :examples    [{:code "(strx/hook.end)"}
                                          {:code "(strx/hook.end (def foo 42) (strx/out [:end :foo foo]))}"}]
                            :signature   [{:params [& trx+]}]
                            :type        :special-transaction}}
                
                    [& trx+]
                
                    (-fail))
                
                
                
                  (defn hook.error
                
                    ^{:doc {:description ["When an exception occurs, the given function is called with that exception. The result is code that is interpreted."
                                          "Returned code can be a special transaction."
                                          "Default is outputting the error without any modification"
                                          "Overwrites any previously registered function, `nil` removes it."]
                            :examples    [{:code "(strx/hook.error (fn [ex] `(strx/out [:EXCEPTION ~ex])))"}]
                            :signature   [{:params [f]}]
                            :type        :special-transaction}}
                
                    [f]
                
                    (-fail))
                
                
                
                  (defn hook.out
                
                    ^{:doc {:description ["Registers a function that modifies any value prior to being outputted with `out`"
                                          "Default is `identity`"
                                          "If the function returns nil, then nothing is outputted."
                                          "Overwrites any previously registered function, `nil` removes it."]
                            :examples    [{:code "(strx/hook.out (fn [x] (when-not (:foo x) x)))"}]
                            :signature   [{:params [f]}]
                            :type        :special-transaction}}
                
                    [f]
                
                    (-fail))
                
                
                
                  (defn hook.trx
                
                    ^{:doc {:description ["Registers a function that modifies a regular transaction (not any special one)."
                                          "Useful for decorating all subsequent transactions or filtering them based on metadata."
                                          "Overwrites any previously registered function, `nil` removes it."]
                            :examples    [{:code "(strx/hook.trx (fn [trx] `(strx/out [(quote ~trx) ~trx])))"}]
                            :signature   [{:params [f]}]
                            :type        :special-transaction}}
                
                    [f]
                
                    (-fail))
                
                                                                        
                
                  (defn log
                
                    ^{:doc {:description "Defines the current CVM log under the given symbol"
                            :examples    [{:code "(strx/do (log :foo) (strx/log l) (strx/out l))"}]
                            :signature   [{:params [sym]}]
                            :type        :special-transaction}}
                
                    [sym]
                
                    (-fail))
                
                
                
                  (defn out
                
                    ^{:doc {:description "Special transaction which outputs the given argument."
                            :examples    [{:code "(strx/out 42)"}]
                            :signature   [{:params [x]}]
                            :type        :special-transaction}}
                
                    [x]
                
                    (-fail))
                
                
                
                  (defn read
                
                    ^{:doc {:description ["Passes the given string through the Convex Lisp reader and returns a vector forms."
                                          "Those forms can be compiled, evaluated, ..."]
                            :examples    [{:code "(strx/read \"(+ 2 2)\")"}]
                            :signature   [{:params [string]}]
                            :type        :special-transaction}}
                
                    [string]
                
                    (-fail))
                
                
                
                  (defn splice
                
                    ^{:doc {:description ["Evaluates the given argument, result must be a vector of transactions."
                                          "Executes those transactions one by one."
                                          "Similar to `do` but more dynamic."]
                            :examples    [{:code "(strx/do (def x (quote [(def foo 42) (strx/out foo)])) (strx/splice x))"}]
                            :signature   [{:params [trx+]}]
                            :type        :special-transaction}}
                
                    [trx+]
                
                    (-fail))
                
                
                
                  (defn screen.clear
                
                    ^{:doc {:description ["Clears the screen."
                                          "Useful only if the output is printed in the terminal."]
                            :examples    [{:code "(strx/clear.screen)"}]
                            :signature   [{:params []}]
                            :type        :special-transaction}}
                
                    []
                
                    (-fail))
                
                
                
                  (defn try
                
                    ^{:doc {:description ["Given transactions are executed one by one until an exception is thrown."
                                          "In such case, the exception is defined under `*cvm.error*` and transactions in the catch form are executed (see `catch`)."
                                          "With or without a catch form, execution outside of `try` continues."]
                            :examples    [{:code "(strx/try (def foo 42) (fail \"Oops\") (strx/catch (strx/out [:error *cvm.error*])))"}]
                            :signature   [{:params [& trx+]}]
                            :type        :special-transaction}}
                                        
                
                    [& trx+]
                
                    (-fail))
                                
                
                  ))) ;; END - STRX



  (def help
       (deploy '(do

                  (call *registry*
                        (cns-update 'convex.run.help
                                    *address*))



                  (defn line+

                    [section+]

                    (apply str
                           (reduce (fn [acc [section line+]]
                                     (reduce (fn [acc-2 line]
                                               (conj acc-2
                                                     \newline
                                                     \newline
                                                     line))
                                             (conj acc
                                                   \newline
                                                   \newline
                                                   \newline
                                                   section
                                                   \newline
                                                   (loop [acc []
                                                          i   (count section)]
                                                    (if (> i
                                                           0)
                                                      (recur (conj acc
                                                                   "=")
                                                             (dec i))
                                                      (apply str
                                                             acc))))
                                             line+))
                                   []
                                   section+)))



                  (let [-doc (fn [target meta]
                               (let [doc         (:doc meta)
                                     description (:description doc)
                                     example+    (:examples doc)
                                     signature   (:signature doc)
                                     type        (:type doc)
                                     target-sym  (symbol target)
                                     section+    [["HELP"
                                                   [target]]]
                                     section-2+  (if type
                                                   (conj section+
                                                         ["TYPE"
                                                          [type]])
                                                   section+)
                                     section-3+  (if signature
                                                   (conj section-2+
                                                         ["SIGNATURE"
                                                          (map (fn [sign]
                                                                 (cons target-sym
                                                                       (:params sign)))
                                                               signature)])
                                                   section-2+)
                                     section-4+  (if description
                                                   (conj section-3+
                                                         ["DESCRIPTION"
                                                          (cond
                                                            (str? description)    [description]
                                                            (vector? description) description
                                                            :else                 ["Malformed, description must be a string or a vector or strings."])])
                                                   section-3+)
                                     section-5+  (if example+
                                                   (conj section-4+
                                                         ["EXAMPLES"
                                                          (map :code
                                                               example+)])
                                                   section-4+)]
                                 (line+ section-5+)))]

                      (defn doc


                        ([sym]

                         (-doc (str sym)
                               (lookup-meta sym)))


                        ([addr sym]

                         (-doc (str (address addr)
                                             "/"
                                             sym)
                               (lookup-meta addr
                                            sym)))))


                    )))  ;; End - HELP


  ) ;; END 
