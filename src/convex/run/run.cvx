;;
;;
;; Special transactions supported by the runner.
;;
;; Defined as function but they throw a fatal error when used as regular Convex Lisp code.
;; Also act as documentation holders.
;;
;;
(do

  (def sreq
       (deploy '(do

                  (call *registry*
                        (cns-update 'convex.run.sreq 
                                    *address*))


                  (call *registry*
                        (register {:doc  {:description ["Special requests are vectors of data which instruct the Convex Lisp Runner to perform useful actions such as outputting values."
                                                        "Those actions are not implemented by the CVM, they are only understood by Runner."
                                                        "After each transaction in the main file has been executed, the Runner checks if the result is any supported special request."
                                                        "Such vectors are created by calling functions from this address."]}
                                   :name "Convex Lisp Runner Special Requests"}))

                
                  ;; SPECIAL REQUESTS
                

                  (defn advance

                    ^{:doc {:description ["Advances the current timestamp by `millis` milliseconds."
                                          "Argument must be > 0."]
                            :examples    [{:code "(sreq/advance (* 60 60 1000))"}]
                            :signature   [{:params [millis]}]
                            :type        :function}}

                    [millis]

                    (assert (>= millis
                                0))
                    [:cvm.sreq :advance millis])


                
                  (defn dep
                
                    ^{:doc {:description ["Loads Convex Lisp dependency files. During watch mode, those files are live-reloaded as well."
                                          "If used, MUST be written as the very first transaction found in the main file."
                                          "Takes a map of `symbol` -> `path to file`. Files are read as lists of Convex Lisp forms and then defined under their corresponding symbol."
                                          "Then, those forms can be used as needed. It is common to use `deploy` or `eval`, depending on the purpose of a given file."]
                            :examples    [{:code "(sreq/dep {'my-lib \"path/to/lib.cvx\"})"}]
                            :signature   [{:params [sym->file]}]
                            :type        :function}}
                
                    [sym->file]
                
                    (assert (not "First transaction")))
                
                
                
                  (defn do
                
                    ^{:doc {:description ["Given a sequence of quoted transactions, executes them one by one."
                                          "Useful when composing special requests in some way."]
                            :examples    [{:code "(sreq/do '[(def foo 42) (sreq/out foo)])"}]
                            :signature   [{:params [trx+]}]
                            :type        :function}}
                
                    [trx+]

                    (assert (or (list? trx+)
                                (vector? trx+)))
                    [:cvm.sreq :do trx+])
                


                  (defn env
                
                    ^{:doc {:description ["Retrieves environment variable from the current process. Useful when some information must be passed to the runner from the outside."
                                          "When a symbol is given, defines under that symbol the entire map of `env property (string)` -> `env value (string)`."
                                          "When a env variable is given as well, defines only the value for that variable"]
                            :examples    [{:code "(sreq/env 'env-map"}
                                          {:code "(sreq/env 'my-x-value \"MY_X\")"}]
                            :signature   [{:params [sym]}
                                          {:params [sym env-var]}]
                            :type        :function}}
                
                
                    ([sym]

                     (-env sym
                           nil))
                
                
                    ([sym env-var]

                     (assert (symbol? sym))
                     (assert (or (str? env-var)
                                 (nil? env-var)))
                     [:cvm.sreq :env sym env-var]))
                
                
                
                  (defn hook.end
                
                    ^{:doc {:description ["Registers the given sequence of quoted transactions to be executed at the end, even if an error occured."
                                          "Overwrites what was previously registers."
                                          "Providing no transaction cancels what was previously registered."]
                            :examples    [{:code "(sreq/hook.end nil)"}
                                          {:code "(sreq/hook.end '[(def foo 42) (sreq/out [:end :foo foo])])"}]
                            :signature   [{:params [trx+]}]
                            :type        :function}}
                
                    [trx+]
                
                    (assert (or (list? trx+)
                                (nil? trx+)
                                (vector? trx+)))
                    [:cvm.sreq :hook.end trx+])
                
                
                
                  (defn hook.error
                
                    ^{:doc {:description ["When an exception occurs, the given function is called with that exception. The result is code that is interpreted."
                                          "Returned code can be a special request."
                                          "Default is outputting the error without any modification"
                                          "Overwrites any previously registered function, `nil` removes it."]
                            :examples    [{:code "(sreq/hook.error (fn [ex] (sreq/out [:EXCEPTION ex])))"}]
                            :signature   [{:params [f]}]
                            :type        :function}}
                
                    [f]
                
                    (assert (fn? f))
                    [:cvm.sreq :hook.error f])
                
                
                
                  (defn hook.out
                
                    ^{:doc {:description ["Registers a function that modifies any value prior to being outputted with `out`"
                                          "Default is `identity`, meaning values are not modified."
                                          "If the function returns nil, then nothing is outputted."
                                          "Overwrites any previously registered function, `nil` removes it."]
                            :examples    [{:code "(sreq/hook.out (fn [x] (when-not (:foo x) x)))"}]
                            :signature   [{:params [f]}]
                            :type        :function}}
                
                    [f]

                    (assert (fn? f))
                    [:cvm.sreq :hook.out f])
                
                
                
                  (defn hook.result
                
                    ^{:doc {:description ["Registers a quoted transaction meant to be executed after transaction with the purpose of doing some post-processing."
                                          "Useful for things like displaying juice consumption, tracing transactions, etc."
                                          "Overwrites any previously registered quoted transaction, `nil` removes it."]
                            :examples    [{:code "(sreq/hook.trx '(sreq/out [:result help/*trx.last.result* :juice help/*trx.last.juice*]))"}]
                            :signature   [{:params [f]}]
                            :type        :function}}
                
                    [f]

                    [:cvm.sreq :hook.result f])
                
                                                                        
                
                  (defn log
                
                    ^{:doc {:description "Defines the current CVM log under the given symbol."
                            :examples    [{:code "(sreq/do '[(log :foo) (sreq/log l) (sreq/out l))"}]
                            :signature   [{:params [sym]}]
                            :type        :function}}
                
                    [sym]
                
                    (assert (symbol? sym))
                    [:cvm.sreq :log sym])
                
                
                
                  (defn out
                
                    ^{:doc {:description "Outputs the given argument."
                            :examples    [{:code "(sreq/out 42)"}]
                            :signature   [{:params [x]}]
                            :type        :function}}
                
                    [x]

                    [:cvm.sreq :out x])
                
                
                
                  (defn read
                
                    ^{:doc {:description ["Passes the given string through the Convex Lisp reader and returns a list of forms."
                                          "Those forms can be compiled, evaluated, ..."]
                            :examples    [{:code "(sreq/read \"(+ 2 2)\")"}]
                            :signature   [{:params [string]}]
                            :type        :function}}
                
                    [sym src]
                
                    (assert (str? src))
                    (assert (symbol? sym))
                    [:cvm.sreq :read src])
                

                
                  (defn screen.clear
                
                    ^{:doc {:description ["Clears the screen."
                                          "Useful only if the output is printed in the terminal."]
                            :examples    [{:code "(sreq/clear.screen)"}]
                            :signature   [{:params []}]
                            :type        :function}}
                
                    []

                    [:cvm.sreq :screen.clear])
                
                

                  (defn try
                
                    ^{:doc {:description ["First argument is a sequence of quoted transactions executed one by one until an exception is throw."
                                          "In such case, the exception is defined under `help/*cvm.error*` and optional quoted transactions from the second argument are executed."
                                          "With or without \"catch\" transactions, execution in the main file continues."]
                            :examples    [{:code "(sreq/try '[(def foo 42) (fail \"Oops\")] '[(sreq/out [:error *cvm.error*)])"}]
                            :signature   [{:params [try-trx+ catch-trx+]}]
                            :type        :function}}
                                        
                
                    ([try-trx+]

                     (try try-trx+
                          nil))


                    ([try-trx+ catch-trx+]

                     (assert (or (list? try-trx+)
                                 (vector? try-trx+)))
                     (assert (or (nil? catch-trx+)
                                 (list? catch-trx+)
                                 (vector? catch-trx+)))
                     [:cvm.sreq :try try-trx+ catch-trx+]))
                              
                
                  ))) ;; END - STRX



  (def help
       (deploy '(do

                  (call *registry*
                        (cns-update 'convex.run.help
                                    *address*))


                  (call *registry*
                        (register {:doc  {:description ["Help library for the Convex Lisp Runner."
                                                        "The Runner executes each top-level form as a transaction."
                                                        "This library provides a series of special values named `*xxx*` which hold commonly useful information, such as juice consumption."
                                                        "It also provide the `about` function for printing a description of any account or any symbol defined in an account."
                                                        "For more information, run `(help/about help 'about)`."
                                                        "The Runner is able to understand a series of \"special requests\" which perform commonly useful actions such as outputting values."
                                                        "Those \"special requests\" are merely vectors built using the SReq library."
                                                        "The Help and the SReq libraries are respectively defined in the default account as `help` and `sreq`."]}
                                   :name "Convex Lisp Runner Help and Miscelleneous Utilities"}))


                  (import convex.run.sreq :as sreq)


                  ;; SPECIAL VALUES

                  (def *cycle*

                    ^{:doc {:description ["Starting at 0, is incremented every time the main file is run."
                                          "Potentially useful for watch mode."]}}

                    nil)



                  (def *error*

                    ^{:doc {:description ["Any thrown exception is defined under this symbol."
                                          "Notably useful in try-catch (see `sreq/try`)"]}}

                    nil)



                  (def *file*

                    ^{:doc {:description "Canonical path of the invoked main file."}}

                    nil)



                  (def *juice*

                    ^{:doc {:description "Total amount of juice consumed up to now."}}

                    nil)



                  (def *trx.form*

                    ^{:doc {:description "Form representing the current transaction."}}

                    nil)



                  (def *trx.id*

                    ^{:doc {:description ["Id of the current transaction."
                                          "Starting at 0, is incremented on every transaction."
                                          "Resets on each run in watch mode."]}}

                    nil)



                  (def *trx.last.form*

                    ^{:doc {:description "Like `*trx.form*` but represents the previous transaction."}}

                    nil)



                  (def *trx.last.id*

                    ^{:doc {:description "Like `*trx.id*` but represents the previous transaction."}}

                    nil)



                  (def *trx.last.juice*

                    ^{:doc {:description "Amount of juice consumed by the previous transaction."}}

                    nil)



                  (def *trx.last.result*

                    ^{:doc {:description "Result of the previous transaction."}}

                    nil)


                  ;; FUNCTIONS


                  (defn str-line+

                    ^{:doc {:description ["Returns a unique string which lays out text sections in a way that is easy to read for humans."
                                          "Used by `str-about`"]
                            :examples    [{:code "(str-line+ [[\"My section\" [\"Line 1\" \"Line 2\"]]])"}]
                            :signature   [{:params [section+]}]
                            :type        :function}}

                    [section+]

                    (apply str
                           (reduce (fn [acc [section line+]]
                                     (reduce (fn [acc-2 line]
                                               (conj acc-2
                                                     \newline
                                                     \newline
                                                     line))
                                             (conj acc
                                                   \newline
                                                   \newline
                                                   \newline
                                                   section
                                                   \newline
                                                   (loop [acc []
                                                          i   (count section)]
                                                    (if (> i
                                                           0)
                                                      (recur (conj acc
                                                                   "=")
                                                             (dec i))
                                                      (apply str
                                                             acc))))
                                             line+))
                                   []
                                   section+)))



                  (let [-doc (fn [target meta]
                               (let [doc         (:doc meta)
                                     description (:description doc)
                                     example+    (:examples doc)
                                     signature   (:signature doc)
                                     type        (:type doc)
                                     target-sym  (symbol target)
                                     section+    [["HELP"
                                                   [target]]]
                                     section-2+  (if type
                                                   (conj section+
                                                         ["TYPE"
                                                          [type]])
                                                   section+)
                                     section-3+  (if signature
                                                   (conj section-2+
                                                         ["SIGNATURE"
                                                          (map (fn [sign]
                                                                 (cons target-sym
                                                                       (:params sign)))
                                                               signature)])
                                                   section-2+)
                                     section-4+  (if description
                                                   (conj section-3+
                                                         ["DESCRIPTION"
                                                          (cond
                                                            (str? description)    [description]
                                                            (vector? description) description
                                                            :else                 ["Malformed, description must be a string or a vector or strings."])])
                                                   section-3+)
                                     section-5+  (if example+
                                                   (conj section-4+
                                                         ["EXAMPLES"
                                                          (map :code
                                                               example+)])
                                                   section-4+)]
                                 (str-line+ section-5+)))]

                      (defn str-about

                        ^{:doc {:description ["Using `str-line+`, prepares a string for displaying useful information about an account or a symbol defined in any account."
                                              "Used by `about`"]
                                :examples    [{:code "(help/str-about sreq)"}
                                              {:code "(help/str-about sreq 'out)"}]
                                :signature   [{:params [addr-or-sym]}
                                              {:params [addr sym]}]
                                :type        :function}}

                        ([addr-or-sym]

                         (if (symbol? addr-or-sym)
                           (-doc (str addr-or-sym)
                                 (lookup-meta addr-or-sym))
                           (if-let [acc (account addr-or-sym)]
                             (let [allowance   (acc :allowance)
                                   balance     (acc :balance)
                                   controller  (acc :controller)
                                   env         (acc :environment)
                                   key         (acc :key)
                                   meta        (acc :metadata)
                                   meta-reg    (call *registry*
                                                     (lookup addr-or-sym))
                                   name        (:name meta-reg)
                                   overview    (:description (:doc meta-reg))
                                   section+    [["ACCOUNT"
                                                 [addr-or-sym]]
                                                ["KEY"
                                                 [(or key
                                                      "None (this is an actor)")]]
                                                ["ALLOWANCE"
                                                 [allowance]]
                                                ["BALANCE"
                                                 [balance]]
                                                ["CONTROLLER"
                                                 [(or controller
                                                      "None")]]]
                                  section-2+    (if name
                                                  (conj section+
                                                        ["NAME"
                                                         [name]])
                                                  section+)
                                  section-3+    (if overview
                                                  (conj section-2+
                                                        ["OVERVIEW"
                                                         (if (str? overview)
                                                           [overview]
                                                           overview)])
                                                  section-2+)
                                  section-4+    (if (> (count env)
                                                       0)
                                                  (conj section-3+
                                                        ["ENVIRONMENT (simplified)"
                                                         (reduce (fn [line+ [k _v]]
                                                                   (if-let [desc (get-in meta
                                                                                         [k
                                                                                          :doc
                                                                                          :description])]
                                                                     (conj line+
                                                                           k
                                                                           (str "  "
                                                                                (if (str? desc)
                                                                                  desc
                                                                                  (first desc))))
                                                                     (conj line+
                                                                           k)))
                                                                 []
                                                                 env)])
                                                  section-3+)]
                               (str-line+ section-4+))
                             (str "Account "
                                  addr-of-sym
                                  " does not exist."))))


                        ([addr sym]

                         (-doc (str (address addr)
                                             "/"
                                             sym)
                               (lookup-meta addr
                                            sym)))))



                    (defn about

                      ^{:doc {:description "Prepares a special request for outputting useful information about an account or a symbol defined in any account."
                              :examples    [{:code "(help/str-about sreq)"}
                                            {:code "(help/str-about sreq 'out)"}]
                              :signature   [{:params [addr-or-sym]}
                                            {:params [addr sym]}]
                              :type        :function}}


                      ([addr-or-sym]

                       (sreq/out (str-about addr-or-sym)))


                      ([addr sym]

                       (sreq/out (str-about addr
                                            sym))))


                    )))  ;; End - HELP



  ;; CVM result, needed for easily getting the addresses of the libraries.
  ;;
  [help
   sreq]


  ) ;; END 
