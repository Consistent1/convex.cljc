(cvm.read {xform "src/convex/lib/lab/xform.cvx"
           store "src/convex/lib/lab/xform/store.cvx"})


(cvm.out.clear)



(cvm.out (str "RUN NÂ°"
              (inc *cvm.cycle*)))

(cvm.out)

(cvm.out "OUTPUT:")

(cvm.out)


;(cvm.hook.trx (fn [code]
;               `(cvm.out [:HOOK.trx ~code])))
;
;
;(cvm.hook.out (fn [x]
;                [:HOOK.out x]))



(eval store)




(defn foo [form]

  `(cvm.out [[:trx *cvm.trx.id*] (quote ~form) ~form]))


(defmacro foo* [form]

 (foo form))



(defmacro bar [form]

  (fail :failure))



(cvm.try

  (cvm.out "test")

  (bar (+ 2 2))

  (cvm.out "retest")

  (cvm.catch
    (cvm.out [:catch *cvm.error*])))





(cvm.out (cvm.do 42 21 24))



;(cvm.hook.out nil)
;
;42
;
;(cvm.hook.end
;  (cvm.out "END")
;  (fail :failure)
;  (cvm.out 42))


; (def xform
;      (deploy xform))
; 
; 
; (eval store)
; 
; 
; 
; (defmacro printer
; 
;   [code]
;   
;   `(cvm.do
;      (cvm.do
;        (cvm.out [:trx *cvm.trx.id* ~(:tag (meta code))]))
;      (cvm.do
;        ~code)))
; 
; 
; 
; (cvm.trx.map printer)
; 
; 
; 
; ^{:tag :foo2} 42
; 
; 
; (cvm.trx.map nil)
; 
; [:a :bar]

;(xform/transduce (xform/comp (xform/filter (fn [item]
;                                             (contains-key? (tag+ item)
;                                                            :fruit))))
;                 conj
;                 []
;                 inventory)



; (log :foo :bar)
; 
; (cvm.log l)
; 
; (cvm.out [:log l])


;cvm.juice.last



; (defmacro out-log
; 
;   []
; 
;   `(cvm.do
;      (cvm.log LOG)
;      (cvm.out [:log LOG])
;      (undef LOG)))
; 
; 
; 
; (log :a :b :c)
; 
; 
; (out-log)
