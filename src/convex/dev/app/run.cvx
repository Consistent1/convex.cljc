(cvm.read {xform "src/convex/lib/lab/xform.cvx"
           store "src/convex/lib/lab/xform/store.cvx"})


(cvm.out.clear)


(cvm.out (str "RUN NÂ°"
              (inc *cvm.cycle*)))

(cvm.out)

(cvm.out "OUTPUT:")

(cvm.out)




(eval store)




(defn foo [form]

  `(cvm.out [[:trx *cvm.trx.id*] (quote ~form) ~form]))


(defmacro foo* [form]

 (foo form))




(cvm.try

  (cvm.out "test")

  (+ 2 [])

  (cvm.out "retest")

  (cvm.catch
    (cvm.out [:catch *cvm.error*])))



(cvm.out 42)



; (def xform
;      (deploy xform))
; 
; 
; (eval store)
; 
; 
; 
; (defmacro printer
; 
;   [code]
;   
;   `(cvm.do
;      (cvm.do
;        (cvm.out [:trx *cvm.trx.id* ~(:tag (meta code))]))
;      (cvm.do
;        ~code)))
; 
; 
; 
; (cvm.trx.map printer)
; 
; 
; 
; ^{:tag :foo2} 42
; 
; 
; (cvm.trx.map nil)
; 
; [:a :bar]

;(xform/transduce (xform/comp (xform/filter (fn [item]
;                                             (contains-key? (tag+ item)
;                                                            :fruit))))
;                 conj
;                 []
;                 inventory)



; (log :foo :bar)
; 
; (cvm.log l)
; 
; (cvm.out [:log l])


;cvm.juice.last



; (defmacro out-log
; 
;   []
; 
;   `(cvm.do
;      (cvm.log LOG)
;      (cvm.out [:log LOG])
;      (undef LOG)))
; 
; 
; 
; (log :a :b :c)
; 
; 
; (out-log)
