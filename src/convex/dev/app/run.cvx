;;;;;;;;;; INIIALIZING A RUN





;; Reads those files and binds the unevaluated code to the given symbols using special transaction `cvm.read`
;;
(sreq/dep {xform "src/convex/lib/lab/xform.cvx"
           store "src/convex/lib/lab/xform/store.cvx"})



;; Clears the terminal using special transaction `cvm.out.clear`
;;
(sreq/screen.clear)



(help/about sreq 'advance)


;; Prints nice information at the start of a run using special transaction `cvm.out`
;;
; (cvm.out (str "Run NÂ°" (inc *cvm.cycle*)
;               \newline
;               \newline
;               "OUTPUT:"
;               \newline))


;;;;;;;;;; SPECIAL TRANSACTIONS


;; Special transactions are interpreted by the runner in order to produce useful side-effects.
;;
;; Currently:
;;
;; - `cvm.dep` - Given a map of `symbol` -> `file path`, reads each file and binds the unevaluated code its requested symbol
;; - `cvm.do` - Similar to `do`, executes each form as an individual transaction
;; - `cvm.hook.end` - Executes the given code at the end of a run, even if an error occured
;; - `cvm.hook.error` - When an errors occurs, calls the given function with the error and then executes the returned code (default is outputting with `cvm.out`)
;; - `cvm.hook.out` - On each output, maps the data using the given function (default is `identity`, no alteration)
;; - `cvm.hook.trx` - Before each transaction, uses the given function for mapping transaction code (eg. output the result, do not execute if some metadata, ...)
;; - `cvm.log` - Binds the current state of the CVM log to the given symbol
;; - `cvm.out` - Outputs the given item
;; - `cvm.out.clear` - Clears the screen (useful when output is printing to the terminal)
;; - `cvm.try` - Try-catch mechanism
;;
;; Those special transactions are demonstrated in this file.
;;
;; Since they are "transactions", one CANNOT nest them in regular transactions:
;;
;; (+ 2 (cvm.do 2))
;;
;; However, some special transaction CAN contain other special transaction, for instance:
;;
;; (cvm.do (cvm.out "Hello world"))


;;;;;;;;;; PRODUCING AN OUTPUT


;; Each form is a separate transaction ; each transaction is executed but no output is produced
;;
; 42
; (+ 2 2)
; (first [:a :b :c])


;; Produces an output by wrapping code in the `cvm.out` special transaction
;;
; (cvm.out (+ 2 2))


;;;;;;;;;; HOOKS (code executed at particular moments)


;; Registers code that is executed at the end, no matter if any error occured or not
;;
;(cvm.hook.end
;  (cvm.out "END"))



;; Hook which maps errors to code (default is outputting them)
;;
; (cvm.hook.error (fn [error]
;                   `(cvm.out [:error ~error])))



;; Hook which maps transaction code ; `*cvm.trx.id*` is a special value incremented on each new transaction in this file
;;
; (cvm.hook.trx (fn [trx]
;                 `(cvm.out [:trx *cvm.trx.id* (quote ~trx) ~trx])))



;; Hook which maps what is being output
;;
;(cvm.hook.out (fn [x]
;                [:HOOK.out x]))



;; Removing hooks
;;
; (cvm.hook.end nil)
; (cvm.hook.error nil)
; (cvm.hook.out nil)
; (cvm.hook.trx nil)


;;;;;;;;;; WORKING WITH FILES (read at the beginning of this file in the special transaction `cvm.read`)


;; The store file can be evaluated in place
;;
; (eval (first store))



;; Deploys transducers file as a library
;,
; (def xform
;      (deploy (first xform)))



;; Transducer example ; functions `available?`, `code`, `price`, and `tag+` were defined in the evaluated "store" file
;;
; (cvm.out [:query-veggies
;           (xform/transduce ;; Processing, composition of "transducers" which filter and map items
;                            (comp (xform/filter (fn [item]
;                                                  (contains-key? (tag+ item)
;                                                                 :fruit)))
;                                  (xform/filter (fn [item]
;                                                  (< (price item)
;                                                     600)))
;                                  (xform/filter available?)
;                                  (xform/map code)
;                                  )
;                            ;; Output, each item that survives processing is `conj`ed to the given vector (empty at the beginning)
;                            conj
;                            []
;                            ;; Input, declared in the "store" file, a vector where an item is a fruit or vegetable with a price, some quantity, tags, ...
;                            inventory)])


;;;;;;;;; BUILDING ABSTRACTIONS


;; Simple special transaction which in turn run each given form as a separate transaction
;;
; (cvm.do
;   (cvm.out "First")
;   (cvm.out "Second"))



;; Each new transaction is always expanded prior to checking if it is a special one or not.
;; This means that abstraction can be built using regular macros.

;; Macro for tracing a transaction (produces a nice output of what happens)
;;
; (defmacro trace
;  
;   [trx]
; 
;   `(cvm.do
;      (cvm.out "===")
;      (cvm.out \newline)
;      (cvm.out (str "TRANSACTION: "
;                    (quote ~trx)))
;      (cvm.out \newline)
;      (cvm.out (str "RESULT: "
;                    ~trx))
;      (cvm.out \newline)
;      (cvm.out "===")))



; (trace (+ 2 2))


;;;;;;;;;; TRY-CATCH


;; Special transaction where each form is run as an individual transaction.
;; `(+ 2 [])` thows an exception, hence execution stops.
;; Last form is a special transaction `cvm.catch` which is evaluated when an error is indeed catched ; error is then accessible under `*cvm.error*`
;;
; (cvm.try
; 
;   (cvm.out "Try 1")
; 
;   (+ 2 [])
; 
;   (cvm.out "Try 2")
; 
;   (cvm.catch
;     (cvm.out [:catch *cvm.error*])))


;;;;;;;;;; ACCESSING THE CVM LOG


;; Using the standard `log` function
;;
; (log [:a :b :c])


;; Interns the CVM log under the given `LOG` symbol
;;
; (cvm.log LOG)


; (cvm.out [:my-log (get LOG
;                        *address*)])
