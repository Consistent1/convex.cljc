;;
;;
;; Help library for the Convex Lisp Runner offering a series of values dynamically set by the runner (eg. `env/*error*` when a CVM error occurs) and the `about`
;; function for navigating documentation metadata.
;;
;;


(call *registry*
      (cns-update 'convex.run
                  *address*))


(call *registry*
      (register {:doc  {:description ["Help library for the Convex Lisp Runner."
                                      "Provides a series of special values named `*xxx*` which hold commonly useful information, such as juice consumption."
                                      "Also provides the `about` function for printing a description of any account or any symbol defined in any account."
                                      "For more information, evalute `(env/about env 'about)`."]}
                 :name "Convex Lisp Runner Help and Miscelleneous Utilities"}))


(def self

  ^{:doc {:description ""}}

  *address*)


;;;;;;;;;; STATIC VALUES


(def line

  ^{:doc {:description ""}}

  ;; Set by runner at startup.

  nil)


;;;;;;;;;; DYNAMIC VALUES


(def *catch*

  ^{:doc {:description ""}}

  '())


(def *cycle*

  ^{:doc {:description ["Starting at 0, is incremented every time the main file is run."
                        "Potentially useful for watch mode."]}}

  nil)



(def *error*

  ^{:doc {:description ["Any thrown exception is defined under this symbol."
                        "Notably useful in try-catch (see `sreq/try`)"]}}

  nil)



(def *main?*

  ^{:doc {:description ""}}

  false)



(def *file*

  ^{:doc {:description "Canonical path of the invoked main file."}}

  nil)



(def *result*

  ^{:doc {:description "Result of the previous transaction."}}

  nil)



(def *watch?*

  ^{:doc {:description ""}}

  false)


;;;;;;;;;; SETTING SOME DYNAMIC VALUES


(defn catch.pop

  ^{:doc {:description ""}}

  []

  (if (= *address*
         self)
    (def *catch*
         (or (next *catch*)
             '()))
    (call self
          (catch.pop))))


(export catch.pop)



(defn catch.push

  ^{:doc {:description ""}}

  [trx]

  (if (= *address*
         self)
    (def *catch*
         (conj *catch*
               trx))
    (call self
          (catch.push trx))))


(export catch.push)


;;;;;;;;;; MISCELLANEOUS HELPERS


(def fake-key

  ^{:doc {:description "Fake key for turning an actor into a user account with standard `set-key`."}}

  0x0000000000000000000000000000000000000000000000000000000000000000)



(defmacro zombie

  ^{:doc {:description "Wraps forms into deploy code which turns the actor into a user account with `fake-key` and make it controllable with `eval-as`."
          :examples    [{:code "(def a (env/zombie (def foo 42)))"}]
          :type        :macro}}

  [& form+]

  `(deploy '(do
              (set-controller ~*address*)
              (set-key ~fake-key)
              ~(cons 'do
                     form+))))


;;;;;;;;;; PRINTING


(defn str-line+

  ^{:doc {:description ["Returns a unique string which lays out text sections in a way that is easy to read for humans."
                        "Used by `str-about`"]
          :examples    [{:code "(str-line+ [[\"My section\" [\"Line 1\" \"Line 2\"]]])"}]
          :signature   [{:params [section+]}]
          :type        :function}}

  [section+]

  (apply str
         (reduce (fn [acc [section line+]]
                   (reduce (fn [acc-2 pr-line]
                             (conj acc-2
                                   line
                                   line
                                   pr-line))
                           (conj acc
                                 line
                                 line
                                 line
                                 section
                                 line
                                 (loop [acc []
                                        i   (count section)]
                                  (if (> i
                                         0)
                                    (recur (conj acc
                                                 "=")
                                           (dec i))
                                    (apply str
                                           acc))))
                           line+))
                 []
                 section+)))



(let [-doc (fn [target meta]
             (let [doc         (:doc meta)
                   description (:description doc)
                   example+    (:examples doc)
                   signature   (:signature doc)
                   type        (:type doc)
                   target-sym  (symbol target)
                   section+    [["HELP"
                                 [target]]]
                   section-2+  (if type
                                 (conj section+
                                       ["TYPE"
                                        [type]])
                                 section+)
                   section-3+  (if signature
                                 (conj section-2+
                                       ["SIGNATURE"
                                        (map (fn [sign]
                                               (cons target-sym
                                                     (:params sign)))
                                             signature)])
                                 section-2+)
                   section-4+  (if description
                                 (conj section-3+
                                       ["DESCRIPTION"
                                        (cond
                                          (str? description)    [description]
                                          (vector? description) description
                                          :else                 ["Malformed, description must be a string or a vector or strings."])])
                                 section-3+)
                   section-5+  (if example+
                                 (conj section-4+
                                       ["EXAMPLES"
                                        (map :code
                                             example+)])
                                 section-4+)]
               (str-line+ section-5+)))]

    (defn str-about

      ^{:doc {:description ["Using `str-line+`, prepares a string for displaying useful information about an account or a symbol defined in any account."
                            "Used by `about`"]
              :examples    [{:code "(env/str-about sreq)"}
                            {:code "(env/str-about sreq 'out)"}]
              :signature   [{:params [addr-or-sym]}
                            {:params [addr sym]}]
              :type        :function}}

      ([addr-or-sym]

       (if (symbol? addr-or-sym)
         (-doc (str addr-or-sym)
               (lookup-meta addr-or-sym))
         (if-let [acc (account addr-or-sym)]
           (let [allowance   (acc :allowance)
                 balance     (acc :balance)
                 controller  (acc :controller)
                 env         (acc :environment)
                 key         (acc :key)
                 meta        (acc :metadata)
                 meta-reg    (call *registry*
                                   (lookup addr-or-sym))
                 name        (:name meta-reg)
                 overview    (:description (:doc meta-reg))
                 section+    [["ACCOUNT"
                               [addr-or-sym]]
                              ["KEY"
                               [(or key
                                    "None (this is an actor)")]]
                              ["ALLOWANCE"
                               [allowance]]
                              ["BALANCE"
                               [balance]]
                              ["CONTROLLER"
                               [(or controller
                                    "None")]]]
                section-2+    (if name
                                (conj section+
                                      ["NAME"
                                       [name]])
                                section+)
                section-3+    (if overview
                                (conj section-2+
                                      ["OVERVIEW"
                                       (if (str? overview)
                                         [overview]
                                         overview)])
                                section-2+)
                section-4+    (if (> (count env)
                                     0)
                                (conj section-3+
                                      ["ENVIRONMENT (simplified)"
                                       (reduce (fn [line+ [k _v]]
                                                 (if-let [desc (get-in meta
                                                                       [k
                                                                        :doc
                                                                        :description])]
                                                   (conj line+
                                                         k
                                                         (str "  "
                                                              (if (str? desc)
                                                                desc
                                                                (first desc))))
                                                   (conj line+
                                                         k)))
                                               []
                                               env)])
                                section-3+)]
             (str-line+ section-4+))
           (str "Account "
                addr-of-sym
                " does not exist."))))


      ([addr sym]

       (-doc (str (address addr)
                           "/"
                           sym)
             (lookup-meta addr
                          sym)))))



  (defn about

    ^{:doc {:description ["Prepares a special request for outputting useful information about an account or a symbol defined in any account."
                          "Note: if present, the environment description is simplified one. More information about each symbol can be queried."]
            :examples    [{:code "(env/str sreq)"}
                          {:code "(env/str sreq 'out)"}]
            :signature   [{:params [addr-or-sym]}
                          {:params [addr sym]}]
            :type        :function}}


    ([addr-or-sym]

     (sreq/out! (str-about addr-or-sym)))


    ([addr sym]

     (sreq/out! (str-about addr
                           sym))))







;;;;;;;;;;


(defn dep

  ^{:doc {:description ["Loads Convex Lisp dependency files. During watch mode, those files are live-reloaded as well."
                        "If used, MUST be written as the very first transaction found in the main file."
                        "Takes a map of `symbol` -> `path to file`. Files are read as lists of Convex Lisp forms and then defined under their corresponding symbol."
                        "Then, those forms can be used as needed. It is common to use `deploy` or `eval`, depending on the purpose of a given file."]
          :examples    [{:code "(sreq/dep {'my-lib \"path/to/lib.cvx\"})"}]
          :signature   [{:params [sym->file]}]
          :type        :function}}

  [sym->file]

  (assert (not "First transaction")))



(defn log

  ^{:doc {:description ["Retrieves the current CVM log."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/do '[(log :foo) (sreq/log l) (sreq/out l))"}]
          :signature   [{:params []}]
          :type        :function}}

  []

  [:cvm.sreq :log])



(defn main

  ^{:doc {:description ""}}

  [path]

  (if *main?*
    (fail :STATE
          "Main file already loaded")
    [:cvm.sreq :main path]))



(defn main.watch

  ^{:doc {:description ""}}

  [path]

  (if *main?*
    (fail :STATE
          "Main file already loaded")
    [:cvm.sreq :main.watch path]))



(defn monitor

  ^{:doc {:description ""}}

  [trx]

  [:cvm.sreq :monitor trx])



(defn read+

  ^{:doc {:description ["Passes the given string through the CVX reader and produces a list of cells."
                        "Those cells can be compiled, evaluated, ..."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/read+ \"(+ 2 2)\")"}]
          :signature   [{:params [string]}]
          :type        :function}}

  [src]

  (assert (str? src))
  [:cvm.sreq :read+ src])
