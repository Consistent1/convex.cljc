;;
;;
;; Help library for the Convex Lisp Runner offering a series of values dynamically set by the runner (eg. `env/*error*` when a CVM error occurs) and the `about`
;; function for navigating documentation metadata.
;;
;;


(call *registry*
      (cns-update 'convex.run
                  *address*))


(call *registry*
      (register {:doc  {:description ["Help library for the Convex Lisp Runner."
                                      "Provides a series of special values named `*xxx*` which hold commonly useful information, such as juice consumption."
                                      "Also provides the `about` function for printing a description of any account or any symbol defined in any account."
                                      "For more information, evalute `(env/about env 'about)`."]}
                 :name "Convex Lisp Runner Help and Miscelleneous Utilities"}))


;;;;;;;;;;


(def $.stream

  ^{:doc      {:description ""}
    :private? true}

  (call *registry*
        (cns-resolve 'convex.run.stream)))



(def self

  ^{:doc {:description ""}}

  *address*)


;;;;;;;;;; Static values set by the runner


(def line

  ^{:doc {:description ""}}


  nil)



(def version

  ^{:doc {:description ""}}

  nil)


;;;;;;;;;; DYNAMIC VALUES


(def *result*

  ^{:doc {:description "Result of the previous transaction."}}

  nil)


;;;;;;;;;; MISCELLANEOUS HELPERS


(def fake-key

  ^{:doc {:description "Fake key for turning an actor into a user account with standard `set-key`."}}

  0x0000000000000000000000000000000000000000000000000000000000000000)



(defmacro zombie

  ^{:doc {:description "Wraps forms into deploy code which turns the actor into a user account with `fake-key` and make it controllable with `eval-as`."
          :examples    [{:code "(def a (env/zombie (def foo 42)))"}]
          :type        :macro}}

  [& form+]

  `(deploy '(do
              (set-controller ~*address*)
              (set-key ~fake-key)
              ~(cons 'do
                     form+))))


;;;;;;;;;; Getting help


(defmacro help

  ^{:doc {:description ""}}


  ([]

   '($.help/main))


  ([addr-or-sym]

   (if (and (list? addr-or-sym)
            (= (count addr-or-sym)
               3)
            (= (first addr-of-sym)
               'lookup))
     `($.help/symbol ~(nth addr-or-sym
                           1)
                     (quote ~(nth addr-or-sym
                                  2)))
     `(let [x ~addr-or-sym]
        (if (address? x)
          ($.help/address x)
          ($.help/symbol (quote ~addr-or-sym)))))))


;;;;;;;;;;


(defn log

  ^{:doc {:description ["Retrieves the current CVM log."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/do '[(log :foo) (sreq/log l) (sreq/out l))"}]
          :signature   [{:params []}]
          :type        :function}}

  []

  [:cvm.sreq :log])



(defn monitor

  ^{:doc {:description ""}}

  [trx]

  [:cvm.sreq :monitor trx])



(defn read+

  ^{:doc {:description ["Passes the given string through the CVX reader and produces a list of cells."
                        "Those cells can be compiled, evaluated, ..."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/read+ \"(+ 2 2)\")"}]
          :signature   [{:params [string]}]
          :type        :function}}

  [src]

  (assert (str? src))
  [:cvm.sreq :read+ src])
