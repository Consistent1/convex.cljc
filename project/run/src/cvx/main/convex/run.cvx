;;
;;
;; Help library for the Convex Lisp Runner offering a series of values dynamically set by the runner (eg. `env/*error*` when a CVM error occurs) and the `about`
;; function for navigating documentation metadata.
;;
;;


(call *registry*
      (cns-update 'convex.run
                  *address*))


(call *registry*
      (register {:doc  {:description ["Help library for the Convex Lisp Runner."
                                      "Provides a series of special values named `*xxx*` which hold commonly useful information, such as juice consumption."
                                      "Also provides the `about` function for printing a description of any account or any symbol defined in any account."
                                      "For more information, evalute `(env/about env 'about)`."]}
                 :name "Convex Lisp Runner Help and Miscelleneous Utilities"}))


(def self

  ^{:doc {:description ""}}

  *address*)



(def sreq

 ^{:doc {:description "Alias to the SReq library."}}

 (call *registry*
       (cns-resolve 'convex.run.sreq)))


;;;;;;;;;; STATIC VALUES


(def line

  ^{:doc {:description ""}}

  ;; Set by runner at startup.

  nil)


;;;;;;;;;; DYNAMIC VALUES


(def *catch*

  ^{:doc {:description ""}}

  '())


(def *cycle*

  ^{:doc {:description ["Starting at 0, is incremented every time the main file is run."
                        "Potentially useful for watch mode."]}}

  nil)



(def *error*

  ^{:doc {:description ["Any thrown exception is defined under this symbol."
                        "Notably useful in try-catch (see `sreq/try`)"]}}

  nil)



(def *main?*

  ^{:doc {:description ""}}

  false)



(def *file*

  ^{:doc {:description "Canonical path of the invoked main file."}}

  nil)



(def *hook.end*

  ^{:doc {:description ""}}

  nil)



(def *result*

  ^{:doc {:description "Result of the previous transaction."}}

  nil)



(def *watch?*

  ^{:doc {:description ""}}

  false)


;;;;;;;;;; SETTING SOME DYNAMIC VALUES


(defn set.hook.end

  ^{:doc {:description ""}}

  [trx]

  (if (= *address*
         self)
    (def *hook.end*
         trx)
    (call self
          (set.hook.end trx))))


(export set.hook.end)


(defn catch.pop

  ^{:doc {:description ""}}

  []

  (if (= *address*
         self)
    (def *catch*
         (or (next *catch*)
             '()))
    (call self
          (catch.pop))))


(export catch.pop)



(defn catch.push

  ^{:doc {:description ""}}

  [trx]

  (if (= *address*
         self)
    (def *catch*
         (conj *catch*
               trx))
    (call self
          (catch.push trx))))


(export catch.push)


;;;;;;;;;; MISCELLANEOUS HELPERS


(def fake-key

  ^{:doc {:description "Fake key for turning an actor into a user account with standard `set-key`."}}

  0x0000000000000000000000000000000000000000000000000000000000000000)



(defmacro zombie

  ^{:doc {:description "Wraps forms into deploy code which turns the actor into a user account with `fake-key` and make it controllable with `eval-as`."
          :examples    [{:code "(def a (env/zombie (def foo 42)))"}]
          :type        :macro}}

  [& form+]

  `(deploy '(do
              (set-controller ~*address*)
              (set-key ~fake-key)
              ~(cons 'do
                     form+))))


;;;;;;;;;; PRINTING


(defn str-line+

  ^{:doc {:description ["Returns a unique string which lays out text sections in a way that is easy to read for humans."
                        "Used by `str-about`"]
          :examples    [{:code "(str-line+ [[\"My section\" [\"Line 1\" \"Line 2\"]]])"}]
          :signature   [{:params [section+]}]
          :type        :function}}

  [section+]

  (apply str
         (reduce (fn [acc [section line+]]
                   (reduce (fn [acc-2 pr-line]
                             (conj acc-2
                                   line
                                   line
                                   pr-line))
                           (conj acc
                                 line
                                 line
                                 line
                                 section
                                 line
                                 (loop [acc []
                                        i   (count section)]
                                  (if (> i
                                         0)
                                    (recur (conj acc
                                                 "=")
                                           (dec i))
                                    (apply str
                                           acc))))
                           line+))
                 []
                 section+)))



(let [-doc (fn [target meta]
             (let [doc         (:doc meta)
                   description (:description doc)
                   example+    (:examples doc)
                   signature   (:signature doc)
                   type        (:type doc)
                   target-sym  (symbol target)
                   section+    [["HELP"
                                 [target]]]
                   section-2+  (if type
                                 (conj section+
                                       ["TYPE"
                                        [type]])
                                 section+)
                   section-3+  (if signature
                                 (conj section-2+
                                       ["SIGNATURE"
                                        (map (fn [sign]
                                               (cons target-sym
                                                     (:params sign)))
                                             signature)])
                                 section-2+)
                   section-4+  (if description
                                 (conj section-3+
                                       ["DESCRIPTION"
                                        (cond
                                          (str? description)    [description]
                                          (vector? description) description
                                          :else                 ["Malformed, description must be a string or a vector or strings."])])
                                 section-3+)
                   section-5+  (if example+
                                 (conj section-4+
                                       ["EXAMPLES"
                                        (map :code
                                             example+)])
                                 section-4+)]
               (str-line+ section-5+)))]

    (defn str-about

      ^{:doc {:description ["Using `str-line+`, prepares a string for displaying useful information about an account or a symbol defined in any account."
                            "Used by `about`"]
              :examples    [{:code "(env/str-about sreq)"}
                            {:code "(env/str-about sreq 'out)"}]
              :signature   [{:params [addr-or-sym]}
                            {:params [addr sym]}]
              :type        :function}}

      ([addr-or-sym]

       (if (symbol? addr-or-sym)
         (-doc (str addr-or-sym)
               (lookup-meta addr-or-sym))
         (if-let [acc (account addr-or-sym)]
           (let [allowance   (acc :allowance)
                 balance     (acc :balance)
                 controller  (acc :controller)
                 env         (acc :environment)
                 key         (acc :key)
                 meta        (acc :metadata)
                 meta-reg    (call *registry*
                                   (lookup addr-or-sym))
                 name        (:name meta-reg)
                 overview    (:description (:doc meta-reg))
                 section+    [["ACCOUNT"
                               [addr-or-sym]]
                              ["KEY"
                               [(or key
                                    "None (this is an actor)")]]
                              ["ALLOWANCE"
                               [allowance]]
                              ["BALANCE"
                               [balance]]
                              ["CONTROLLER"
                               [(or controller
                                    "None")]]]
                section-2+    (if name
                                (conj section+
                                      ["NAME"
                                       [name]])
                                section+)
                section-3+    (if overview
                                (conj section-2+
                                      ["OVERVIEW"
                                       (if (str? overview)
                                         [overview]
                                         overview)])
                                section-2+)
                section-4+    (if (> (count env)
                                     0)
                                (conj section-3+
                                      ["ENVIRONMENT (simplified)"
                                       (reduce (fn [line+ [k _v]]
                                                 (if-let [desc (get-in meta
                                                                       [k
                                                                        :doc
                                                                        :description])]
                                                   (conj line+
                                                         k
                                                         (str "  "
                                                              (if (str? desc)
                                                                desc
                                                                (first desc))))
                                                   (conj line+
                                                         k)))
                                               []
                                               env)])
                                section-3+)]
             (str-line+ section-4+))
           (str "Account "
                addr-of-sym
                " does not exist."))))


      ([addr sym]

       (-doc (str (address addr)
                           "/"
                           sym)
             (lookup-meta addr
                          sym)))))



  (defn about

    ^{:doc {:description ["Prepares a special request for outputting useful information about an account or a symbol defined in any account."
                          "Note: if present, the environment description is simplified one. More information about each symbol can be queried."]
            :examples    [{:code "(env/str sreq)"}
                          {:code "(env/str sreq 'out)"}]
            :signature   [{:params [addr-or-sym]}
                          {:params [addr sym]}]
            :type        :function}}


    ([addr-or-sym]

     (sreq/out! (str-about addr-or-sym)))


    ([addr sym]

     (sreq/out! (str-about addr
                           sym))))







;;;;;;;;;;


(defn dep

  ^{:doc {:description ["Loads Convex Lisp dependency files. During watch mode, those files are live-reloaded as well."
                        "If used, MUST be written as the very first transaction found in the main file."
                        "Takes a map of `symbol` -> `path to file`. Files are read as lists of Convex Lisp forms and then defined under their corresponding symbol."
                        "Then, those forms can be used as needed. It is common to use `deploy` or `eval`, depending on the purpose of a given file."]
          :examples    [{:code "(sreq/dep {'my-lib \"path/to/lib.cvx\"})"}]
          :signature   [{:params [sym->file]}]
          :type        :function}}

  [sym->file]

  (assert (not "First transaction")))



(defn do

  ^{:doc {:description ["Given a sequence of quoted transactions, executes them one by one."
                        "Useful when composing special requests in some way."]
          :examples    [{:code "(sreq/do '[(def foo 42) (sreq/out foo)])"}]
          :signature   [{:params [trx+]}]
          :type        :function}}

  [trx+]

  (assert (or (list? trx+)
              (vector? trx+)))
  [:cvm.sreq :do trx+])



(defn file.in

  ^{:doc {:description ""}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.in path])



(defn file.out

  ^{:doc {:description ""}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.out path])



;; Currently expects exactly one input form.
;; Too tricky to use.
;
; (defn in
; 
;   ^{:doc {:description ["Reads a cell form from input."
;                         "Currently fails if streams contains more than one input."
;                         "See `out.bin`."]}}
; 
; 
;   ([]
; 
;    (in *in*))
; 
; 
;   ([stream]
; 
;    [:cvm.sreq :in stream]))



(defn log

  ^{:doc {:description ["Retrieves the current CVM log."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/do '[(log :foo) (sreq/log l) (sreq/out l))"}]
          :signature   [{:params []}]
          :type        :function}}

  []

  [:cvm.sreq :log])



(defn main

  ^{:doc {:description ""}}

  [path]

  (if *main?*
    (fail :STATE
          "Main file already loaded")
    [:cvm.sreq :main path]))



(defn main.watch

  ^{:doc {:description ""}}

  [path]

  (if *main?*
    (fail :STATE
          "Main file already loaded")
    [:cvm.sreq :main.watch path]))




(defn monitor

  ^{:doc {:description ""}}

  [trx]

  [:cvm.sreq :monitor trx])



(defn process.env

  ^{:doc {:description ["Retrieves environment variable from the current process. Useful when some information must be passed to the runner from the outside."
                        "When a env variable is given as well, defines only the value for that variable"
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/env}"}
                        {:code "(sreq/env \"MY_X\")"}]
          :signature   [{:params [sym]}
                        {:params [sym env-var]}]
          :type        :function}}


  ([]

   (process.env nil))


  ([env-var]

   (assert (or (str? env-var)
               (nil? env-var)))
   [:cvm.sreq :process.env env-var]))



(defn process.exit

  ^{:doc {:description ["Stops execution and exits process with given `status` code (a long)."
                        "Depending on the operating system, by convention, a non-zero value means an error occured."]
          :examples    [{:code "(sreq/exit 42)"}]
          :signature   [{:params [status]}]
          :type        :function}}

  [status]

  (assert (long? status))
  [:cvm.sreq :exit status])



(defn read+

  ^{:doc {:description ["Passes the given string through the CVX reader and produces a list of cells."
                        "Those cells can be compiled, evaluated, ..."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/read+ \"(+ 2 2)\")"}]
          :signature   [{:params [string]}]
          :type        :function}}

  [src]

  (assert (str? src))
  [:cvm.sreq :read+ src])
