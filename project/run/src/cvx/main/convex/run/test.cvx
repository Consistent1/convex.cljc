;;
;;
;; Unit testing library for the Convex Lisp Runner
;;
;; Provides a simple but flexible framework where a test assertion is a transaction.
;;
;;


;; REGISTERING THE LIBRARY


(call *registry*
      (cns-update 'convex.run.test
                  *address*))

(call *registry*
      (register {:doc  {:description "Unit testing library for the Convex Lisp Runner."}
                 :name "Convex Liser Runner Unit Testing"}))


;; IMPORTING OTHER LIBRARIES


(def $

  ^{:doc {:description ""}}

  (call *registry*
        (cns-resolve 'convex.run)))



(def $.catch

  ^{:doc {:description ""}}

  (call *registry*
        (cns-resolve 'convex.run.catch)))



(def $.process

  ^{:doc {:description ""}}

  (call *registry*
        (cns-resolve 'convex.run.process)))



(def $.time

  ^{:doc {:description ""}}

  (call *registry*
        (cns-resolve 'convex.run.time)))



(def $.trx

  ^{:doc      {:description ""}
    :private? true}

  (call *registry*
        (cns-resolve 'convex.run.trx)))


;; STATIC VALUES


(def self

  ^{:doc {:description "Reference to this library's address."}}

  *address*)


;; ALTERING TEST REPORTS


(def *n-fail*

  ^{:doc {:description "Number of currently failed tests."}}

  0)


(def *report+*

  ^{:doc {:description ["Vector of currently collected test reports."
                        "Also see `conj-report`"]}}

  [])



(defn report.clear

  ^{:doc {:description ["Erases all test reports."
                        "Used internally by `state.push`."
                        "See `*report+*`."]}}

  []

  (if (= *address*
         self)
    (do
      (def *n-fail*
           0)
      (def *report+*
           []))
    (call self
          (report.clear)))
  nil)


(export report.clear)



(defn report.conj

  ^{:doc {:description ["Low-level function for adding a new report to the `state` symbol."
                        "A report summarizes a test assertion."
                        "If strictly required, study the `fail` and `trx` symbols which rely on this function."]}}

  [report]

  (if (= *address*
         self)
     (do
       (when-not (:pass? report)
         (def *n-fail*
              (inc *n-fail*)))
       (def *report+*
            (conj *report+*
                  (assoc report
                         :metadata
                         (assoc (:metadata report)
                                :path
                                *path*)))))
    (call self
          (report.conj report))))



(export report.conj)



(defn report.merge

  ^{:doc {:description ["Merges the given argument into `*n-fail*` and `*report+*`."
                        "Used by `state.pop` for remembering tests reults after restoring previous state."]}}

  [n-fail report+]

  (if (= *address*
         self)
    (do
      (def *n-fail*
           (+ *n-fail*
              n-fail))
      (def *report+*
           (concat *report+*
                   report+)))
    (call self
          (report.merge n-fail
                        report+))))


(export report.merge)


;; FILTERING TESTS


(def *filter*

  ^{:doc {:description ["User defined function for filtering tests based on their metadata."
                        "See `filter.set`."]}}

  nil)



(defn filter.allow?

  ^{:doc {:description ["Returns a boolean indicating if a test should be executed based on its metadata."
                        "See `*filter*`."]}}

  [metadata]

  (if *filter*
    (*filter* metadata)
    true))



(defn filter.set

  ^{:doc {:description ["Sets `*filter*`."
                        "Function must take metadata and return nil or false if test must be ignored."
                        "Providing nil removes current filter."]}}

  [f]

  (if (= *address*
        self)
    (do
      (assert (or (fn? f)
                  (nil? f)))
      (def *filter*
           f))
    (call self
          (filter.set f))))


(export filter.set)


;; DEFAULT METADATA


(def *meta*

  ^{:doc {:description ["User defined function for altering metadata."
                        "Altering happens before filtering. See `*filter*`."
                        "See `meta.set`."]}}

  nil)



(defn meta.map

  ^{:doc {:description "Maps `metadata` using `*meta*` if it is set to a function."}}

  [metadata]

  (if *meta*
    (*meta* metadata)
    metadata))



(defn meta.set

  ^{:doc {:description ["Sets `*meta*`."
                        "Function must takes metadata and returns new metadata."]}}

  [f]

  (if (= *address*
         self)
    (do
      (assert (or (fn? f)
                  (nil? f)))
      (def *meta*
           f))
    (call self
          (meta.set f))))


(export meta.set)


;; PATH


(def *path*

  ^{:doc {:description ["Vector of arbitrary values that helps locating a particular result."
                        "Current value is attach to test report under `:path` in `:metadata`."
                        "Item is added using `path.conj`."]}}

  [])



(defn path.conj

  ^{:doc {:description "Adds an arbitrary item to `*path*`."}}

  [item]

  (if (= *address*
         self)
    (def *path*
         (conj *path*
               item))
    (call self
          (path.conj item))))


(export path.conj)


;; CVM STATE ISOLATION


(defn group

  ^{:doc {:description ["Encloses given quoted transactions between `state.push` and `state.pop`."
                        "Optional `trx-pop` is an additional transaction executed on pop."]}}


  ([trx+]

   (group trx+
          nil))


  ([trx+ trx-pop]

   ($.trx/precat (cons (list state.push)
                       (conj trx+
                             (list state.pop
                                   trx-pop))))))



(defn state.pop

  ^{:doc {:description ["Like `(sreq/state.pop)` but ensures tests results are remembered."
                        "See function `state.push`."
                        "An additional quoted `trx` can be passed to transfer other user data."]}}


  ([]

   (state.pop nil))


  ([trx]

   ($.time/pop `($.trx/precat '((~self/report.merge ~self/*n-fail*
                                                    (quote ~self/*report+*))
                                ~trx)))))



(defn state.push

  ^{:doc {:description ["Like `(sreq/state.push)` but clears the test state from this actor."
                        "Later, CVM state can be restored with function `state.pop`."
                        "Provides isolation, side-effects can be discarded in a controlled fashion."]}}

  []

  ($.trx/precat `((~$.time/push)
                  (~self/report.clear))))


;; TESTING TRANSACTIONS


(defn fail

  ^{:doc {:description ["Tests that the given `trx` quoted transaction throws an exception."
                        "If no exception is throw, test fails."
                        "If an exception is thrown, it is passed to the `expected-fail?` function."
                        "Returning true means the exception was as expected, meaning test passes."
                        "Most of the time, the `fail-code` function will be used rather than this one."
                        "See the `trx` symbol from this library for metadata and how exection is done."]}}


  ([expected-fail? trx]

   (fail expected-fail?
         trx
         nil))


  ([expected-fail? trx metadata]

   (let [metadata-2 (meta.map metadata)]
     (when (filter.allow? metadata-2)
       (let [base-report {:expect   :exception
                          :metadata metadata-2
                          :trx      (list 'quote
                                          trx)}]
         ($.catch/safe `(let [result ~trx]
                          (~self/report.conj (assoc ~base-report
                                                    :result result
                                                    :passe? false)))
                       `(~self/report.conj (assoc ~base-report
                                                  :exception $/*result*
                                                  :pass?     (~expected-fail? $/*result*)))))))))



(defn fail-code

  ^{:doc {:description ["Like the `fail` function but `expected-code?` receives the exception's code."
                        "A convenient solution is to use a set of expected codes."]
          :examples    [{:code "(fail-code #{:ASSERT} '(assert (< 42 3)))"}]}}

  ([code-target trx]

   (fail-code code-target
              trx
              nil))


  ([code-target trx metadata]

   (fail (fn [ex]
           (code-target (ex :code)))
         trx
         (assoc metadata
                :code-target
                code-target))))


(defn trx

  ^{:doc {:description ["Tests that the given transaction (a quoted form) return exactly true."
                        "Any other value means the transaction failed."
                        "Result is reported using `conj-report`."
                        "Metadata is an arbitrary map associated under `:metadata` in the report for providing extra information."
                        "It is advised to provide at least `:description`, a human-readable string explaining the test."]
          :examples    [{:code "(trx '(< 2 3) {:description \"Two should be lesser than three.\"})"}]}}


  ([trx]

   (self/trx trx
             nil))


  ([trx metadata]

   (let [metadata-2 (meta.map metadata)]
     (when (filter.allow? metadata-2)
       (let [base-report {:expect   :result
                          :metadata metadata-2
                          :trx      (list 'quote
                                          trx)}]
         ($.catch/safe `(let [result ~trx]
                          (~self/report.conj (assoc ~base-report
                                                    :result result
                                                    :pass?  (= result
                                                               true))))
                       `(~self/report.conj (assoc ~base-report
                                                  :exception $/*result*
                                                  :pass?     false))))))))


;; TRACING


(defmacro is

  ^{:doc {:description "Macro for tracing the given `form`: it it does not return true, result is returned as well as arguments (assumes `form` is a function call)."}}

  [form]

  (let [n-arg (dec (count form))]
    (if (> n-arg
           0)
      `(let [arg+ ~(vec (next form))
             res  (apply ~(first form)
                         arg+)]
         (or (= res
                true)
             (list '=
                   res
                   (cons (quote ~(first form))
                         arg+))))
      form)))


;; REPORTING


(defn exit

  ^{:doc {:description ["Returns an 'exit' special request to terminate the process."
                        "A non-zero status code is issued in case not all tests pass."
                        "Meant to be used at the end of the run indicating failure or success."]}}

  []

  ($.process/exit (if (> *n-fail*
                         0)
                    42
                    0)))



(defn print-failed

  ^{:doc {:description ["Returns an 'out' special requestion which outputs failed tests in human-readable format."
                        "Prints each failed transaction, why, and its `:description` from `:metadata`."]}}


  ([]

   (print-failed *n-fail*
                 *report+*))


  ([n-fail report+]

   (sreq/out! (apply str
                     "Number of failed tests: "
                     n-fail
                     " / "
                     (count report+)
                     (when (> n-fail
                            0)
                      (reduce (fn [acc report]
                                 (if (:pass? report)
                                   acc
                                  (let [metadata (report :metadata)
                                        ex       (dissoc (report :exception)
                                                         :trx)
                                        res      (report :result)
                                        res?     (contains-key? report
                                                                :result)
                                        [text
                                         data]   (if (= (report :expect)
                                                        :result)
                                                   (if res?
                                                     ["Returned: "
                                                      res]
                                                     ["Threw: "
                                                      ex])
                                                   (if res?
                                                     ["Instead of exception: "
                                                      res]
                                                     ["Not predicted exception: "
                                                      ex]))]
                                    (conj acc
                                          "---"
                                          $/line
                                          $/line
                                          (report :trx)
                                          $/line
                                          $/line
                                          "  "
                                          text
                                          data
                                          $/line
                                          $/line
                                          "  Path: "
                                          (:path metadata)
                                          $/line
                                          $/line
                                          "  "
                                          (or (:description metadata)
                                              "No description provided.")
                                          $/line
                                          $/line
                                          "  Other metadata: "
                                          (dissoc metadata
                                                  :description
                                                  :path)
                                          $/line
                                          $/line
                                          ))))
                              [$/line
                               $/line]
                              report+))))))
