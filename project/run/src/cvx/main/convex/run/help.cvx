

(call *registry*
      (cns-update 'convex.run.help
                  *address*))


(call *registry*
      (register {:doc  {:description ""}
                 :name ""}))


;;;;;;;;;;


(def core

  ^{:doc      {:description ""}
    :private? true}

  (call *registry*
        (cns-resolve 'convex.core)))



(def $

  ^{:doc      {:description ""}
    :private? true}

  (call *registry*
        (cns-resolve 'convex.run)))



(def $.term

  ^{:doc      {:description ""}
    :private? true}

  (call *registry*
        (cns-resolve 'convex.run.term)))



(def $.trx

  ^{:doc      {:description ""}
    :private? true}

  (call *registry*
        (cns-resolve 'convex.run.trx)))


;;;;;;;;;;


(def -accent

  ^{:doc {:description ""}}

  (str $.term/bold
       $.term/fg.blue))



(defn section

  ^{:doc {:description ""}}

  [acc heading line+]

  (reduce (fn [acc-2 line]
            (conj acc-2
                  $/line
                  "  "
                  line))
          (conj acc
                $/line
                -accent
                heading
                $.term/reset)
          line+))



(defn key-value

  ^{:doc {:description ""}}

  [acc heading txt]

  (conj acc
        $/line
        -accent
        heading
        $.term/reset
        $/line
        "  "
        txt))



(defn -vector?

  ^{:doc      {:description ""}
    :private? true}

  [x]

  (and (vector? x)
       (not (empty? x))))





(defn -out!

  ^{:doc      {:description ""}
    :private? true}

  [acc]

  ($.trx/precat `(($.stream/out! ~(apply str
                                         acc))
                  nil)))



(defn description

  ^{:doc {:description ""}}

  [acc desc]

  (section acc
           "Description:"
           (if (boolean desc)
             (if (and (vector? desc)
                      (not (zero? (count desc))))
               desc
               [(str desc)])
             ["No documentation."])))



(defn -env-line

  ^{:doc      {:description ""}
    :private? true}

  [acc sym desc]

  (conj acc
        (str $.term/bold
             $.term/fg.green
             sym
             "  "
             $.term/reset
             $/line
             "    "
             (let [desc-2 (if desc
                            (if (str? desc)
                              desc
                              (first desc))
                            "No documentation.")
                   n-char (count desc-2)
                   limit  (min 75
                               n-char)]
              (loop [char+ []
                     i     0]
                (if (< i
                       limit)
                  (recur (conj char+
                               (nth desc-2
                                    i))
                         (inc i))
                  (apply str
                         (if (< limit
                                n-char)
                           (conj char+
                                 "...")
                           char+))))))))
                                    



(defn address

  ^{:doc {:description ""}}


  ([]

   (address *address*))


  ([addr]

   (-out! (if-let [account (core/account addr)]
            (let [meta-reg (call *registry*
                                 (lookup addr))
                  acc      []
                  acc      (key-value acc
                                      "Name:"
                                      (or (:name meta-reg)
                                          "Not provided."))
                  acc      (description acc
                                        (:description meta-reg))
                  acc      (key-value acc
                                      "Allowance:"
                                      (:allowance account))
                  acc      (key-value acc
                                      "Balance:"
                                      (:balance account))
                  acc      (key-value acc
                                      "Controller:"
                                      (or (:controller account)
                                          "None"))
                  acc      (key-value acc
                                      "Key:"
                                      (or (:key account)
                                          "None"))
                  meta     (:metadata account)
                  env      (reduce (fn [acc sym]
                                     (if-let [meta-sym (get meta
                                                            sym)]
                                       (if (:private? meta-sym)
                                         acc
                                         (-env-line acc
                                                    sym
                                                    (get-in meta-sym
                                                            [:doc
                                                             :description])))
                                       (-env-line acc
                                                  sym
                                                  nil)))
                                   []
                                   (keys (:environment account)))
                  acc      (if (empty? env)
                             acc
                             (section acc
                                      "Overview:"
                                      env))
                  ]
              acc)
            [($.term/down-begin 1)
             $.term/bold
             $.term/fg.red
             "Account not found."
             $.term/reset]))))




(defn meta

  ^{:doc {:description ""}}


  [meta]

  (-out! (if meta
           (let [doc   (:doc meta)
                 desc  (:description doc)
                 acc   (description []
                                    (:description doc))
                 sign+ (:signature doc)
                 acc   (if sign+
                        (section acc
                                 "Signature(s):"
                                 (if (-vector? sign+)
                                   (map :params
                                        sign+)
                                   (str sign+)))
                        acc)
                 ex+   (:examples doc)
                 acc   (if ex+
                         (section acc
                                  "Example(s):"
                                  (if (-vector? sign+)
                                    (map (fn [ex]
                                           (let [code   (:code ex)
                                                 return (:returns ex)]
                                             (if (nil? return)
                                               code
                                               (str code
                                                    ($.term/right 1)
                                                    -accent
                                                    "->"
                                                    $.term/reset
                                                    ($.term/right 1)
                                                    return))))
                                         ex+)
                                    (str ex+)))
                         acc)
                 err+  (:errors doc)
                 acc   (if err+
                         (section acc
                                  "Error(s):"
                                  (if (and (map? err+)
                                           (not (empty? err+)))
                                    (map (fn [[code txt]]
                                           (str code
                                                -accent
                                                " <- "
                                                $.term/reset
                                                txt))
                                         err+)
                                    [(str err+)]))
                         acc)]
             acc)
          [$/line
           $.term/bold
           $.term/fg.red
           "Symbol is not defined."
           $.term/reset])))



(defn symbol

  ^{:doc {:description ""}}


  ([sym]

   (meta (lookup-meta sym)))


  ([addr sym]

   (meta (lookup-meta addr
                      sym))))



(defn main

  ^{:doc {:description ""}}

  []

  (let [account (fn [account text]
                  (str $/line
                       $.term/bold
                       $.term/fg.blue
                       "  "
                       account
                       $.term/reset
                       ": "
                       text))
        text    (str $/line
                     "The Convex Lisp Runner executes each form as a separate transaction. Each transaction is local, there is no connection to any peer."
                     $/line
                     $/line
                     "This environment is well-suited for development, testing, and some off-chain computation."
                     $/line
                     $/line
                     "To learn more about getting help for accounts and symbols, run: "
                     $.term/bold
                     "($/help $/help)"
                     $.term/reset
                     $/line
                     $/line
                     "Libraries of interest:"
                     $/line
                     (account "$"
                              "miscellaneous utilities such as juice monitoring")
                     (account "$.catch"
                              "error handling, catching exceptions")
                     (account "$.doc"
                              (str "prototype of a simple document rendering library based on "
                                   $.term/bold
                                   "$.term"
                                   $.term/reset))
                     (account "$.file"
                              (str "reading/writing files, open file streams for "
                                   $.term/bold
                                   "$.stream"
                                   $.term/reset))
                     (account "$.process"
                              "process utilities, such as reading environment variables")
                     (account "$.repl"
                              "starting and stopping the Convex Lisp REPL")
                     (account "$.stream"
                              "reading/writing streams (currently files and STDIO)")
                     (account "$.term"
                              "produce nice terminal output, such as colored text")
                     (account "$.test"
                              "unit testing library")
                     (account "$.time"
                              "time-travel utilities")
                     (account "$.trx"
                              "modifying the list of pending transactions for execution"))]
    ($.trx/precat `(($.stream/out! ~text)
                    nil))
    nil))
