;;
;;
;; The SReq library offers functions for creating vectors that the Convex Lisp Runner interperts as special requests.
;; A special request is typically a side-effects such as outputting a value.
;;
;;


(call *registry*
      (cns-update 'convex.run.sreq
                  *address*))


(call *registry*
      (register {:doc  {:description ["Special requests are vectors of data which instruct the Convex Lisp Runner to perform useful actions such as outputting values."
                                      "Those actions are not implemented by the CVM, they are only understood by the runner."
                                      "After each transaction in the main file has been executed, the runner checks if the result is any supported special request."
                                      "Such vectors are created by calling functions from this address."]}
                 :name "Convex Lisp Runner Special Requests"}))



(def env

  ^{:doc {:description ""}}

  (address (inc (long *address*))))


;; SPECIAL REQUESTS


(defn advance

  ^{:doc {:description ["Advances the current timestamp by `millis` milliseconds."
                        "Argument must be > 0."]
          :examples    [{:code "(sreq/advance (* 60 60 1000))"}]
          :signature   [{:params [millis]}]
          :type        :function}}

  [millis]

  (assert (>= millis
              0))
  [:cvm.sreq :advance millis])



(defn close

  ^{:doc {:description ""}}

  [stream]

  [:cvm.sreq :close stream])



(defn dep

  ^{:doc {:description ["Loads Convex Lisp dependency files. During watch mode, those files are live-reloaded as well."
                        "If used, MUST be written as the very first transaction found in the main file."
                        "Takes a map of `symbol` -> `path to file`. Files are read as lists of Convex Lisp forms and then defined under their corresponding symbol."
                        "Then, those forms can be used as needed. It is common to use `deploy` or `eval`, depending on the purpose of a given file."]
          :examples    [{:code "(sreq/dep {'my-lib \"path/to/lib.cvx\"})"}]
          :signature   [{:params [sym->file]}]
          :type        :function}}

  [sym->file]

  (assert (not "First transaction")))



(defn do

  ^{:doc {:description ["Given a sequence of quoted transactions, executes them one by one."
                        "Useful when composing special requests in some way."]
          :examples    [{:code "(sreq/do '[(def foo 42) (sreq/out foo)])"}]
          :signature   [{:params [trx+]}]
          :type        :function}}

  [trx+]

  (assert (or (list? trx+)
              (vector? trx+)))
  [:cvm.sreq :do trx+])



(defn file.in

  ^{:doc {:description ""}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.in path])



(defn file.out

  ^{:doc {:description ""}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.out path])



;; Currently expects exactly one input form.
;; Too tricky to use.
;
; (defn in
; 
;   ^{:doc {:description ["Reads a cell form from input."
;                         "Currently fails if streams contains more than one input."
;                         "See `out.bin`."]}}
; 
; 
;   ([]
; 
;    (in env/*in*))
; 
; 
;   ([stream]
; 
;    [:cvm.sreq :in stream]))



(defn in+

  ^{:doc {:description ["Reads a cell form from input."
                        "See `out.bin`."]}}


  ([]

   (in+ env/*in*))


  ([stream]

   [:cvm.sreq :in+ stream]))



(defn in.line+

  ^{:doc {:description ["Reads a line from STDIN."
                        "Returns a list of forms."
                        "See `out.ln`."]}}


  ([]

   (in.line+ env/*in*))


  ([stream]

   [:cvm.sreq :in.line+ stream]))



(defn log

  ^{:doc {:description ["Retrieves the current CVM log."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/do '[(log :foo) (sreq/log l) (sreq/out l))"}]
          :signature   [{:params []}]
          :type        :function}}

  []

  [:cvm.sreq :log])



(defn main

  ^{:doc {:description ""}}

  [path]

  (if env/*main?*
    (fail :STATE
          "Main file already loaded")
    [:cvm.sreq :main path]))



(defn main.watch

  ^{:doc {:description ""}}

  [path]

  (if env/*main?*
    (fail :STATE
          "Main file already loaded")
    [:cvm.sreq :main.watch path]))




(defn monitor

  ^{:doc {:description ""}}

  [trx]

  [:cvm.sreq :monitor trx])



(defn out

  ^{:doc {:description ["Writes the given argument to STDOUT as text."
                        "See `out.flush`."]
          :examples    [{:code "(sreq/out 42)"}]
          :signature   [{:params [x]}]
          :type        :function}}


  ([x]

   (out env/*out*
        x))


  ([stream x]

   [:cvm.sreq :out stream x]))



(defn out!

  ^{:doc {:description ["Writes the given argument to STDOUT as text."
                        "See `out.flush`."]
          :examples    [{:code "(sreq/out 42)"}]
          :signature   [{:params [x]}]
          :type        :function}}


  ([x]

   (out! env/*out*
         x))


  ([stream x]

   [:cvm.sreq :out! stream x]))



(defn out.flush

  ^{:doc {:description "Flushes what has been outputted with `out`."}}


  ([]

   (out.flush env/*out*))


  ([stream]

   [:cvm.sreq :out.flush stream]))



(defn process.env

  ^{:doc {:description ["Retrieves environment variable from the current process. Useful when some information must be passed to the runner from the outside."
                        "When a env variable is given as well, defines only the value for that variable"
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/env}"}
                        {:code "(sreq/env \"MY_X\")"}]
          :signature   [{:params [sym]}
                        {:params [sym env-var]}]
          :type        :function}}


  ([]

   (process.env nil))


  ([env-var]

   (assert (or (str? env-var)
               (nil? env-var)))
   [:cvm.sreq :process.env env-var]))



(defn process.exit

  ^{:doc {:description ["Stops execution and exits process with given `status` code (a long)."
                        "Depending on the operating system, by convention, a non-zero value means an error occured."]
          :examples    [{:code "(sreq/exit 42)"}]
          :signature   [{:params [status]}]
          :type        :function}}

  [status]

  (assert (long? status))
  [:cvm.sreq :exit status])



(defn read+

  ^{:doc {:description ["Passes the given string through the CVX reader and produces a list of cells."
                        "Those cells can be compiled, evaluated, ..."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/read+ \"(+ 2 2)\")"}]
          :signature   [{:params [string]}]
          :type        :function}}

  [src]

  (assert (str? src))
  [:cvm.sreq :read+ src])



(defn state.pop

  ^{:doc {:description ["Restores the last state saved with `state.push`."
                        "Quoted transaction, if given, is executed in the context of the restored state, allowing to pass values from one to the other."]
          :examples    [{:code "(sreq/state.pop)"}]
          :signatures  [{:params []}]
          :type        :function}}


  ([]

   (state.pop nil))


  ([trx]

   [:cvm.sreq :state.pop trx]))



(defn state.push

  ^{:doc {:description ["Pushes the current state of the CVM onto a stack."
                        "This state can later be restored using `state.pop`."]
          :examples    [{:code "(sreq/state.push)"}]
          :signature   [{:params []}]
          :type        :function}}

  []

  [:cvm.sreq :state.push])
