;;
;;
;; The SReq library offers functions for creating vectors that the Convex Lisp Runner interperts as special requests.
;; A special request is typically a side-effects such as outputting a value.
;;
;;


(call *registry*
      (cns-update 'convex.run.sreq 
                  *address*))


(call *registry*
      (register {:doc  {:description ["Special requests are vectors of data which instruct the Convex Lisp Runner to perform useful actions such as outputting values."
                                      "Those actions are not implemented by the CVM, they are only understood by the runner."
                                      "After each transaction in the main file has been executed, the runner checks if the result is any supported special request."
                                      "Such vectors are created by calling functions from this address."]}
                 :name "Convex Lisp Runner Special Requests"}))


;; SPECIAL REQUESTS


(defn advance

  ^{:doc {:description ["Advances the current timestamp by `millis` milliseconds."
                        "Argument must be > 0."]
          :examples    [{:code "(sreq/advance (* 60 60 1000))"}]
          :signature   [{:params [millis]}]
          :type        :function}}

  [millis]

  (assert (>= millis
              0))
  [:cvm.sreq :advance millis])



(defn dep

  ^{:doc {:description ["Loads Convex Lisp dependency files. During watch mode, those files are live-reloaded as well."
                        "If used, MUST be written as the very first transaction found in the main file."
                        "Takes a map of `symbol` -> `path to file`. Files are read as lists of Convex Lisp forms and then defined under their corresponding symbol."
                        "Then, those forms can be used as needed. It is common to use `deploy` or `eval`, depending on the purpose of a given file."]
          :examples    [{:code "(sreq/dep {'my-lib \"path/to/lib.cvx\"})"}]
          :signature   [{:params [sym->file]}]
          :type        :function}}

  [sym->file]

  (assert (not "First transaction")))



(defn do

  ^{:doc {:description ["Given a sequence of quoted transactions, executes them one by one."
                        "Useful when composing special requests in some way."]
          :examples    [{:code "(sreq/do '[(def foo 42) (sreq/out foo)])"}]
          :signature   [{:params [trx+]}]
          :type        :function}}

  [trx+]

  (assert (or (list? trx+)
              (vector? trx+)))
  [:cvm.sreq :do trx+])



(defn env

  ^{:doc {:description ["Retrieves environment variable from the current process. Useful when some information must be passed to the runner from the outside."
                        "When a env variable is given as well, defines only the value for that variable"
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/env}"}
                        {:code "(sreq/env \"MY_X\")"}]
          :signature   [{:params [sym]}
                        {:params [sym env-var]}]
          :type        :function}}


  ([]

   (env nil))


  ([env-var]

   (assert (or (str? env-var)
               (nil? env-var)))
   [:cvm.sreq :env env-var]))



(defn exit

  ^{:doc {:description ["Stops execution and exits process with given `status` code (a long)."
                        "Depending on the operating system, by convention, a non-zero value means an error occured."]
          :examples    [{:code "(sreq/exit 42)"}]
          :signature   [{:params [status]}]
          :type        :function}}

  [status]

  (assert (long? status))
  [:cvm.sreq :exit status])



(defn in

  ^{:doc {:description ["Reads a cell form from input."
                        "Currently fails if streams contains more than one input."
                        "See `out.bin`."]}}


  ([]

   (in nil))


  ([stream]

   [:cvm.sreq :in stream]))



(defn in+

  ^{:doc {:description ["Reads a cell form from input."
                        "See `out.bin`."]}}


  ([]

   (in+ nil))


  ([stream]

   [:cvm.sreq :in+ stream]))



(defn in.line+

  ^{:doc {:description ["Reads a line from STDIN."
                        "Returns a list of forms."
                        "See `out.ln`."]}}


  ([]

   (in.line+ nil))


  ([stream]

   [:cvm.sreq :in.line+ stream]))



(defn in.set

  ^{:doc {:description ""}}

  [stream]

  (assert (long? stream))
  [:cvm.sreq :in.set stream])



(defn log

  ^{:doc {:description ["Retrieves the current CVM log."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/do '[(log :foo) (sreq/log l) (sreq/out l))"}]
          :signature   [{:params []}]
          :type        :function}}

  []

  [:cvm.sreq :log])



(defn monitor

  ^{:doc {:description ""}}

  [trx]

  [:cvm.sreq :monitor trx])



(defn out

  ^{:doc {:description ["Writes the given argument to STDOUT as text."
                        "See `out.flush`."]
          :examples    [{:code "(sreq/out 42)"}]
          :signature   [{:params [x]}]
          :type        :function}}


  ([x]

   (out nil
        x))


  ([stream x]

   [:cvm.sreq :out stream x]))



(defn out!

  ^{:doc {:description ["Writes the given argument to STDOUT as text."
                        "See `out.flush`."]
          :examples    [{:code "(sreq/out 42)"}]
          :signature   [{:params [x]}]
          :type        :function}}


  ([x]

   (out! nil
         x))


  ([stream x]

   [:cvm.sreq :out! stream x]))



(defn out.err.set

  ^{:doc {:description ""}}

  [stream]

  (assert (long? stream))
  [:cvm.sreq :out.err.set stream])



(defn out.flush

  ^{:doc {:description "Flushes what has been outputted with `out`."}}


  ([]

   (out.flush nil))


  ([stream]

   [:cvm.sreq :out.flush stream]))



(defn out.set

  ^{:doc {:description ""}}

  [stream]

  (assert (long? stream))
  [:cvm.sreq :out.set stream])



(defn read+

  ^{:doc {:description ["Passes the given string through the CVX reader and produces a list of cells."
                        "Those cells can be compiled, evaluated, ..."
                        "Result is temporarily stored in `env/*result* and is accessible during the next transaction."]
          :examples    [{:code "(sreq/read+ \"(+ 2 2)\")"}]
          :signature   [{:params [string]}]
          :type        :function}}

  [src]

  (assert (str? src))
  [:cvm.sreq :read+ src])



(defn state.pop

  ^{:doc {:description ["Restores the last state saved with `state.push`."
                        "Quoted transaction, if given, is executed in the context of the restored state, allowing to pass values from one to the other."]
          :examples    [{:code "(sreq/state.pop)"}]
          :signatures  [{:params []}]
          :type        :function}}


  ([]

   (state.pop nil))


  ([trx]

   [:cvm.sreq :state.pop trx]))



(defn state.push

  ^{:doc {:description ["Pushes the current state of the CVM onto a stack."
                        "This state can later be restored using `state.pop`."]
          :examples    [{:code "(sreq/state.push)"}]
          :signature   [{:params []}]
          :type        :function}}

  []

  [:cvm.sreq :state.push])



(defn try

  ^{:doc {:description ["First argument is a sequence of quoted transactions executed one by one until an exception is throw."
                        "In such case, the exception is defined under `env/*error*` and optional quoted transactions from the second argument are executed."
                        "With or without \"catch\" transactions, execution in the main file continues."]
          :examples    [{:code "(sreq/try '[(def foo 42) (fail \"Oops\")] '[(sreq/out [:error *error*)])"}]
          :signature   [{:params [try-trx+ catch-trx+]}]
          :type        :function}}


  ([trx-try]

   (try trx-try
        nil))


  ([trx-try trx-catch]

   [:cvm.sreq :try trx-try trx-catch]))
