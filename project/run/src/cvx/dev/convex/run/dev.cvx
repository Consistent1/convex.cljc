;;
;;
;; Example of a Convex Lisp main file.
;;
;; Each form is evaluated as a transaction until a CVM exception is thrown.
;;
;; Lines starting with ";;" are comments.
;; Lines starting with ";" can be uncommented for learning and testing features.
;;
;;

;;;;;;;;;; INIIALIZING A RUN


;; Reads those files and binds the unevaluated code (list of forms) to the given symbols.
;;
;; If used, MUST be at the beginning of the main file as first transaction.
;; In watch mode, those files are live-reloaded as well.
;;
;; Ensure file paths are correct when testing this.
;;
(sreq/dep {store "project/cvx/lab/lib/xform/src/cvx/dev/convex/xform/store.cvx"
           xform "project/cvx/lab/lib/xform/src/cvx/main/convex/xform.cvx"})



;; Clears the terminal.
;;
(sreq/screen.clear)



;; Prints nice information at the start of a run.
;;
(sreq/out.ln (str "Run NÂ°" (inc help/*cycle*)
                  help/line
                  help/line
                  "OUTPUT:"
                  help/line))


;;;;;;;;;; HELP LIBRARY


;; The Help library is a special address only available when using the runner.
;;
;; Notably, it provides an `about` function which can be used to describe any address or any symbol defined
;; in any address

; (help/about help)

; (help/about help 'about)


;; It also contains dynamic values commonly useful.
;;
;; For example:
;;
; (+ 10 20)
; (sreq/out.ln {:juice  help/*trx.last.juice*
;               :result help/*trx.last.result*})


;;;;;;;;;; SPECIAL REQUESTS


;; Special requests are interpreted by the runner in order to produce useful side-effects.
;;
;; They are simply vectors produced using the `sreq` library. The runner checks each transaction result for those.
;;
;; It is important understanding that calling those functions only returns a vector.
;;
;; Only then side-effects are performed by the runner.
;;
;; The rest of this file shows examples of such special requests.

; (help/about sreq)

; (help/about sreq 'out)


;;;;;;;;;; PRODUCING AN OUTPUT


;; Returns a vector which requests the runner to output a given value.
;;
; (sreq/out.ln [:output "any value" {'foo 42}])


;;;;;;;;;; HOOKS (code executed at particular moments)


;; Registers transactions to be executed at the end of the run, even if a CVM exception was thrown.
;;
; (sreq/hook.end '[(def foo 42)
;                  (sreq/out.ln [:end :foo foo])])


;; Registers a function which maps a thrown CVM exception to a transaction.
;; Default is to output them.
;;
;(sreq/hook.error (fn [err]
;                   (sreq/out.ln (str "An error occured: " err))))
;(fail :foo :bar)


;; Registers a function which maps any value to be output right before being so.
;; Allows for implementing things like pretty-printing.
;;
; (sreq/hook.out (fn [x]
;                  (if (and (map? x)
;                           (:foo x))
;                    (str "This value contains `:foo`: " x)
;                    x)))
; (sreq/out.ln 42)
; (sreq/out.ln {:foo 1, :bar 2})


;; Registers a transaction to perform after each transaction in this main file.
;; Useful for providing feedback on what is happening.
;;
;(sreq/hook.result '(sreq/out.ln {:form   help/*trx.last.form*
;                                 :juice  help/*trx.last.juice*
;                                 :result help/*trx.last.result*}))
;(+ 10 20)

;(sreq/hook.result nil)
;;
;; Any registered can be overwritten or canceled with nil
;;


;;;;;;;;;; DEPENDENCIES (uncomment first transction in this main file `(sreq/dep ...)`


;; The store file can be evaluated in place
;;
; (eval (first store))



;; Deploys transducers file as a library
;;
; (def xform
;      (deploy (first xform)))



;; Transducer example ; functions `available?`, `code`, `price`, and `tag+` were defined in the evaluated "store" file
;;
; (sreq/out.ln [:query-veggies
;               (xform/transduce ;; Processing, composition of "transducers" which filter and map items
;                                (comp (xform/filter (fn [item]
;                                                      (contains-key? (tag+ item)
;                                                                     :fruit)))
;                                      (xform/filter (fn [item]
;                                                      (< (price item)
;                                                         600)))
;                                      (xform/filter available?)
;                                      (xform/map code)
;                                      )
;                                ;; Output, each item that survives processing is `conj`ed to the given vector (empty at the beginning)
;                                conj
;                                []
;                                ;; Input, declared in the "store" file, a vector where an item is a fruit or vegetable with a price, some quantity, tags, ...
;                                inventory)])


;;;;;;;;; BUILDING ABSTRACTIONS


;; Creating transactions dynamically is easy.
;;
;(def trx+
;     '[(def foo 42)
;       (sreq/out.ln [:foo foo])])
;
;(sreq/do trx+)


;; Hence, regular functions and macros can be used to build any abstraction.
;;
; (defmacro trace
;
;   [trx]
;
;   (sreq/do `[(sreq/out.ln "===")
;              (sreq/out.ln help/line)
;              (sreq/out.ln (str "TRANSACTION: "
;                                (quote ~trx)))
;              (sreq/out.ln help/line)
;              (sreq/out.ln (str "RESULT: "
;                                ~trx))
;              (sreq/out.ln help/line)
;              (sreq/out.ln "===")]))
; 
; (trace (+ 2 2))


;;;;;;;;;; TRY-CATCH


;; Transactions from the first "try" vector are executed one by one until an error occurs, like `sreq/do`.
;;
;; If an error does occur, execution jumps to the second "catch" vector for error handling.
;;
; (sreq/try '[(def foo 42)
;             (fail :bar :baz)]
;           '[(sreq/out.ln [:catch :foo foo :caught help/*error*])])


;;;;;;;;;; ACCESSING THE CVM LOG


;; Using the standard `log` function
;;
; (log [:a :b :c])


;; Retrieves the current log.
;;
; (sreq/log)

;; For the next transaction, it is available as last transaction's result.
;;
; (sreq/out.ln [:log help/*trx.last.result*])


;;;;;;;;;; READING SOURCE


;; Any string representing Convex Lisp code can be read.
;; Code is available as a list of forms in last transaction's result.
;;
; (sreq/read (str "(+ 2 " "3)"))
; (let [form (first help/*trx.last.result*)]
;   (sreq/out.ln (list '= form (eval form))))


;;;;;;;;;; ACCESSING PROCESS ENVIRONMENT


;; Storing whole process environment map.
;;
; (sreq/env)
; (sreq/out [:whole-env help/*trx.last.result*])


;; Storing only one env property.
;;
; (sreq/env "SOME_ENV") ;; Should be a property spotted in previous example
; (sreq/out.ln [:one-prop help/*trx.last.result*])


;;;;;;;;;; SCHEDULING AND ADVANCING TIMESTAMP


;; Unless requested, the CVM timestamp never changes.
;;
;; For testing scheduling, it can be advanced.

; (def happened?
;      false)

;; Scheduling this in 10 milliseconds
;;
; (schedule (+ *timestamp*
;              10)
;           (def happened?
;                true))

;; Not yet.
;;
; (sreq/out.ln [:happened? happened? *timestamp*])


;; Advancing the timestamp by 10 milliseconds.
;;
; (sreq/advance 10)


;; Done!
;;
; (sreq/out.ln [:happened? happened? *timestamp*])


;;;;;;;;;; Saving and restoring state 


;; Current state is pushed onto a stack.
;;
; (sreq/state.push)

;; Doing some work in current state.
;;
; (def foo
;      42)

;; Restoring last saved state and transferring arbitrary work.
;;
; (sreq/state.pop `(def bar ~foo))

;; `foo` was not defined originally but we ported it to the restored state as `bar`.
;;
; (sreq/out.ln [:foo-defined? (defined? foo) :bar bar])


;;;;;;;;;; Reading from STDIN


;; Implementing a very simple REPL which read forms entered by the user, executes them and prints the result.
;;
(defn repl

  []

  (sreq/do '[(sreq/out "> ")
             (sreq/out.flush)
             (sreq/in.ln)
             (let [form+ help/*trx.last.result*]
               (when-not (and (not (nil? form+))
                              (>= (count form+)
                                  1)
                              (= (first form+)
                                 :repl.stop))
                 (sreq/do `[(sreq/out help/line)
                            (sreq/try '[(eval ~(cons 'do
                                                     form+))
                                        (sreq/out.ln help/*trx.last.result*)]
                                      '[(sreq/out.ln (list 'quote
                                                           help/*error*))])
                            (sreq/out.ln "")
                            (repl)])))]))

(repl)
