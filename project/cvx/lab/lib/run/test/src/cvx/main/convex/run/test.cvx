;;
;;
;; Unit testing library for the Convex Lisp Runner
;;
;; Provides a simple but flexible framework where a test assertion is a transaction.
;;
;;


;; REGISTERING THE LIBRARY

(call *registry*
      (cns-update 'convex.run.test
                  *address*))

(call *registry*
      (register {:doc  {:description "Unit testing library for the Convex Lisp Runner."}
                 :name "Convex Liser Runner Unit Testing"}))


;; IMPORTING OTHER LIBRARIES

(def sreq

  ^{:doc {:description "Alias to the SReq library."}}

  (call *registry*
        (cns-resolve 'convex.run.sreq)))


;; VALUES

(def self

  ^{:doc {:description "Reference to this library's address."}}

  *address*)



;; Is defined below in order to preserve metadata. 
;;
(def state
     nil)



(defn update-state

  ^{:doc {:description ["Used by this actor."
                        "Updates the `state` symbol using `f`, a function `state` -> `state`."]}}

  [f]

  (def state

    ^{:doc {:description "State map holding the number of failures (`:n-fail`) and all reports (`:report+`, see the `conj-report` symbol)."}}

    (f state)))



(defn clear

  ^{:doc {:description "Resets the `state` symbol to a clean state, erasing all tests."}}

  []

  (if (= *address*
         self)
    (update-state (fn [_state]
                    {:n-fail  0
                     :report+ []}))
    (call self
          (clear)))
  nil)


(export clear)

(clear)



(defn conj-report

  ^{:doc {:description ["Low-level function for adding a new report to the `state` symbol."
                        "A report summarizes a test assertion."
                        "If strictly required, study the `fail` and `trx` symbols which rely on this function."]}}

  [report]

  (if (= *address*
         self)
    (def state
         (let [state-2 (assoc state
                              :report+
                              (conj (get state
                                         :report+)
                                    report))]
          (if (:pass? report)
            state-2
            (assoc state-2
                   :n-fail
                   (inc (state-2 :n-fail))))))
    (call self
          (conj-report report))))



(export conj-report)



(defn exit

  ^{:doc {:description ["Returns an 'exit' special request to terminate the process."
                        "A non-zero status code is issued in case not all tests pass."
                        "Meant to be used at the end of the run indicating failure or success."]}}

  []

  (sreq/exit (if (> (:n-fail self/state)
                    0)
               42
               0)))



(defn fail

  ^{:doc {:description ["Tests that the given `trx` quoted transaction throws an exception."
                        "If no exception is throw, test fails."
                        "If an exception is thrown, it is passed to the `expected-fail?` function."
                        "Returning true means the exception was as expected, meaning test passes."
                        "Most of the time, the `fail-code` function will be used rather than this one."
                        "See the `trx` symbol from this library for metadata and how exection is done."]}}

  
  ([expected-fail? trx]

   (fail expected-fail?
         trx
         nil))


  ([expected-fail? trx metadata]

   (let [base-report {:expect   :exception
                      :metadata metadata
                      :trx      (list 'quote
                                      trx)}]
     (sreq/try `[(query ~trx)
                 (~self/conj-report (assoc ~base-report
                                           :result help/*trx.last.result*
                                           :pass?  false))]
               `[(let [ex help/*error*]
                   (~self/conj-report (assoc ~base-report
                                             :exception ex
                                             :pass?     (~expected-fail? ex))))]))))


(defn fail-code

  ^{:doc {:description ["Like the `fail` function but `expected-code?` receives the exception's code."
                        "A convenient solution is to use a set of expected codes."]
          :examples    [{:code "(fail-code #{:ASSERT} '(assert (< 42 3)))"}]}}
  

  ([code-target trx]

   (fail-code code-target
              trx
              nil))


  ([code-target trx metadata]

   (fail (fn [ex]
           (code-target (ex :code)))
         trx
         (assoc metadata
                :code-target
                code-target))))



(defn trx

  ^{:doc {:description ["Tests that the given transaction (a quoted form) return exactly true."
                        "Any other value means the transaction failed."
                        "Transaction is evaluated wrapped in `(query ...)`, meaning any side-effect is discarded afterwards."
                        "Result is reported using `conj-report`."
                        "Metadata is an arbitrary map associated under `:metadata` in the report for providing extra information."
                        "It is advised to provide at least `:description`, a human-readable string explaining the test."]
          :examples    [{:code "(trx '(< 2 3) {:description \"Two should be lesser than three.\"})"}]}} 


  ([trx]

   (self/trx trx
             nil))


  ([trx metadata]

   (let [base-report {:expect   :result
                      :metadata metadata
                      :trx      (list 'quote
                                      trx)}]
     (sreq/try `[(query ~trx)
                 (let [result help/*trx.last.result*]
                   (~self/conj-report (assoc ~base-report
                                             :result result
                                             :pass?  (= result
                                                        true))))]
               `[(~self/conj-report (assoc ~base-report
                                           :exception help/*error*
                                           :pass?     false))]))))


 ;; REPORTING


 (defn print-failed

   ^{:doc {:description ["Returns an 'out' special requestion which outputs failed tests in human-readable format."
                         "Prints each failed transaction, why, and its `:description` from `:metadata`."]}}


   ([]

    (print-failed state))


   ([state]

    (let [n-fail (:n-fail state)]
      (sreq/out (apply str
	  				   "Number of failed tests: "
	  				   n-fail
	  				   (when (> n-fail
	  				      	  0)
                         (reduce (fn [acc report]
	  				               (if (:pass? report)
	  				      	         acc
                                     (let [metadata (report :metadata)
                                                     ex       (dissoc (report :exception)
                                                                      :trx)
                                                     res      (report :result)
                                                     res?     (contains-key? report
                                                                             :result)
                                                     [text
                                                      data] (if (= (report :expect)
                                                                   :result)
                                                              (if res?
                                                                ["Returned: "
                                                                 res]
                                                                ["Threw: "
                                                                 ex])
                                                              (if res?
                                                                ["Instead of exception: "
                                                                 res]
                                                                ["Not predicted exception: "
                                                                 ex]))]
                                                 (conj acc
                                                       "---"
                                                       \newline
                                                       \newline
                                                       (report :trx)
                                                       \newline
                                                       \newline
                                                       "  "
                                                       text
                                                       data
                                                       \newline
                                                       \newline
                                                       "  "
                                                       (or (:description metadata)
                                                           "No description provided.")
                                                       \newline
                                                       \newline
                                                       "  Other metadata: "
                                                       (dissoc metadata
                                                               :description)
                                                       \newline
                                                       \newline
                                                       ))))
                                 ["\n\n"]
                                 (:report+ state))))))))
