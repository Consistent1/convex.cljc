;;
;;
;; Unit testing library for the Convex Lisp Runner
;;
;; Provides a simple but flexible framework where a test assertion is a transaction.
;;
;;


;; REGISTERING THE LIBRARY

(call *registry*
      (cns-update 'convex.run.test
                  *address*))

(call *registry*
      (register {:doc  {:description "Unit testing library for the Convex Lisp Runner."}
                 :name "Convex Liser Runner Unit Testing"}))


;; IMPORTING OTHER LIBRARIES

(def sreq

  ^{:doc {:description "Alias to the SReq library."}}

  (call *registry*
        (cns-resolve 'convex.run.sreq)))


;; VALUES

(def self

  ^{:doc {:description "Reference to this library's address."}}

  *address*)



;; Is defined below in order to preserve metadata. 
;;
(def state
     nil)


;; MODIFYING STATE CONTAINING REPORTS


(defn update-state

  ^{:doc {:description ["Used by this actor."
                        "Updates the `state` symbol using `f`, a function `state` -> `state`."]}}

  [f]

  (def state

    ^{:doc {:description "State map holding the number of failures (`:n-fail`) and all reports (`:report+`, see the `conj-report` symbol)."}}

    (f state)))


;;


(defn clear

  ^{:doc {:description "Resets the `state` symbol to a clean state, erasing all tests."}}

  []

  (if (= *address*
         self)
    (update-state (fn [_state]
                    {:n-fail  0
                     :report+ []}))
    (call self
          (clear)))
  nil)


(export clear)
(clear)



(defn conj-report

  ^{:doc {:description ["Low-level function for adding a new report to the `state` symbol."
                        "A report summarizes a test assertion."
                        "If strictly required, study the `fail` and `trx` symbols which rely on this function."]}}

  [report]

  (if (= *address*
         self)
    (let [state-2 (update-state (fn [state]
                                  (assoc state
                                         :report+
                                         (conj (get state
                                                    :report+)
                                               report))))]
     (if (:pass? report)
       state-2
       (update-state (fn [state]
                       (assoc state-2
                              :n-fail
                              (inc (state-2 :n-fail)))))))
    (call self
          (conj-report report))))



(export conj-report)



(defn merge

  ^{:doc {:description "Merges the given test state with the current one."}}

  [state]

  (if (= *address*
         self)
    (update-state (fn [state-old]
                    (assoc state-old
                           :n-fail  (+ (state-old :n-fail)
                                       (state :n-fail))
                           :report+ (concat (state-old :report+)
                                            (state :report+)))))
    (call self
          (merge state))))


(export merge)


;; CVM STATE ISOLATION


(defn group

  ^{:doc {:description ""}}


  ([trx+]

   (group trx+
          nil))


  ([trx+ trx-pop]

   (sreq/do (cons (list state.push)
                  (conj trx+
                        (list state.pop
                              trx-pop))))))



(defn state.pop

  ^{:doc {:description ["Like `(sreq/state.pop)` but ensures tests results are remembered."
                        "See function `state.push`."
                        "An additional quoted `trx` can be passed to transfer other user data."]}}


  ([]

   (state.pop nil))


  ([trx]

   (sreq/state.pop `(sreq/do '[(~self/merge (quote ~self/state))
                    ~trx]))))



(defn state.push

  ^{:doc {:description ["Like `(sreq/state.push)` but clears the test state from this actor."
                        "Later, CVM state can be restored with function `state.pop`."
                        "Provides isolation, side-effects can be discarded in a controlled fashion."]}}

  []

  (sreq/do `[(sreq/state.push)
             (~self/clear)]))


;; TESTING TRANSACTIONS


(defn fail

  ^{:doc {:description ["Tests that the given `trx` quoted transaction throws an exception."
                        "If no exception is throw, test fails."
                        "If an exception is thrown, it is passed to the `expected-fail?` function."
                        "Returning true means the exception was as expected, meaning test passes."
                        "Most of the time, the `fail-code` function will be used rather than this one."
                        "See the `trx` symbol from this library for metadata and how exection is done."]}}

  
  ([expected-fail? trx]

   (fail expected-fail?
         trx
         nil))


  ([expected-fail? trx metadata]

   (let [base-report {:expect   :exception
                      :metadata metadata
                      :trx      (list 'quote
                                      trx)}]
     (sreq/try `[~trx
                 (~self/conj-report (assoc ~base-report
                                           :result help/*trx.last.result*
                                           :pass?  false))]
               `[(let [ex help/*error*]
                   (~self/conj-report (assoc ~base-report
                                             :exception ex
                                             :pass?     (~expected-fail? ex))))]))))


(defn fail-code

  ^{:doc {:description ["Like the `fail` function but `expected-code?` receives the exception's code."
                        "A convenient solution is to use a set of expected codes."]
          :examples    [{:code "(fail-code #{:ASSERT} '(assert (< 42 3)))"}]}}
  

  ([code-target trx]

   (fail-code code-target
              trx
              nil))


  ([code-target trx metadata]

   (fail (fn [ex]
           (code-target (ex :code)))
         trx
         (assoc metadata
                :code-target
                code-target))))



(defn trx

  ^{:doc {:description ["Tests that the given transaction (a quoted form) return exactly true."
                        "Any other value means the transaction failed."
                        "Result is reported using `conj-report`."
                        "Metadata is an arbitrary map associated under `:metadata` in the report for providing extra information."
                        "It is advised to provide at least `:description`, a human-readable string explaining the test."]
          :examples    [{:code "(trx '(< 2 3) {:description \"Two should be lesser than three.\"})"}]}} 


  ([trx]

   (self/trx trx
             nil))


  ([trx metadata]

   (let [base-report {:expect   :result
                      :metadata metadata
                      :trx      (list 'quote
                                      trx)}]
     (sreq/try `[~trx
                 (let [result help/*trx.last.result*]
                   (~self/conj-report (assoc ~base-report
                                             :result result
                                             :pass?  (= result
                                                        true))))]
               `[(~self/conj-report (assoc ~base-report
                                           :exception help/*error*
                                           :pass?     false))]))))


;; REPORTING


(defn exit

  ^{:doc {:description ["Returns an 'exit' special request to terminate the process."
                        "A non-zero status code is issued in case not all tests pass."
                        "Meant to be used at the end of the run indicating failure or success."]}}

  []

  (sreq/exit (if (> (:n-fail self/state)
                    0)
               42
               0)))


(defn print-failed

  ^{:doc {:description ["Returns an 'out' special requestion which outputs failed tests in human-readable format."
                        "Prints each failed transaction, why, and its `:description` from `:metadata`."]}}


  ([]

   (print-failed state))


  ([state]

   (let [n-fail (:n-fail state)]
     (sreq/out (apply str
     				   "Number of failed tests: "
     				   n-fail
                      " / "
                      (count (state :report+))
     				   (when (> n-fail
     				      	  0)
                        (reduce (fn [acc report]
     				               (if (:pass? report)
     				      	         acc
                                    (let [metadata (report :metadata)
                                          ex       (dissoc (report :exception)
                                                           :trx)
                                          res      (report :result)
                                          res?     (contains-key? report
                                                                  :result)
                                          [text
                                           data]   (if (= (report :expect)
                                                          :result)
                                                     (if res?
                                                       ["Returned: "
                                                        res]
                                                       ["Threw: "
                                                        ex])
                                                     (if res?
                                                       ["Instead of exception: "
                                                        res]
                                                       ["Not predicted exception: "
                                                        ex]))]
                                      (conj acc
                                            "---"
                                            \newline
                                            \newline
                                            (report :trx)
                                            \newline
                                            \newline
                                            "  "
                                            text
                                            data
                                            \newline
                                            \newline
                                            "  "
                                            (or (:description metadata)
                                                "No description provided.")
                                            \newline
                                            \newline
                                            "  Other metadata: "
                                            (dissoc metadata
                                                    :description)
                                            \newline
                                            \newline
                                            ))))
                                ["\n\n"]
                                (:report+ state))))))))
