;; File for core documentation and other metadta
;;
;; Read in as raw forms and added to metadata for each core symbol specified
;;
;; Includes:
;;  - metadata for core functions defined in Java code
;;  - metadata for Convex Lisp special forms
;;  - additional metadata for anything defined during core environment bootstrap (e.g. in core.con)
{
  abs
  {
	 :doc {:description "Computes the absolute value of a numerical argument. Supports Double and Long results."
         :examples [{:code "(abs -1.5)"}
                    {:code "(abs 100)"}]
         :type :function
         :signature [{:params [x]
                      :return Number}
                     ]
         :errors {:CAST "If the parameter is not a Number"}}
	}

	accept
	{
	 :doc {:description "Accepts offered coins up to the amount of *offer* from *caller*. Amount must cast to Long. If successful, the amount will be added immediately to the *balance* of the current *address*. This is the recommended way of transferring balance between Actors, as it requires a positive action to confirm receipt. Returns the amount accepted if successful."
         :examples [{:code "(accept *offer*)"}]
         :type :function
         :signature [{:params [amount]
                      :return Number}]
         :errors {:CAST "If the amount accepted is not a Long"
                  :ARGUMENT "If the amount acccpeted is negative"
                  :STATE "If the *caller* has not offered sufficient coins to fulfil the offer"}}
	}

  account
	{
	 :doc {:description "Returns the Account record for a given addess, or nil if the account does not exist. Argument must cast to Address."
         :examples [{:code "(account *address*)"}]
         :type :function
         :signature [{:params [address]
                      :return Account}]
         :errors {:CAST "If the argument is not a valid Address"}}
	}

 	address
	{
	 :doc {:description "Casts the argument to an Address. Valid arguments include hex Strings, Longs, Addresses and Blobs with the correct length (8 bytes)."
         :examples [{:code "(address 451)"}]
         :type :function
         :signature [{:params [a]
                      :return Address}]
         :errors {:CAST "If the argument is not castable to a valid Address."}}
	}

 	address?
	{
	 :doc {:description "Tests if the argument is an Address. Returns true if and only if the argument is an actual Address, not merely castable to one."
         :examples [{:code "(address? #777)"}
                    {:code "(address? :foo)"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  apply
	{
	 :doc {:description "Applies a function to the specified arguments, after flattening the last argument. Last argument must be a sequential collection, or 'nil' which is considered and empty collection."
         :examples [{:code "(apply + [1 2 3])"}
                    {:code "(apply + 1 2 [3 4 5])"}]
         :type :function
         :signature [{:params [f & args more-args]
                      :return Any}]
         :errors {:CAST "If the first argument is not castable to a valid Function."
                  :ARITY "If the additional arguments cause an arity error in the applied Function."}}
	}

  assoc
	{
	 :doc {:description "Adds entries into an associative data structure, taking each two arguments as key/value pairs. A nil data structure is considered as an empty map."
         :examples [{:code "(assoc {1 2} 3 4)"}]
         :type :function
         :signature [{:params [coll & kvs]
                      :return DataStructure}]
         :errors {:CAST "If the first argument is not a valid DataStructure."
                  :ARITY "If the additional arguments are not an even number (key and value pairs)."
                  :ARGUMENT "If one or more of the supplied keys is invalid for the DataStructure."}}
	}

  assoc-in
	{
	 :doc {:description "Associates a value entries into an nested associative data structure, as if using 'assoc' at each level."
         :examples [{:code "(assoc-in {1 [1 2 3]} [1 2] 4)"}]
         :type :function
         :signature [{:params [coll keys v]
                      :return DataStructure}]
         :errors {:CAST "If the first argument is not a valid DataStructure, or the second argument is not a Sequence."
                  :ARGUMENT "If one or more of the supplied keys is invalid for the DataStructure."}}
	}

  balance
	{
	 :doc {:description "Returns the coin balance of the specified account, which must be an Address. Returns nil if and only the Account does not exist."
         :examples [{:code "(balance *caller*)"}]
         :type :function
         :signature [{:params [address]
                      :return Long}]
         :errors {:CAST "If the argument is not a valid Address."}}
	}

  blob
	{
	 :doc {:description "Casts the argument to a Blob. Handles Addresses, Hashes, existing blobs, and hex Strings"
         :examples [{:code "(blob \"1234abcd\")"}]
         :type :function
         :signature [{:params [address]
                      :return Blob}]
         :errors {:CAST "If the argument is not castable to a Blob."}}
	}

  blob-map
	{
	 :doc {:description "Creates a BlobMap. Blobmaps support blob types as keys only. Optional arguments must be pairs of Blob keys and values, to be included in the BlobMap."
         :examples [{:code "(blob-map 0x1234 :foo)"}]
         :type :function
         :signature [{:params [& kvs]
                      :return BlobMap}]
         :errors {:ARITY "If there are not an even number of arguments (key and value pairs)."
                  :ARGUMENT "If any of the keys supplied is not castable to a Blob."}}
	}

  blob?
	{
	 :doc {:description "Tests if the argument is a Blob."
         :examples [{:code "(blob? 0x1234)"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  boolean
	{
	 :doc {:description "Casts any value to a Boolean. Returns true if the value is truthy, false otherwise."
         :examples [{:code "(boolean 123)"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  boolean?
	{
	 :doc {:description "Tests if the argument is a boolean (either true or false)."
         :examples [{:code "(boolean? false)"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  byte
	{
	 :doc {:description "Casts a value to a Byte. Discards high bits of larger integer types."
         :examples [{:code "(byte 1234)"}]
         :type :function
         :signature [{:params [a]
                      :return Byte}]
         :errors {:CAST "If the argument is not castable to a Byte."}}
	}

  call*
	{
	 :doc {:description "Calls an Actor function. address must cast to Address. offer must cast to Long. (symbol fn-name) must identify an exported function in the target Actor. args must be valid arguments for the called function."
         :examples [{:code "(call* some-actor 1000 'actor-fn arg1 arg2)"}]
         :type :function
         :signature [{:params [address offer fn-name & args]
                      :return Any}]
         :errors {:CAST "If the address argument is an Address, the offer is not a Long, or the function name is not a Symbol."
                  :ARITY "If the supplied arguments are the wrong arity for the called function."
                  :STATE "If the address does not refer to an Account with the callable function specified by fn-name."
                  :ARGUMENT "If the offer is negative."}}
	}

  call
	{
	 :doc {:description "Calls an function in another Account. The specified address must be valid, and refer to an existing account. offer is optional, if provided must cast to Long. call-form must be a valid expression calling an exported function in the target Account."
         :examples [{:code "(call some-contract 1000 (contract-fn arg1 arg2))"}]
         :type :macro
         :signature [{:params [address call-form]
                      :return Any}
                     {:params [address offer call-form]
                      :return Any}]
         :errors {:CAST "If the address argument is an Address, the offer is not a Long, or the function name is not a Symbol."
                  :ARITY "If the supplied arguments are the wrong arity for the called function."
                  :STATE "If the address does not refer to an Account with the callable function specified by fn-name."
                  :ARGUMENT "If the offer is negative."}}
	}

  ceil
  {
    :doc {:description "Computes the mathematical ceiling (rounding up towards positive infinity) for a numerical argument. Uses double precision mathematics."
          :examples [{:code "(ceil 16.3)"}]
          :type :function
          :signature [{:params [x]
                       :return Double}]
          :errors {:CAST "If the argument is not a Number."}}
  }

  char
	{
	 :doc {:description "Casts a value to a Char. Discards high bits of larger integer types."
         :examples [{:code "(char 97)"}]
         :type :function
         :signature [{:params [a]
                      :return Character}]
         :errors {:CAST "If the argument is not castable to a Character."}}
	}

  coll?
	{
	 :doc {:description "Tests if the argument is a Collection. Collections include maps, vectors, lists, sets."
         :examples [{:code "(coll? [1 2 3])"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  cond
	{
	 :doc {:description "Performs conditional tests on successive (test, result) pairs of arguments, returning the result for the first test that succeeds. Performs short-circuit evaluation, i.e. result expressions that are not used and any test expressions after the first success will not be executed. In the case that no test succeeds, a single aditional argument may be added as a fallback value. If no fallback value is available, nil will be returned."
         :examples [{:code "(cond test1 result1 else-value)"}
                    {:code "(cond test1 result1 test2 result2 test3 result-3)"}]
         :type :special
         :signature [{:params []}
                     {:params [test]}
                     {:params [test result]}
                     {:params [test result fallback-value]}
                     {:params [test1 result1 test2 result2 & more]}]}
	}

  compile
	{
	 :doc {:description "Compiles a form, returning an op."
         :examples [{:code "(compile '(fn [x] (* x 2)))"}]
         :type :function
         :signature [{:params [form]
                      :return Op}]
         :errors {:COMPILE "If a compiler error occurs."}}
	}

  concat
	{
	 :doc {:description "Concatenates sequential objects, returning a new sequential object of the same type as the first non-nil argument. Nil is treated as an empty sequence."
         :examples [{:code "(concat [1 2] [3 4])"}]
         :type :function
         :signature [{:params [& seqs]
                      :return DataStructure}]
         :errors {:CAST "If any of the arguments is not a sequential data structure."}}
	}

  conj
	{
	 :doc {:description "Adds elements to a data structure, in the natural mode of addition for the data structure. Supports sequential collections, sets and maps."
         :examples [{:code "(conj [1 2] 3)"}
                    {:code "(conj {1 2} [3 4])"}
                    {:code "(conj #{1 2} 3)"}]
         :type :function
         :signature [{:params [coll & elems]
                      :return DataStructure}]
         :errors {:CAST "If the first argument is not a DataStructure (or nil)."
                  :ARGUMENT "If a provided element is not of correct type for the given data structure."}}
	}

  cons
	{
	 :doc {:description "Constructs a List, by prepending the leading arguments to the last argument. The last argument must be coercable to a sequence."
         :examples [{:code "(cons 1 '(2 3))"}
                    {:code "(cons 1 2 '(3 4))"}]
         :type :function
         :signature [{:params [arg & more-args coll]}]
         :errors {:CAST "If the last argument is not a Sequence."}}
	}

  contains-key?
	{
	 :doc {:description "Tests if the given asccoiative data structure contains the given key."
         :examples [{:code "(contains-key? {:foo 1 :bar 2} :foo)"}]
         :type :function
         :signature [{:params [coll key]
                      :return Boolean}]}
	}

  create-peer
	{
    :doc {:description "Creates a new peer on the network. The peer must have an account number and sufficient balance to place a stake amount"
          :examples [{:code "(create-peer account-key 700000000)"}]
          :type :function
          :signature [{:params [account-key stake-amount]
                       :return stake-amount}]
          :errors {:CAST "If the first argument is not a valid account-key."}}
	}

  count
	{
	 :doc {:description "Counts the number of elements in the given collection. Returns the length of Blobs and Strings."
         :examples [{:code "(count [1 2 3])"}]
         :type :function
         :signature [{:params [coll]
                      :return Long}]
         :errors {:CAST "If the argument is not a countable object."}}
	}

  dec
	{
	 :doc {:description "Decrements the given number by 1. Result is a Long."
         :examples [{:code "(dec 10)"}]
         :type :function
         :signature [{:params [num]
                      :return Long}]
         :errors {:CAST "If the argument is not a Number."}}
	}

  def
	{
	 :doc {:description "Creates a definition in the current environment. This value will persist in the environment owned by the current account. The name argument must be a Symbol, or a Symbol wrapped in a Syntax Object with optional metadata."
         :examples [{:code "(def a 10)"}]
         :type :special
         :signature [{:params [name value]}]
         :errors {:CAST "If the argument is neither a valid Symbol name nor a Syntax containing a Symbol value."}}
	}

  deploy
	{
	 :doc {:description "Deploys an actor. The code provided will be executed to initialise the Actor's account. Returns the Address of the deployed Actor."
         :examples [{:code "(deploy '(do (defn my-fn [x y] (+ x y)) (export my-fn)) )"}]
         :type :function
         :signature [{:params [code]
                      :return Address}]
         :errors {:COMPILE "If a compiler error occurred deploying the given code."}}
	}

  difference
  {
    :doc {:description "Computes the difference of one or more sets. 'nil' is treated as the empty set."
          :examples [{:code "(difference #{1 2} #{2 3})"}]
          :type :function
          :signature [{:params [set & more]
                       :return Set}]
          :errors {:CAST "If any of the arguments is neither a Set nor nil."}}
  }

  disj
	{
	 :doc {:description "Removes a key from a set. If the key does not exist, returns the same set unchanged. nil is treated as the empty Set."
         :examples [{:code "(disj #{1 2 3} 1)"}]
         :type :function
         :signature [{:params [coll key]}]
         :errors {:CAST "If the first argument is not a Set."}}
	}

  dissoc
	{
	 :doc {:description "Removes entries with the specified key(s) from a map. Returns the same map unchanged if the key is not present."
         :examples [{:code "(dissoc {1 2 3 4} 3)"}]
         :type :function
         :signature [{:params [coll & keys]
                      :return Map}]
         :errors {:CAST "If the first argument is not a Map."}}
	}

  do
	{
	 :doc {:description "Executes multiple expressions sequentially, and returns the value of the final expression."
         :examples [{:code "(do (count [1 2 3]) :done)"}]
         :type :special
         :signature [{:params [& expressions]}]}
	}


  double
 	{
	 :doc {:description "Casts any numerical value to a Double."
         :examples [{:code "(double 3)"}]
         :type :function
         :signature [{:params [a]
                      :return Double}]
         :errors {:CAST "If the argument is not castable to Double."}}
	}

  empty
 	{
	 :doc {:description "Returns an empty collection of the same type as the argument. (empty nil) returns nil."
         :examples [{:code "(empty [1 2 3])"}]
         :type :function
         :signature [{:params [coll]
                      :return DataStructure}]
         :errors {:CAST "If the argument is neither nil nor a data structure."}}
	}

  empty?
 	{
	 :doc {:description "Checks if the argument is an empty collection. nil is considered empty. "
         :examples [{:code "(empty? [])"}]
         :type :function
         :signature [{:params [coll]
                      :return Boolean}]
         :errors {:CAST "If the argument is neither nil nor a data structure."}}
	}

  encoding
 	{
	 :doc {:description "Returns the byte encoding for a given value as a Blob. The encoding is the unique canonical binary representation of a value. Encodings may change between Convex versions - it is unwise to rely on the exact representation."
         :examples [{:code "(encoding {1 2})"}]
         :type :function
         :signature [{:params [value]
                      :return Blob}]}
	}

  eval
 	{
	 :doc {:description "Compiles and evaluates a form in the current context."
         :examples [{:code "(eval '(+ 1 2))"}]
         :type :function
         :signature [{:params [form]}]
         :errors {:EXPAND "If an expander error occurred while expanding the form."
                  :COMPILE "If a compiler error occurred evaluating the form."}}
	}

  eval-as
 	{
	 :doc {:description "Compiles and evaluates a form in the environment of the specifed Account. The current Account must have controller privileges to execute this operation."
         :examples [{:code "(eval-as #666 '(+ 1 2))"}]
         :type :function
         :signature [{:params [address form]}]}
	}

  exp
 	{
	 :doc {:description "Returns e raised to the power of the given numerical argument."
         :examples [{:code "(exp 1.0)"}]
         :type :function
         :signature [{:params [x]
                      :return Double}]
         :errors {:CAST "If the argument is not a Number."}}
	}

  expand
 	{
	 :doc {:description "Expands the given form. Uses the specified expander (including macros) as the primary expander if provided, the default *initial-expander* otherwise. If also provided, a continuation expander will be passed to the primary expander, otherwise the primary will be used as its own continuation."
         :examples [{:code "(expand '(if a :truthy :falsey))"}]
         :type :function
         :signature [{:params [form]}
                     {:params [form expander]}
                     {:params [form expander cont]}]}
	}

  exports?
 	{
	 :doc {:description "Tests if a specified actor exports a given symbol name."
         :examples [{:code "(exports? actor-address 'function-name)"}]
         :type :function
         :signature [{:params [actor symbol]}]
         :errors {:CAST "If the actor argument is not an Address."}}
	}

  fail
 	{
	 :doc {:description "Causes execution to fail at the current position. Error type defaults to ASSERT if not specified, and cannot be 'nil'. Error message defaults to nil if not specified. The message may be any value, but the use of short descriptive strings is recommended."
         :examples [{:code "(fail :ASSERT \"Assertion failed\")"}]
         :type :function
         :signature [{:params []}
                     {:params [message]}
                     {:params [error-type message]}]}
	}

  first
 	{
	 :doc {:description "Returns the first element from a collection. Will cause a BOUNDS error if the collection is empty. It can be a good idea to check for this case with `empty?` first."
         :examples [{:code "(first [1 2 3])"}]
         :type :function
         :signature [{:params [coll]}]
         :errors {:CAST "If the first argument is not a countable collection."
                  :BOUNDS "If the collection is empty."}}
	}

  floor
  {
    :doc {:description "Computes the mathematical floor (rounding down towards negative infinity) for a numerical argument. Uses double precision mathematics."
          :examples [{:code "(floor 16.3)"}]
          :type :function
          :signature [{:params [x]
                       :return Double}]}
  }

  fn
 	{
	 :doc {:description "Creates an anonymous function (closure) with the specified argument list and function body. Will close over variables in the current lexical scope."
         :examples [{:code "(let [f (fn [x y] (* x y))] (f 10 7))"}]
         :type :special
         :signature [{:params [args & body]}]}
	}

  fn?
 	{
	 :doc {:description "Tests if the argument is a function. Some arguments may be castable to functions but are not functions themselves, e.g. maps and vectors."
         :examples [{:code "(fn? count)"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  get
 	{
	 :doc {:description "Gets an element from a collection at the specified index value. Works on all collection types including maps, sets and sequences. Nil is treated as an empty collection. If the index is not present, returns not-found value (or nil if not-found is not provided)."
         :examples [{:code "(get {:foo 10 :bar 15} :foo)"}]
         :type :function
         :signature [{:params [coll key]}
                     {:params [coll key not-found]}]}
	}

  get-holding
 	{
	 :doc {:description "Gets the holding value for a specified owner account address. Owner account must exist. Holding will be null by default."
         :examples [{:code "(get-holding *caller*)"}]
         :type :function
         :signature [{:params [owner]}]
         :errors {:CAST "If the argument is not an Address."}}
	}

  get-in
 	{
	 :doc {:description "Gets an element by sucessively looking up keys in a collection according to the logic of get. If any lookup does not find the appropriate key, will return nil (or the not-found value if provided)."
         :examples [{:code "(get-in [[1 2] [3 4]] [1 1])"}]
         :type :function
         :signature [{:params [coll keys]}
                     {:params [coll keys not-found]}]
         :errors {:CAST "If the first argument is not an associative collection."}}
	}

  halt
 	{
	 :doc {:description "Completes execution in the current context with the specified result, or null if not provided. Does not roll back any state changes made. If the currently executing context is an actor, the result will be used as the return value from the actor call."
         :examples [{:code "(halt :we-are-finished-here)"}]
         :type :function
         :signature [{:params []}
                     {:params [result]}]}
	}

  hash
  {
	 :doc {:description "Calculates the 32-byte SHA3-256 cryptographic Hash of a Blob. Also works with Hash and Address arguments (since these are specialised types of Blob)."
         :examples [{:code "(hash 0x1234)"}
                    {:code "(hash (encoding :foo))"}]
         :type :function
         :signature [{:params [value]
                      :return Blob}]}
	}

  hash?
  {
	 :doc {:description "Tests if the given value is a Hash. A Hash is a specialised type of Blob"
         :examples [{:code "(hash? (hash 0x1234))"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  hash-map
  {
	 :doc {:description "Constructs a hash map with the given keys and values. If a key is repeated, the last value will overwrite previous ones."
         :examples [{:code "(hash-map 1 2 3 4)"}]
         :type :function
         :signature [{:params [& kvs]}]
         :errors {:ARITY "If the number of arguments is not even (key and value pairs)."}}
	}

  hash-set
  {
	 :doc {:description "Constructs a Set with the given values. If a value is repeated, it will be included only once in the set."
         :examples [{:code "(hash-set 1 2 3)"}]
         :type :function
         :signature [{:params [& values]}]}
	}


  inc
	{
	 :doc {:description "Increments the given number by 1. Converts to Long if necessary."
         :examples [{:code "(inc 10)"}]
         :type :function
         :signature [{:params [num]
                      :return Long}]
         :errors {:CAST "If the actor argument is not a Number."}}
	}

  intersection
  {
    :doc {:description "Computes the intersection of one or more sets. 'nil' is treated as the empty set."
          :examples [{:code "(intersection #{1 2} #{2 3})"}]
          :type :function
          :signature [{:params [set & more]
                       :return Set}]
          :errors {:CAST "If any of the arguments is neither a Set nor nil."}}
  }

  into
	{
	 :doc {:description "Adds elements to a collection, in a collection-defined manner as with 'conj'."
         :examples [{:code "(into {} [[1 2] [3 4]])"}]
         :type :function
         :signature [{:params [coll elements]
                      :return DataStructure}]
         :errors {:CAST "If either argument is not a DataStructure."
                  :ARGUMENT "If any of the elements is not a valid type for the given data structure."}}
	}

  keys
	{
	 :doc {:description "Returns a vector of keys in the given map, in the map defined order."
         :examples [{:code "(keys {:foo 1 :bar 2})"}]
         :type :function
         :signature [{:params [m]
                      :return Vector}]
         :errors {:CAST "If the argument is not a Map."}}
	}

  keyword
	{
	 :doc {:description "Coerces the argument to a keyword."
         :examples [{:code "(keyword \"foo\")"}]
         :type :function
         :signature [{:params [name]
                      :return Keyword}]
         :errors {:CAST "If the argument is not of a type castable to Keyword."
                  :ARGUMENT "If the Keyword name is of illegal length."}}
	}


  keyword?
	{
	 :doc {:description "Tests if the argument is a Keyword."
         :examples [{:code "(keyword? :foo)"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  last
	{
	 :doc {:description "Returns the last element of a data structure, in collection-defined order. Collection argument must be coercible to a sequence."
         :examples [{:code "(last [1 2 3])"}]
         :type :function
         :signature [{:params [coll]}]
         :errors {:CAST "If the argument is not a DataStructure."}}
	}

  let
  {
	 :doc {:description "Binds local variables according to symbol / expression pairs in a binding vectors, then execute following expressions in an implicit do block."
         :examples [{:code "(let [x 10] (* x x))"}]
         :type :special
         :signature [{:params [bindings & exps]}]
         }
	}

  list
	{
	 :doc {:description "Creates a List containing the given arguments as elements."
         :examples [{:code "(list 1 2 3)"}]
         :type :function
         :signature [{:params [& elements]
                      :return List}]}
	}

  list?
	{
	 :doc {:description "Tests if the argument is a List data structure."
         :examples [{:code "(list? :foo)"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  log
  {
	 :doc {:description "Outputs a sequence of values to the Convex log for the current Account. Any valid CVM values can be logged. Returns the Vector of values logged."
         :examples [{:code "(log :EVENT 123 [:some :data])"}]
         :type :function
         :signature [{:params [& values]
                      :return Vector}]}
	}

  long
  {
	 :doc {:description "Casts the given argument to a 64-bit signed Long."
         :examples [{:code "(long 10)"}]
         :type :function
         :signature [{:params [num]}]
         :errors {:CAST "If the argument is not castable to Long."}}
	}


  long?
	{
	 :doc {:description "Tests if the argument is a Long value."
         :examples [{:code "(long? 1234)"}]
         :type :function
         :signature [{:params [a]
                      :return Boolean}]}
	}

  lookup
  {
    :doc {:description "Looks up the value of a Symbol in the current execution environment, or the account of the given address if specified."
          :examples [{:code "(do (def a 13) (lookup a))"}
                     {:code "(lookup #8 count)"}]
          :type :special
          :signature [{:params [sym]}
                      {:params [address sym]}]
          :errors {:COMPILE "If the last argument is not a Symbol."
                   :CAST "If the optional Address expression does not produce a valid Address."
                   :NOBODY "If the target Account for lookup does not exist."}}
  }

  lookup-meta
  {
    :doc {:description "Looks up metadata for a symbol in the current execution environment, or the account of the given address if specified. Name may be a symbol, keyword or String. Returns nil if not found."
          :examples [{:code "(lookup-meta 'count)"}]
          :type :function
          :signature [{:params [name]}
                      {:params [address name]}]}
  }

  loop
	{
	 :doc {:description "Creates a loop body, binding one or more loop variables in a manner similar to 'let'. Within the loop body, 'recur' can be used to return to the start of the loop while re-binding the loop variables with new values. Does not consume stack."
         :examples [{:code "(loop [i 10 acc 1] (if (> i 1) (recur (dec i) (* acc i)) acc))"}]
         :type :special
         :signature [{:params [bindings & body]}]}
	}

  macro
  {
    :doc {:description "Creates a macro expansion procedure. When used in a function call position, the macro procedure will expand to the given expression, which should be a compilable form."
          :examples [{:code "(macro [x] '(or x y))"}]
          :type :macro
          :signature [{:params [params & body]}]}
  }

  map
  {
    :doc {:description "Applies a function to each element of a data structure in sequence, and returns a vector of results. Additional collection may be provided to call a function with higher arity."
          :examples [{:code "(map inc [1 2 3])"}]
          :type :function
          :signature [{:params [f coll]}
                      {:params [f coll1 coll2 & more-colls ]}]}
  }

  map?
  {
    :doc {:description "Tests if an object is a map data structure."
          :examples [{:code "(map? {1 2})"}]
          :type :function
          :signature [{:params [coll]
                       :return Boolean}]}
  }

  merge
  {
    :doc {:description "Merges zero or more hashmaps, replacing existing values. nil is considered as an empty map."
          :examples [{:code "(merge {1 2 3 4} {3 5 7 9})"}]
          :type :function
          :signature [{:params [& maps]}]}
  }

  meta
  {
    :doc {:description "Returns metadata for a Syntax Object. Returns nil if the argument is not a Syntax Object."
          :examples [{:code "(meta (syntax 'foo {:bar 1}))"}]
          :type :function
          :signature [{:params [syntax]
                       :return Map}]}
  }

  mod
  {
    :doc {:description "Returns the integer modulus of a numerator divided by a divisor. The result will always be positive, in consistent with Euclidean Divsion."
          :examples [{:code "(mod 13 5)"}]
          :type :function
          :signature [{:params [num div]}]}
  }

  nan?
  {:doc {:description "Tests if the value provided is ##NaN. Returns false for any other value (including non-numerical arguments)."
         :examples [{:code "(nan? ##NaN)"}]
         :type :function
         :signature [{:params [x]
                      :return Boolean}]
         }}

  name
  {
    :doc {:description "Gets the String name of an object. Valid names can come from Strings, Keywords or Symbols."
          :examples [{:code "(name :foo)"}]
          :type :function
          :signature [{:params [named-object]
                       :return String}]
          :errors {:CAST "If the argument is not castable to a String name."}}
  }

  next
  {
    :doc {:description "Returns the elements of a sequential data structure after the first, or null if no more elements remain."
          :examples [{:code "(next [1 2 3])"}]
          :type :function
          :signature [{:params [coll]
                       :return Sequence}]
          :errors {:CAST "If the argument is not a Sequence."}}
  }

  nil?
  {
    :doc {:description "Tests if the argument is nil."
          :examples [{:code "(nil? nil)"}]
          :type :function
          :signature [{:params [a]
                       :return Boolean}]}
  }

  not
  {
    :doc {:description "Inverts a truth value. Returns false for truthy input and true for falsey input."
          :examples [{:code "(not true)"}
                     {:code "(not nil)"}]
          :type :function
          :signature [{:params [b]
                       :return Boolean}]}
  }

  nth
  {
    :doc {:description "Gets the nth element of a countable data structure. The index must be a valid long between 0 (inclusive) and the element count of the collection (exclusive)."
          :examples [{:code "(nth [1 2 3] 2)"}]
          :type :function
          :signature [{:params [coll index]}]
          :errors {:CAST "If the first argument is not countable data structure."}}
  }

  number?
  {
    :doc {:description "Returns true if the argument is a numeric value, false otherwise."
          :examples [{:code "(number? 2.3)"}]
          :type :function
          :signature [{:params [a]
                       :return Boolean}]}
  }

  pow
  {
    :doc {:description "Returns the first argument raised to the power of the second argument. Uses double precision maths."
          :examples [{:code "(pow 2 3)"}]
          :type :function
          :signature [{:params [x y]
                       :return Double}]
          :errors {:CAST "If the argument is not a Number."}}
  }

  quasiquote
  {
    :doc {:description "Returns the quoted value of a form, without evaluating it. Like 'quote', but elements within the form may be unquoted."
          :examples [{:code "(quasiquote foo)"}
                     {:code "`(:a :b ~(+ 2 3))"}]
          :type :special
          :signature [{:params [form]}]}
    :expander true
  }


  query
  {
    :doc {:description "Runs forms in query mode. Results will be retained, but any state changes will be rolled back."
          :examples [{:code "(query (def a 10) a)"}
                     {:code "(query (call unsafe-actor (do-something)))"}]
          :type :special
          :signature [{:params [& forms]}]}
  }

  quot
  {
    :doc {:description "Returns the quotient of a numerator divided by a divisor. Performs truncated division, i.e. rounds towards zero."
          :examples [{:code "(quot 13 5)"}]
          :type :function
          :signature [{:params [num div]}]}
  }

  quote
  {
    :doc {:description "Returns the quoted value of a form, without evaluating it. For example, you can quote a symbol to get the symbol itself rather than the value in the environment that it refers to."
          :examples [{:code "(quote foo)"}
                     {:code "(eval (quote (+ 1 2 3)))"}]
          :type :special
          :signature [{:params [form]}]}
    :expander true
  }

  recur
  {
    :doc {:description "Escapes from the currently executing code and recurs at the level of the next loop or function body."
          :examples [{:code "(recur acc (dec i))"}]
          :type :special
          :signature [{:params [x y]}]}
  }

  reduce
  {
    :doc {:description "Reduces over a collection data structure, calling an arity 2 function with the accumulated value and each element. If an initial accumulator value is not supplied, the initial value will be determined by calling the function on the first 0, 1 or 2 elements of the collection (however many are available)."
          :examples [{:code "(reduce (fn [acc x] (* acc x)) 1 [1 2 3 4 5])"}]
          :type :function
          :signature [{:params [f coll]}
                      {:params [f init coll]}]
          :errors {:CAST "If the first argument is not a function, or the final argument is not a sequential collection."}}
  }

  reduced
  {
    :doc {:description "Returns immediately from the enclosing 'reduce' function, providing the given value as the result of the whole reduce operation. This can be used to terminate early from a reduce operation, saving transaction costs."
          :examples [{:code "(reduce (fn [acc x] (reduced :exit)) 1 [1 2 3 4 5])"}]
          :type :function
          :signature [{:params [result]}]}
  }

  rem
  {
    :doc {:description "Returns the remainder of a numerator divided by a divisor, consistent with division performed by 'quot'. The remainder will therefore have the same sign as the numerator."
          :examples [{:code "(rem 13 5)"}]
          :type :function
          :signature [{:params [num div]}]}
  }

  return
  {
    :doc {:description "Escapes from the currently executing code and returns the specified value from the current function. Expressions following the 'return' will not be executed."
          :examples [{:code "(return :finished)"}]
          :type :special
          :signature [{:params [value]}]}
  }

  reverse
  {
    :doc {:description "Reverses a Sequence. Lists are converted to Vector, and vice versa for efficieny reasons. nil is treated as an empty Vector."
          :examples [{:code "(reverse [1 2 3])"}]
          :type :special
          :signature [{:params [value]
                       :return Sequence}]}
  }

  rollback
  {
    :doc {:description "Escapes from the currently executing smart contract. Rolls back any state changes. Returns the given value."
          :examples [{:code "(rollback :aborted)"}]
          :type :special
          :signature [{:params [val]}]}
  }

  schedule
  {
    :doc {:description "Schedules a form for future execution under this account. Expands and compiles form now, but does not execute until the specified timestamp."
          :examples [{:code "(schedule (+ *timestamp* 1000) (transfer my-friend 1000000))"}]
          :type :macro
          :signature [{:params [timestamp code]}]}
  }

  schedule*
  {
    :doc {:description "Schedules a form for future execution under this account. Expands and compiles form now, but does not execute until the specified timestamp."
          :examples [{:code "(schedule* (+ *timestamp* 1000) '(transfer my-friend 1000000))"}]
          :type :function
          :signature [{:params [timestamp code]}]}
  }

  second
  {
    :doc {:description "Returns the second element of a countable collection."
          :examples [{:code "(second [1 2 3])"}]
          :type :function
          :signature [{:params [coll]}]
          :errors {:CAST "If the argument is not a countable collection."
                   :BOUNDS "If the argument does not have a second value"}}
  }

  set
  {
    :doc {:description "Coerces any data structure to a Set."
          :examples [{:code "(set [1 2 3])"}]
          :type :function
          :signature [{:params [coll]
                       :return Set}]
          :errors {:CAST "If the argument is not a countable data structure."}}
  }

  set!
  {:doc {:description "Sets a local binding identified by an unqualified symbol to the given value. This local change will be be visible until the scope leaves the current binding form (e.g. let binding, function body or recur). Fails with an ARGUMENT error if the symbol is qualified. This is probably most useful for updating a local variable in imperative style. Returns the value assigned to the local binding if successful."
          :examples [{:code "(let [a 10] (set! a 20) a)"}]
          :type :special
          :signature [{:params [sym value]}]}
  }

  set-controller
  {
    :doc {:description "Sets the controller for the current Account. The controller account is granted powerful access privileges including the ability to run 'eval-as'. May set controller to 'nil' to disable such control (this is the default for new accounts)."
          :examples [{:code "(set-controller #9)"}]
          :type :function
          :signature [{:params [addr]}]
          :errors {:CAST "If the argument is neither a valid Address nor nil"
                   :NOBODY "If the address does nott refer to an existing Account."}}
  }

  set-holding
 	{
	 :doc {:description "Sets the holding value for a specified owner account address. Owner account must exist. Returns the new holding value."
         :examples [{:code "(set-holding *caller* 1000)"}]
         :type :function
         :signature [{:params [owner value]}]
         :errors {:CAST "If the first argument is not an Address."}}
	}

  set-key
 	{
	 :doc {:description "Sets the public key for this Account. May set to 'nil' to turn this account into an Actor and disable future external transactions. WARNING: You may lose access to the Account if you do not have access to the associated private key."
         :examples [{:code "(set-key *caller* 1000)"}]
         :type :function
         :signature [{:params [new-key]}]}
	}


  set-memory
 	{
	 :doc {:description "Sets the free memory allowance for the current Account address, in number of bytes. Increases in memory allowance may cost coin balance. Decreases in memory allowance may earn a coin refund."
         :examples [{:code "(set-memory 10000)"}]
         :type :function
         :signature [{:params [mem]}]}
	}

  set-peer-data
  {
    :doc {:description "Sets metadata on a given peer. Metadata must be a Map. Peer must exist, with a public account key. "
          :examples [{:code "(set-peer-data peer-key {:url \"my-peer.com:4242\"})"}]
          :type :function
          :signature [{:params [peer map]}]
          :errors {:CAST "If the first argument is not a valid Peer Key, or the second argument is not a map."}}
  }
  
  set-peer-stake
  {
    :doc {:description "Sets the Peer Stake. Stake must be a Long. Peer must exist, with a public account key. "
          :examples [{:code "(set-peer-data peer-key {:url \"my-peer.com:4242\"})"}]
          :type :function
          :signature [{:params [peer stake]}]
          :errors {:CAST "If the first argument is not a valid Peer Key, or the second argument is not a Long."}}
  }

  set?
  {
    :doc {:description "Tests if the agument is a Set."
          :examples [{:code "(set? #{1 2 3})"}]
          :type :function
          :signature [{:params [a]
                       :return Boolean}]}
  }

  signum
  {
    :doc {:description "Returns the signum of a numeric value, defined to be -1, 0 or 1. Results in a cast error if the argument is not a number (including ##NaN)."
          :examples [{:code "(signum -1)"}]
          :type :function
          :signature [{:params [a]
                       :return Double}]}
  }

  sqrt
  {
    :doc {:description "Computes the square root of a numerical argument. Uses double precision mathematics. May return NaN for negative values."
          :examples [{:code "(sqrt 16.0)"}]
          :type :function
          :signature [{:params [x]
                       :return Double}]}
  }

  stake
  {
    :doc {:description "Sets the stake on a given peer. Peer must exist, and funds must be available to set the stake to the specified level. Setting stake to zero removes the stake entirely."
          :examples [{:code "(stake trusted-peer-account-key 7000000000)"}]
          :type :function
          :signature [{:params [account-key amount]}]}
  }

  str
  {
    :doc {:description "Coerces values to Strings and concatenates them."
          :examples [{:code "(str \"Hello \" name)"}]
          :type :function
          :signature [{:params [& args]
                       :return String}]}
  }

  str?
  {
    :doc {:description "Tests if the argument is a String."
          :examples [{:code "(str? name)"}]
          :type :function
          :signature [{:params [a]
                       :return Boolean}]}
  }

  subset?
  {
    :doc {:description "Tests if a set is a subset of a second set. Both arguments must be sets. nil is considered as an empty set."
          :examples [{:code "(subset? #{1} #{1 2 3})"}]
          :type :function
          :signature [{:params [set1 set2]
                       :return Boolean}]}
  }

  symbol
  {
    :doc {:description "Creates a Symbol. Supports Symbols, Keywords and short Strings. An optional path may be provided, which must be a valid Symbol name, and Address, or null for an unqualified Symbol."
          :examples [{:code "(symbol :foo)"}]
          :type :function
          :signature [{:params [name]
                       :return Symbol}
                      {:params [path name]
                       :return Symbol}]}
  }

  str?
  {
    :doc {:description "Tests if the argument is a String."
          :examples [{:code "(str? \"foo\")"}]
          :type :function
          :signature [{:params [a]
                       :return Boolean}]}
  }

  symbol?
  {
    :doc {:description "Tests if the argument is a Symbol."
          :examples [{:code "(symbol? 'foo)"}]
          :type :function
          :signature [{:params [a]
                       :return Boolean}]}
  }

  syntax
  {
    :doc {:description "Wraps a value as a Syntax Object, if it is not already a Syntax Object. If metadata is provided, merge the metadata into the resulting Syntax Object."
          :examples [{:code "(syntax 'bar)"}]
          :type :function
          :signature [{:params [value]
                       :return Syntax}
                      {:params [value meta]
                       :return Syntax}]}
  }

  syntax?
  {
    :doc {:description "Tests if the argument is a Syntax Object."
          :examples [{:code "(syntax? form)"}]
          :type :function
          :signature [{:params [a]
                       :return Boolean}]}
  }

  tailcall*
  {:doc {:description "Calls a function as a tail call. Will return from the current function with the result of the tail call, without consuming additional stack depth."
          :examples [{:code "(tailcall* + 1 2 3)"}]
          :type :function
          :signature [{:params [f & args] }]}
  }

  transfer
  {
    :doc {:description "Transfers the specified amount of coins to the target-address. Returns the amount transferred if successful. Returns FUNDS error if there is insufficient balance in the sender's account. Returns STATE error if the reciever is an Actor that is unable to accept funds."
          :examples [{:code "(transfer my-friend-address 12345678)"}]
          :type :function
          :signature [{:params [address amount]
                       :return Long}]}
  }

  transfer-memory
  {
    :doc {:description "Transfers the specified amount of memory allowance to the target address. Returns the amount transferred if successful. Returns MEMORY error if there is insufficient balance in the sender's account."
          :examples [{:code "(transfer-memory my-friend-address 100)"}]
          :type :function
          :signature [{:params [address amount]
                       :return Long}]}
  }

  undef*
  {
     :doc {:description "Undefines a symbol, removing the mapping from the current environment if it exists. Helper function for the 'undef' macro."
           :examples [{:code "(undef* 'a)"}]
           :type :function
           :signature [{:params [sym]}]}
  }

  union
  {
    :doc {:description "Computes the union of zero or more sets. 'nil' is treated as the empty set."
          :examples [{:code "(union #{1 2} #{2 3})"}]
          :type :function
          :signature [{:params [& sets]
                       :return Set}]}
  }

  unsyntax
  {
    :doc {:description "Unwraps a value from a syntax object. If the argument is not a Syntax Object, returns it unchanged."
          :examples [{:code "(unsyntax form)"}]
          :type :function
          :signature [{:params [form]}]}
  }

  values
  {
    :doc {:description "Gets the values from a map data structure."
          :examples [{:code "(values {1 2 3 4})"}]
          :type :function
          :signature [{:params [m]
                       :return Vector}]}
  }

  vec
  {
    :doc {:description "Coerces the argument to a Vector. Arguement must be coercible to a sequence."
          :examples [{:code "(vec #{1 2 3 4})"}]
          :type :function
          :signature [{:params [coll]
                       :return Vector}]}
  }

  vector
  {
    :doc {:description "Creates a Vector with the given elements."
          :examples [{:code "(vector 1 2 3)"}]
          :type :function
          :signature [{:params [& elements]
                       :return Vector}]}
  }

  vector?
  {
    :doc {:description "Tests if the argument is a Vector."
          :examples [{:code "(vector? [1 2 3])"}]
          :type :function
          :signature [{:params [a]
                       :return Boolean}]}
  }

  zero?
  {
    :doc {:description "Tests if the argument has the numeric value zero. Returns false for any non-numeric values."
          :examples [{:code "(zero? 0.1)"}]
          :type :function
          :signature [{:params [x]
                       :return Boolean}]}
  }

  *initial-expander*
  {
     :doc {:description "The initial expander used to expand forms."
           :examples [{:code "(expand '(if 1 2 3) *initial-expander*)"}]
           :type :expander
           :signature [{:params [form cont]}]}
  }

  <
  {
     :doc {:description "Tests if numeric arguments are in strict increasing order. Reads as 'less-than'."
           :examples [{:code "(< 1 2 3)"}]
           :type :function
           :signature [{:params [& xs]
                        :return Boolean}]}
  }

  >
  {
     :doc {:description "Tests if numeric arguments are in strict decreasing order. Reads as 'greater-than'."
           :examples [{:code "(> 3 2 1)"}]
           :type :function
           :signature [{:params [& xs]
                        :return Boolean}]}
  }

  <=
  {
     :doc {:description "Tests if numeric arguments are in increasing order. Reads as 'less-than-or-equal'."
           :examples [{:code "(<= 1 1 3)"}]
           :type :function
           :signature [{:params [& xs]
                        :return Boolean}]}
  }

  >=
  {
     :doc {:description "Tests if numeric arguments are in decreasing order. Reads as 'greater-than-or-equal'."
           :examples [{:code "(>= 3 2 2)"}]
           :type :function
           :signature [{:params [& xs]
                        :return Boolean}]}
  }

  ==
  {
     :doc {:description "Tests if arguments are equal in numerical value."
           :examples [{:code "(== 2 2.0)"}]
           :type :function
           :signature [{:params [& xs]
                        :return Boolean}]}
  }

  =
  {
     :doc {:description "Tests if arguments are equal in value."
           :examples [{:code "(= :foo :foo)"}]
           :type :function
           :signature [{:params [& vals]
                        :return Boolean}]}
  }

  +
  {
     :doc {:description "Adds numerical arguments. Result will be a Long if all all integer, or a double if any floating point values are included."
           :examples [{:code "(+ 1 2 3)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }

  -
  {
     :doc {:description "Subtracts numerical arguments from the first argument. Negates a single argument."
           :examples [{:code "(- 10 7)"}]
           :type :function
           :signature [{:params [x]}
                       {:params [x y & more]}]}
  }

  *
  {
     :doc {:description "Multiplies numeric arguments. Result will be a Double if any arguments are Doubles, otherwise it will be a Long."
           :examples [{:code "(* 1 2 3 4 5)"}]
           :type :function
           :signature [{:params [& xs]}]}
  }

  *address*
  {
     :doc {:description "Returns the Address of the current Account. This will be the User address in a newly submitted transaction, or the Actor if an Actor call is being executed."
           :examples [{:code "(address? *address*)"}]
           :type :special}
     :special-symbol true
  }

  *aliases*
  {
     :doc {:description "Returns the map of aliases in the current enviornment. Aliases enable symbols with namespaces e.g. 'library/foo' enables lookup of the symbol 'foo' via the 'library' alias."
           :examples [{:code "*aliases*"}]
           :type :special}
     :special-symbol true
  }

  *memory*
  {
     :doc {:description "Gets the current Memory Allowance for this Account. May be zero - in which case any new memory allocations will be charged at the current memory exchange pool price."
           :examples [{:code "*memory*"}]
           :type :special}
     :special-symbol true
  }

  *balance*
   {
     :doc {:description "Returns the available balance of the current account. Functionally equivalent to '(balance *address*)', but cheaper to execute. Note that the available balance excludes reserved balance for transaction execution, so this number may be somewhat less than the total account balance during transaction execution."
           :examples [{:code "*balance*"}]
           :type :special}
     :special-symbol true
  }

   *caller*
   {
     :doc {:description "Returns the Address of the caller Account, or nil if this is a top-level User transaction. If an Actor or User makes an Actor call, they will be the caller for the duration of execution in the context of the called code."
           :examples [{:code "*caller*"}]
           :type :special}
     :special-symbol true

  }

  *depth*
  {
     :doc {:description "Returns the CVM execution stack depth, at the point the *depth* operation is executed. If the depth becomes too deep, the transaction will fail with a DEPTH exception. In most cases, the allowable depth should be sufficient."
           :examples [{:code "*depth*"}]
           :type :special}
     :special-symbol true
  }

  *holdings*
   {
     :doc {:description "Returns the holdings map for this Account. Holdings are data values controlled by other Accounts (usually Actors, e.g. Token contracts). They can be used to indicate that an Account may have special rights or holdings with respect to a specific Actor, although this interpretation is Actor-specific."
           :examples [{:code "*holdings*"}]
           :type :special}
     :special-symbol true
  }

   *juice*
   {
     :doc {:description "Returns the amount of execution juice remaining at this point of the current transaction. Juice is required for every CVM operation executed, and the transaction will fail immediately with a JUICE error if an attempt is made to consume juice beyond this value."
           :examples [{:code "*juice*"}]
           :type :special}
     :special-symbol true
  }

   *key*
   {
     :doc {:description "Returns the public key for this Account. May be null (e.g. for an Actor)."
           :examples [{:code "*key*"}]
           :type :special}
     :special-symbol true
  }

  *offer*
  {
     :doc {:description "Returns the amount of native coin offered by *caller* to the currently running Actor. Will usually be zero, unless the caller has included an offer with a 'call' expression. The Actor may take up to this amount using 'accept'."
           :examples [{:code "*offer*"}]
           :type :special}
     :special-symbol true
  }

  *origin*
  {
     :doc {:description "Returns the Address of the account that initially signed this transaction. Usually, you should NOT use this for access control, since a rogue Actor can potentially trick a User into creating a transaction that allows code to be indirectly executed. Consider using *caller* for access control instead."
           :examples [{:code "*origin*"}]
           :type :special}
     :special-symbol true
  }

   *result*
  {
     :doc {:description "Returns the result of the last CVM operation executed. Can be used, in some cases, to access the value of the previous expression. Will be nil for new transactions, or at the start of an Actor call."
           :examples [{:code "(do 1 *result*)"}]
           :type :special}
     :special-symbol true
  }

  *sequence*
  {
     :doc {:description "Returns the current sequence number for this account. The sequence number is equal to the number of signed transactions executed. The next valid sequence number is (*sequence* + 1)."
           :examples [{:code "*sequence*"}]
           :type :special}
     :special-symbol true
  }

   *state*
  {
     :doc {:description "Returns the current CVM state record. This is a very large object, and should normally only be used temporarily to look up relevant values."
           :examples [{:code "(keys *state*)"}
                      {:code "(get-in *state* [:accounts *address* :balance])"}]
           :type :special}
     :special-symbol true
  }

  *timestamp*
  {
     :doc {:description "Returns the current timestamp. The timestamp is a Long value that is equal to the greatest timestamp of any block executed (including the current block). A timestamp can be interpreted as the number of milliseconds since January 1, 1970, 00:00:00 GMT. The block timestamp should always be less than or equal to the Unix timestamp of Peers that are in consensus."
           :examples [{:code "*timestamp*"}]
           :type :special}
     :special-symbol true
  }

  /
  {
	 :doc {:description "Double precision point divide. With a single argument, returns the reciprocal of a number. With multiple arguments, divides the first argument by the others in order."
         :examples [{:code "(/ 10 3)"}]
         :type :function
         :signature [{:params [divisor]}
                     {:params [numerator divisor]}
                     {:params [numerator divisor & more]}]}
	}

}
