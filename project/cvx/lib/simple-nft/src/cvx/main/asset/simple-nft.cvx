;;
;;
;; Simple NFT library
;;
;; simple-nft enables the creation of minimal NFT token
;; 
;; The NFT itself is an asset with the designator [simple-nft-actor id]
;;
;;


(call *registry*
      (cns-update 'asset.simple-nft
                  *address*))


(call *registry*
      (register {:name "Simple NFT Library"}))


(def counter 0)

;; map of {owner -> {recipient-address -> id-set}}
(def offers {})

(defn offer [receiver quantity]
  (let [caller-offers (get offers *caller* {})]
    (def offers (assoc offers *caller* (assoc caller-offers receiver quantity)))))

(defn accept [sender quantity]
  
  (let [sender (address sender)
        sender-offers (get offers sender {})  
        offer (or (get-in offers [sender *caller*]) #{})
        _ (assert (subset? quantity offer))
        receiver-balance (or (get-holding *caller*) #{})
        new-offer (difference offer quantity)]
     (def offers (assoc offers sender (assoc sender-offers *caller* new-offer)))
     (internal-direct-transfer sender *caller* quantity)))

(defn direct-transfer [receiver quantity]
  (internal-direct-transfer *caller* receiver quantity))

;; Internal transfer implementation. Must not be accessible from outside!
(defn internal-direct-transfer [sender receiver quantity]
  (let [receiver (address receiver)
        sender-balance (or (get-holding sender) #{})
        _ (assert (subset? quantity sender-balance))
        receiver-balance (or (get-holding receiver) #{})
        new-sender-balance (difference sender-balance quantity)
        new-receiver-balance (union receiver-balance quantity)
        ]
    (set-holding sender new-sender-balance)
    (set-holding receiver new-receiver-balance))
    quantity)

;; Library function to create a NFT. Metadata for the NFT is option, will be nil if not specifies
(defn create 
  ([]
    (call ~*address* (create-nft))))

;; Contract to create a new NFT, with a fresh ID and arbitrary metadata
(defn create-nft 
  ([]
    (let [id counter
          owner *caller*
          owned-nfts (or (get-holding owner) #{})]
      (set-holding owner (conj owned-nfts id))
      (def counter (inc counter))
      id))) 

;; Destroys a set of NFTs. NFTs must be owned by the caller.  
(defn burn [nft-set]
  (let [owned-nfts (get-holding *caller*)
        nft-set (cond
                  (long? nft-set) #{nft-set}
                  (set? nft-set) nft-set
                  (set nft-set))]
    (if (subset? nft-set owned-nfts) :OK (fail :TRUST "Trying to burn nfts which are not owned!"))
    (set-holding *caller* (difference owned-nfts nft-set))
    (def metadata (reduce (fn [md nft] ((dissoc md nft))) metadata nft-set))
    nft-set))

(defn balance [owner]
  (or (get-holding owner) #{}))

(defn owns? [owner nfts]
  (subset? nfts (get-holding owner)))

(def quantity-add union)

(def quantity-sub difference)

(def quantity-subset? subset?)


(export balance create-nft burn quantity-add quantity-sub quantity-subset? offer accept direct-transfer)
